// PlayerUnknown's Battlegrounds (3.5.7.7) SDK

#ifdef _MSC_VER
	#pragma pack(push, 0x8)
#endif

#include "PUBG_TslGame_parameters.hpp"

namespace PUBG
{
//---------------------------------------------------------------------------
//Functions
//---------------------------------------------------------------------------

// Function TslGame.TslPopupInterface.SetPopup
// (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPopupStyle                    PopupStyle                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Message                        (ConstParm, Parm, OutParm, ReferenceParm)
// struct FScriptDelegate         PressedDelegate                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UTslPopupInterface::SetPopup(EPopupStyle PopupStyle, const struct FText& Message, const struct FScriptDelegate& PressedDelegate)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(13559);

	UTslPopupInterface_SetPopup_Params params;
	params.PopupStyle = PopupStyle;
	params.Message = Message;
	params.PressedDelegate = PressedDelegate;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.WidgetToggle
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 WidgetName                     (Parm, ZeroConstructor)

void ATslBaseHUD::WidgetToggle(const struct FString& WidgetName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14222);

	ATslBaseHUD_WidgetToggle_Params params;
	params.WidgetName = WidgetName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.WidgetShow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 WidgetName                     (Parm, ZeroConstructor)
// EWidgetShowType                ShowType                       (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 OptionalParam                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslBaseHUD::WidgetShow(const struct FString& WidgetName, EWidgetShowType ShowType, class UObject* OptionalParam)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14217);

	ATslBaseHUD_WidgetShow_Params params;
	params.WidgetName = WidgetName;
	params.ShowType = ShowType;
	params.OptionalParam = OptionalParam;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.WidgetCreate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 WidgetName                     (Parm, ZeroConstructor)
// struct FTslWidgetConfig        Config                         (Parm)

void ATslBaseHUD::WidgetCreate(const struct FString& WidgetName, const struct FTslWidgetConfig& Config)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14214);

	ATslBaseHUD_WidgetCreate_Params params;
	params.WidgetName = WidgetName;
	params.Config = Config;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.UpdateKillcamDisplayCode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKillcamDisplayCode            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EKillcamDisplayCode ATslBaseHUD::UpdateKillcamDisplayCode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14211);

	ATslBaseHUD_UpdateKillcamDisplayCode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseHUD.UpdateHud
// (Final, Native, Public, BlueprintCallable)

void ATslBaseHUD::UpdateHud()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14210);

	ATslBaseHUD_UpdateHud_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.UnbindActionKeyDelegateEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ActionName                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<EInputEvent>       InputEvent                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslBaseHUD::UnbindActionKeyDelegateEvent(const struct FName& ActionName, TEnumAsByte<EInputEvent> InputEvent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14207);

	ATslBaseHUD_UnbindActionKeyDelegateEvent_Params params;
	params.ActionName = ActionName;
	params.InputEvent = InputEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.TestShowDialog
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 Message                        (Parm, ZeroConstructor)

void ATslBaseHUD::TestShowDialog(const struct FString& Message)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14205);

	ATslBaseHUD_TestShowDialog_Params params;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.ShowPopupDialog
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FString                 PopupWidgetName                (Parm, ZeroConstructor)
// EPopupStyle                    PopupStyle                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Message                        (Parm)
// struct FScriptDelegate         PressedDelegate                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void ATslBaseHUD::ShowPopupDialog(const struct FString& PopupWidgetName, EPopupStyle PopupStyle, const struct FText& Message, const struct FScriptDelegate& PressedDelegate)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14199);

	ATslBaseHUD_ShowPopupDialog_Params params;
	params.PopupWidgetName = PopupWidgetName;
	params.PopupStyle = PopupStyle;
	params.Message = Message;
	params.PressedDelegate = PressedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.ShowDefaultHud
// (Final, Native, Public, BlueprintCallable)

void ATslBaseHUD::ShowDefaultHud()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14198);

	ATslBaseHUD_ShowDefaultHud_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.PrintShowWidgetList
// (Final, Exec, Native, Public)

void ATslBaseHUD::PrintShowWidgetList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14197);

	ATslBaseHUD_PrintShowWidgetList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.PrintCreatedWidgetList
// (Final, Exec, Native, Public)

void ATslBaseHUD::PrintCreatedWidgetList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14196);

	ATslBaseHUD_PrintCreatedWidgetList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.OnClickedKillcamPlay
// (Final, Native, Public, BlueprintCallable)

void ATslBaseHUD::OnClickedKillcamPlay()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14195);

	ATslBaseHUD_OnClickedKillcamPlay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.IsWidgetShow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 WidgetName                     (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslBaseHUD::IsWidgetShow(const struct FString& WidgetName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14192);

	ATslBaseHUD_IsWidgetShow_Params params;
	params.WidgetName = WidgetName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseHUD.IsMouseUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslBaseHUD::IsMouseUse()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14190);

	ATslBaseHUD_IsMouseUse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseHUD.HideWidgetByEscape
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslBaseHUD::HideWidgetByEscape()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14188);

	ATslBaseHUD_HideWidgetByEscape_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseHUD.HidePopupDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 PopupWidgetName                (Parm, ZeroConstructor)

void ATslBaseHUD::HidePopupDialog(const struct FString& PopupWidgetName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14186);

	ATslBaseHUD_HidePopupDialog_Params params;
	params.PopupWidgetName = PopupWidgetName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.GetWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 WidgetName                     (Parm, ZeroConstructor)
// class UUserWidget*             ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UUserWidget* ATslBaseHUD::GetWidget(const struct FString& WidgetName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14183);

	ATslBaseHUD_GetWidget_Params params;
	params.WidgetName = WidgetName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseHUD.GetMainUMGHud
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UUserWidget* ATslBaseHUD::GetMainUMGHud()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14181);

	ATslBaseHUD_GetMainUMGHud_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseHUD.GetLastKillcamDisplayCode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKillcamDisplayCode            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EKillcamDisplayCode ATslBaseHUD::GetLastKillcamDisplayCode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14178);

	ATslBaseHUD_GetLastKillcamDisplayCode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseHUD.GetKillcamCountingText
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FText                   InCountingTextFormat           (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText ATslBaseHUD::GetKillcamCountingText(const struct FText& InCountingTextFormat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14175);

	ATslBaseHUD_GetKillcamCountingText_Params params;
	params.InCountingTextFormat = InCountingTextFormat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseHUD.ForceHidePopupHandler
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPopupButtonID                 DummyID                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslBaseHUD::ForceHidePopupHandler(EPopupButtonID DummyID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14172);

	ATslBaseHUD_ForceHidePopupHandler_Params params;
	params.DummyID = DummyID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.DestroyAllWidgets
// (Final, Native, Public, BlueprintCallable)

void ATslBaseHUD::DestroyAllWidgets()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14171);

	ATslBaseHUD_DestroyAllWidgets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseHUD.BindActionKeyDelegateEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ActionName                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<EInputEvent>       InputEvent                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FScriptDelegate         ActionKeyDelegate              (Parm, ZeroConstructor)

void ATslBaseHUD::BindActionKeyDelegateEvent(const struct FName& ActionName, TEnumAsByte<EInputEvent> InputEvent, const struct FScriptDelegate& ActionKeyDelegate)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14167);

	ATslBaseHUD_BindActionKeyDelegateEvent_Params params;
	params.ActionName = ActionName;
	params.InputEvent = InputEvent;
	params.ActionKeyDelegate = ActionKeyDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.AnimDB.GetBlendSpaceRelaxed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<EAnimStanceType>   AnimStance                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsFPP                         (Parm, ZeroConstructor, IsPlainOldData)
// class UBlendSpace*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpace* UAnimDB::GetBlendSpaceRelaxed(TEnumAsByte<EAnimStanceType> AnimStance, bool bIsFPP)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14258);

	UAnimDB_GetBlendSpaceRelaxed_Params params;
	params.AnimStance = AnimStance;
	params.bIsFPP = bIsFPP;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.AnimDB.GetBlendSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<EAnimStanceType>   AnimStance                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsFPP                         (Parm, ZeroConstructor, IsPlainOldData)
// class UBlendSpace*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpace* UAnimDB::GetBlendSpace(TEnumAsByte<EAnimStanceType> AnimStance, bool bIsFPP)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14254);

	UAnimDB_GetBlendSpace_Params params;
	params.AnimStance = AnimStance;
	params.bIsFPP = bIsFPP;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.AnimDB.GetAnimSpeed
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<EAnimStanceType>   AnimStance                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Direction                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InSpeed                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          PlayRate                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          SprintAlpha                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UAnimDB::GetAnimSpeed(TEnumAsByte<EAnimStanceType> AnimStance, float Direction, float InSpeed, float* PlayRate, float* SprintAlpha)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14247);

	UAnimDB_GetAnimSpeed_Params params;
	params.AnimStance = AnimStance;
	params.Direction = Direction;
	params.InSpeed = InSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PlayRate != nullptr)
		*PlayRate = params.PlayRate;
	if (SprintAlpha != nullptr)
		*SprintAlpha = params.SprintAlpha;

	return params.ReturnValue;
}


// Function TslGame.AsyncStaticMeshComponent.SetStaticMeshAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TAssetPtr<class UStaticMesh>   Asset                          (Parm)

void UAsyncStaticMeshComponent::SetStaticMeshAsset(TAssetPtr<class UStaticMesh> Asset)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14921);

	UAsyncStaticMeshComponent_SetStaticMeshAsset_Params params;
	params.Asset = Asset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.AsyncStaticMeshComponent.IsSameMesh
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TAssetPtr<class UStaticMesh>   Asset                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UAsyncStaticMeshComponent::IsSameMesh(TAssetPtr<class UStaticMesh> Asset)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14918);

	UAsyncStaticMeshComponent_IsSameMesh_Params params;
	params.Asset = Asset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.AsyncStaticMeshComponent.IsLoading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UAsyncStaticMeshComponent::IsLoading()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14916);

	UAsyncStaticMeshComponent_IsLoading_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.AsyncStaticMeshComponent.IsLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UAsyncStaticMeshComponent::IsLoaded()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14914);

	UAsyncStaticMeshComponent_IsLoaded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.AsyncStaticMeshComponent.GetStaticMeshAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TAssetPtr<class UStaticMesh>   ReturnValue                    (Parm, OutParm, ReturnParm)

TAssetPtr<class UStaticMesh> UAsyncStaticMeshComponent::GetStaticMeshAsset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14912);

	UAsyncStaticMeshComponent_GetStaticMeshAsset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.AsyncStaticMeshComponent.ClearStaticMeshAsset
// (Final, Native, Public, BlueprintCallable)

void UAsyncStaticMeshComponent::ClearStaticMeshAsset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14911);

	UAsyncStaticMeshComponent_ClearStaticMeshAsset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBuff.TickBuff
// (Native, Event, Public, BlueprintEvent)

void ATslBuff::TickBuff()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14952);

	ATslBuff_TickBuff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBuff.StopBuffBlueprint
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                           bCanceled                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslBuff::StopBuffBlueprint(bool bCanceled)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14950);

	ATslBuff_StopBuffBlueprint_Params params;
	params.bCanceled = bCanceled;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBuff.StartBuffBlueprint
// (Event, Public, BlueprintEvent)

void ATslBuff::StartBuffBlueprint()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14949);

	ATslBuff_StartBuffBlueprint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBuff.GetOwnerPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class APawn* ATslBuff::GetOwnerPawn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14947);

	ATslBuff_GetOwnerPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBuff.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ATslBuff::GetOwnerCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14945);

	ATslBuff_GetOwnerCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBuff.GetAttackId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAttackId               ReturnValue                    (Parm, OutParm, ReturnParm)

struct FAttackId ATslBuff::GetAttackId()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14943);

	ATslBuff_GetAttackId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBuff.CanApplyBuff
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslBuff::CanApplyBuff()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14941);

	ATslBuff_CanApplyBuff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.BuffComponet.RemoveBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   OverlapId                      (Parm, ZeroConstructor, IsPlainOldData)

void UBuffComponet::RemoveBuff(const struct FName& OverlapId)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14973);

	UBuffComponet_RemoveBuff_Params params;
	params.OverlapId = OverlapId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.BuffComponet.FindBuffWithOverlapId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BuffOverlapId                  (Parm, ZeroConstructor, IsPlainOldData)
// class ATslBuff*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslBuff* UBuffComponet::FindBuffWithOverlapId(const struct FName& BuffOverlapId)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14970);

	UBuffComponet_FindBuffWithOverlapId_Params params;
	params.BuffOverlapId = BuffOverlapId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.BuffComponet.AddBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  TslBuffClass                   (Parm, ZeroConstructor, IsPlainOldData)
// class ATslBuff*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslBuff* UBuffComponet::AddBuff(class UClass* TslBuffClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14967);

	UBuffComponet_AddBuff_Params params;
	params.TslBuffClass = TslBuffClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastableInterface.IsCastable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UCastableInterface::IsCastable(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15003);

	UCastableInterface_IsCastable_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastableInterface.GetCastFailMessage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UCastableInterface::GetCastFailMessage(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15000);

	UCastableInterface_GetCastFailMessage_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastableInterface.GetCastConfig
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FCastConfig             ReturnValue                    (Parm, OutParm, ReturnParm)

struct FCastConfig UCastableInterface::GetCastConfig()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(14998);

	UCastableInterface_GetCastConfig_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.UseHighPrecisionMouseMovement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*       PlayerController               (Parm, ZeroConstructor, IsPlainOldData)

void UTslStatics::UseHighPrecisionMouseMovement(class APlayerController* PlayerController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15355);

	UTslStatics_UseHighPrecisionMouseMovement_Params params;
	params.PlayerController = PlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.UnloadTextureByPtr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TAssetPtr<class UTexture>      TexturePtr                     (Parm)

void UTslStatics::UnloadTextureByPtr(TAssetPtr<class UTexture> TexturePtr)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15353);

	UTslStatics_UnloadTextureByPtr_Params params;
	params.TexturePtr = TexturePtr;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.SwitchValueByIsConsole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ConsoleOverrideValue           (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::SwitchValueByIsConsole(float Value, float ConsoleOverrideValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15349);

	UTslStatics_SwitchValueByIsConsole_Params params;
	params.Value = Value;
	params.ConsoleOverrideValue = ConsoleOverrideValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.SpawnTslParticleAttached
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  TslParticle                    (Parm, ZeroConstructor, IsPlainOldData)
// class USceneComponent*         Parent                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   AttachSocketName               (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   GroupName                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoReturnToPool              (Parm, ZeroConstructor, IsPlainOldData)
// class ATslParticle*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslParticle* UTslStatics::SpawnTslParticleAttached(class UObject* WorldContextObject, class UClass* TslParticle, class USceneComponent* Parent, const struct FName& AttachSocketName, const struct FName& GroupName, bool bAutoReturnToPool)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15341);

	UTslStatics_SpawnTslParticleAttached_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TslParticle = TslParticle;
	params.Parent = Parent;
	params.AttachSocketName = AttachSocketName;
	params.GroupName = GroupName;
	params.bAutoReturnToPool = bAutoReturnToPool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.SpawnTslParticleAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  TslParticle                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SpawnLocation                  (Parm, IsPlainOldData)
// struct FRotator                SpawnRotation                  (Parm, IsPlainOldData)
// struct FName                   GroupName                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoReturnToPool              (Parm, ZeroConstructor, IsPlainOldData)
// class ATslParticle*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslParticle* UTslStatics::SpawnTslParticleAtLocation(class UObject* WorldContextObject, class UClass* TslParticle, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, const struct FName& GroupName, bool bAutoReturnToPool)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15333);

	UTslStatics_SpawnTslParticleAtLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TslParticle = TslParticle;
	params.SpawnLocation = SpawnLocation;
	params.SpawnRotation = SpawnRotation;
	params.GroupName = GroupName;
	params.bAutoReturnToPool = bAutoReturnToPool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.SetWorldOriginByDistance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*       Controller                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          XYDistanceToShift              (Parm, ZeroConstructor, IsPlainOldData)

void UTslStatics::SetWorldOriginByDistance(class APlayerController* Controller, float XYDistanceToShift)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15330);

	UTslStatics_SetWorldOriginByDistance_Params params;
	params.Controller = Controller;
	params.XYDistanceToShift = XYDistanceToShift;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.SetWorldOrigin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*       Controller                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UTslStatics::SetWorldOrigin(class APlayerController* Controller)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15328);

	UTslStatics_SetWorldOrigin_Params params;
	params.Controller = Controller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.SetReportUserInfo
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// ESubjectToReport               Key                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FTslReportUserInfo      UserInfo                       (ConstParm, Parm, OutParm, ReferenceParm)

void UTslStatics::SetReportUserInfo(class UObject* WorldContextObject, ESubjectToReport Key, const struct FTslReportUserInfo& UserInfo)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15323);

	UTslStatics_SetReportUserInfo_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Key = Key;
	params.UserInfo = UserInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.SetReportUrl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReportUrl                      (Parm, ZeroConstructor)

void UTslStatics::SetReportUrl(class UObject* WorldContextObject, const struct FString& ReportUrl)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15320);

	UTslStatics_SetReportUrl_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ReportUrl = ReportUrl;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.SetReportToken
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReportToken                    (Parm, ZeroConstructor)

void UTslStatics::SetReportToken(class UObject* WorldContextObject, const struct FString& ReportToken)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15317);

	UTslStatics_SetReportToken_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ReportToken = ReportToken;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.SetAnimationAkSwitch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*              Character                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 SwitchGroup                    (Parm, ZeroConstructor)
// struct FString                 SwitchState                    (Parm, ZeroConstructor)

void UTslStatics::SetAnimationAkSwitch(class ACharacter* Character, const struct FString& SwitchGroup, const struct FString& SwitchState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15313);

	UTslStatics_SetAnimationAkSwitch_Params params;
	params.Character = Character;
	params.SwitchGroup = SwitchGroup;
	params.SwitchState = SwitchState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.SetAnimationAkRTPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*              Character                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 RTPCName                       (Parm, ZeroConstructor)
// float                          RTPCValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UTslStatics::SetAnimationAkRTPC(class ACharacter* Character, const struct FString& RTPCName, float RTPCValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15309);

	UTslStatics_SetAnimationAkRTPC_Params params;
	params.Character = Character;
	params.RTPCName = RTPCName;
	params.RTPCValue = RTPCValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.ServerPositionToLocal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Server                         (Parm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UTslStatics::ServerPositionToLocal(class UObject* WorldContextObject, const struct FVector& Server)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15305);

	UTslStatics_ServerPositionToLocal_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Server = Server;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.SaveStringToFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 Str                            (Parm, ZeroConstructor)
// struct FString                 Filename                       (Parm, ZeroConstructor)

void UTslStatics::SaveStringToFile(const struct FString& Str, const struct FString& Filename)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15302);

	UTslStatics_SaveStringToFile_Params params;
	params.Str = Str;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.SaveImageToFile
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FString                 Filename                       (Parm, ZeroConstructor)
// TArray<struct FLinearColor>    LinearColorArray               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UTslStatics::SaveImageToFile(const struct FString& Filename, TArray<struct FLinearColor> LinearColorArray)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15298);

	UTslStatics_SaveImageToFile_Params params;
	params.Filename = Filename;
	params.LinearColorArray = LinearColorArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.SafeDivide_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            DivideByZeroValue              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslStatics::SafeDivide_IntInt(int A, int B, int DivideByZeroValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15293);

	UTslStatics_SafeDivide_IntInt_Params params;
	params.A = A;
	params.B = B;
	params.DivideByZeroValue = DivideByZeroValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.SafeDivide_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          DivideByZeroValue              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::SafeDivide_FloatFloat(float A, float B, float DivideByZeroValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15288);

	UTslStatics_SafeDivide_FloatFloat_Params params;
	params.A = A;
	params.B = B;
	params.DivideByZeroValue = DivideByZeroValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.ReleaseMouseCaptureFromPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*       PlayerController               (Parm, ZeroConstructor, IsPlainOldData)

void UTslStatics::ReleaseMouseCaptureFromPlayerController(class APlayerController* PlayerController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15286);

	UTslStatics_ReleaseMouseCaptureFromPlayerController_Params params;
	params.PlayerController = PlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.ProjectPointToFloor
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bOutHit                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Length                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UTslStatics::ProjectPointToFloor(class UObject* WorldContextObject, const struct FVector& Origin, float Length, bool* bOutHit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15280);

	UTslStatics_ProjectPointToFloor_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Origin = Origin;
	params.Length = Length;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bOutHit != nullptr)
		*bOutHit = params.bOutHit;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.ProjectPointsToHighFloor
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bOutHit                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          AroundLength                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          RayLength                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UTslStatics::ProjectPointsToHighFloor(class UObject* WorldContextObject, const struct FVector& Origin, float AroundLength, float RayLength, bool* bOutHit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15273);

	UTslStatics_ProjectPointsToHighFloor_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Origin = Origin;
	params.AroundLength = AroundLength;
	params.RayLength = RayLength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bOutHit != nullptr)
		*bOutHit = params.bOutHit;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.PredictProjectilePathBox
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FHitResult              OutHit                         (Parm, OutParm, IsPlainOldData)
// TArray<struct FVector>         OutPathPositions               (Parm, OutParm, ZeroConstructor)
// struct FVector                 OutLastTraceDestination        (Parm, OutParm, IsPlainOldData)
// struct FVector                 StartPos                       (Parm, IsPlainOldData)
// struct FVector                 LaunchVelocity                 (Parm, IsPlainOldData)
// bool                           bTracePath                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ProjectileBox                  (Parm, IsPlainOldData)
// TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AActor*>          ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawDebugTime                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          SimFrequency                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxSimTime                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          OverrideGravityZ               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::PredictProjectilePathBox(class UObject* WorldContextObject, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, const struct FVector& ProjectileBox, TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<EDrawDebugTrace> DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15252);

	UTslStatics_PredictProjectilePathBox_Params params;
	params.WorldContextObject = WorldContextObject;
	params.StartPos = StartPos;
	params.LaunchVelocity = LaunchVelocity;
	params.bTracePath = bTracePath;
	params.ProjectileBox = ProjectileBox;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.DrawDebugTime = DrawDebugTime;
	params.SimFrequency = SimFrequency;
	params.MaxSimTime = MaxSimTime;
	params.OverrideGravityZ = OverrideGravityZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;
	if (OutPathPositions != nullptr)
		*OutPathPositions = params.OutPathPositions;
	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = params.OutLastTraceDestination;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.PlayerStateToReportReportUserInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslPlayerState*         TslPlayerState                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FTslReportUserInfo      ReturnValue                    (Parm, OutParm, ReturnParm)

struct FTslReportUserInfo UTslStatics::PlayerStateToReportReportUserInfo(class ATslPlayerState* TslPlayerState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15249);

	UTslStatics_PlayerStateToReportReportUserInfo_Params params;
	params.TslPlayerState = TslPlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.PhysicalSurfaceToString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<EPhysicalSurface>  Type                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslStatics::PhysicalSurfaceToString(TEnumAsByte<EPhysicalSurface> Type)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15246);

	UTslStatics_PhysicalSurfaceToString_Params params;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.PhysicalSurfaceToName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<EPhysicalSurface>  Type                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UTslStatics::PhysicalSurfaceToName(TEnumAsByte<EPhysicalSurface> Type)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15243);

	UTslStatics_PhysicalSurfaceToName_Params params;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.LocalPositionToServer
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Local                          (Parm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UTslStatics::LocalPositionToServer(class UObject* WorldContextObject, const struct FVector& Local)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15239);

	UTslStatics_LocalPositionToServer_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Local = Local;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.LoadTextureByPtr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TAssetPtr<class UTexture>      TexturePtr                     (Parm)
// class UTexture*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture* UTslStatics::LoadTextureByPtr(TAssetPtr<class UTexture> TexturePtr)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15236);

	UTslStatics_LoadTextureByPtr_Params params;
	params.TexturePtr = TexturePtr;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.LineSphereIntersection
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Intersection1                  (Parm, OutParm, IsPlainOldData)
// struct FVector                 Intersection2                  (Parm, OutParm, IsPlainOldData)
// struct FVector                 Center                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 Origion                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 Direction                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Radius                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::LineSphereIntersection(const struct FVector& Center, const struct FVector& Origion, const struct FVector& Direction, float Radius, struct FVector* Intersection1, struct FVector* Intersection2)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15228);

	UTslStatics_LineSphereIntersection_Params params;
	params.Center = Center;
	params.Origion = Origion;
	params.Direction = Direction;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Intersection1 != nullptr)
		*Intersection1 = params.Intersection1;
	if (Intersection2 != nullptr)
		*Intersection2 = params.Intersection2;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsUsingGappLobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsUsingGappLobby()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15226);

	UTslStatics_IsUsingGappLobby_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsSupportedSkin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsSupportedSkin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15224);

	UTslStatics_IsSupportedSkin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsShipping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsShipping()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15222);

	UTslStatics_IsShipping_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsServerActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                  Actor                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsServerActor(class AActor* Actor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15219);

	UTslStatics_IsServerActor_Params params;
	params.Actor = Actor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsReportUserValid
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// ESubjectToReport               Key                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsReportUserValid(class UObject* WorldContextObject, ESubjectToReport Key)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15214);

	UTslStatics_IsReportUserValid_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsReportUserApplied
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// ESubjectToReport               Key                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsReportUserApplied(class UObject* WorldContextObject, ESubjectToReport Key)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15209);

	UTslStatics_IsReportUserApplied_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsPIE
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsPIE(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15206);

	UTslStatics_IsPIE_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsNextPlayzoneOnTheMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsNextPlayzoneOnTheMap(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15203);

	UTslStatics_IsNextPlayzoneOnTheMap_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsMapFullyLoaded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                  World                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsMapFullyLoaded(class UWorld* World)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15200);

	UTslStatics_IsMapFullyLoaded_Params params;
	params.World = World;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsLastInputGamepad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsLastInputGamepad(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15197);

	UTslStatics_IsLastInputGamepad_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsKoreaRegion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsKoreaRegion(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15194);

	UTslStatics_IsKoreaRegion_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsGamepadConnected
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsGamepadConnected()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15192);

	UTslStatics_IsGamepadConnected_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsForKoreanRating
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsForKoreanRating()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15190);

	UTslStatics_IsForKoreanRating_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsForChineseLicensing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsForChineseLicensing()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15188);

	UTslStatics_IsForChineseLicensing_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsESports
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsESports()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15186);

	UTslStatics_IsESports_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsEditor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15184);

	UTslStatics_IsEditor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsConsolePlatform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsConsolePlatform()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15182);

	UTslStatics_IsConsolePlatform_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.IsClientActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                  Actor                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::IsClientActor(class AActor* Actor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15179);

	UTslStatics_IsClientActor_Params params;
	params.Actor = Actor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetWaterVolumeAtLocation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Point                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// class APhysicsVolume*          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class APhysicsVolume* UTslStatics::GetWaterVolumeAtLocation(class UObject* WorldContextObject, const struct FVector& Point)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15175);

	UTslStatics_GetWaterVolumeAtLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Point = Point;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetWaterSurfaceHeight
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class APhysicsVolume*          PhysicsVolume                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 CurLocation                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::GetWaterSurfaceHeight(class APhysicsVolume* PhysicsVolume, const struct FVector& CurLocation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15171);

	UTslStatics_GetWaterSurfaceHeight_Params params;
	params.PhysicsVolume = PhysicsVolume;
	params.CurLocation = CurLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetVehicleSeatComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                  Actor                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UTslVehicleSeatComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslVehicleSeatComponent* UTslStatics::GetVehicleSeatComponent(class AActor* Actor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15168);

	UTslStatics_GetVehicleSeatComponent_Params params;
	params.Actor = Actor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetVehicleCommonComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                  Actor                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UTslVehicleCommonComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslVehicleCommonComponent* UTslStatics::GetVehicleCommonComponent(class AActor* Actor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15165);

	UTslStatics_GetVehicleCommonComponent_Params params;
	params.Actor = Actor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetTslPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APawn*                   Pawn                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class ATslPlayerController*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerController* UTslStatics::GetTslPlayerController(class APawn* Pawn)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15162);

	UTslStatics_GetTslPlayerController_Params params;
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetTslPlatformName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslStatics::GetTslPlatformName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15160);

	UTslStatics_GetTslPlatformName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetTslGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class ATslGameState*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslGameState* UTslStatics::GetTslGameState(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15157);

	UTslStatics_GetTslGameState_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetTslCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UTslStatics::GetTslCharacter(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15154);

	UTslStatics_GetTslCharacter_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetSimplePhysicalMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*     PrimitiveComponent             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UPhysicalMaterial*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UPhysicalMaterial* UTslStatics::GetSimplePhysicalMaterial(class UPrimitiveComponent* PrimitiveComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15151);

	UTslStatics_GetSimplePhysicalMaterial_Params params;
	params.PrimitiveComponent = PrimitiveComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetServerLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 ActorOrComponent               (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UTslStatics::GetServerLocation(class UObject* ActorOrComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15148);

	UTslStatics_GetServerLocation_Params params;
	params.ActorOrComponent = ActorOrComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetReportUserInfo
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// ESubjectToReport               Key                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FTslReportUserInfo      ReturnValue                    (Parm, OutParm, ReturnParm)

struct FTslReportUserInfo UTslStatics::GetReportUserInfo(class UObject* WorldContextObject, ESubjectToReport Key)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15143);

	UTslStatics_GetReportUserInfo_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetRecoilControlScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::GetRecoilControlScale()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15141);

	UTslStatics_GetRecoilControlScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetRecoilAnimScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::GetRecoilAnimScale()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15139);

	UTslStatics_GetRecoilAnimScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetNextPlayzoneRadius
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::GetNextPlayzoneRadius(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15136);

	UTslStatics_GetNextPlayzoneRadius_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetNextPlayzonePosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UTslStatics::GetNextPlayzonePosition(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15133);

	UTslStatics_GetNextPlayzonePosition_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetMOAScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::GetMOAScale()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15131);

	UTslStatics_GetMOAScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetMemoryInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslStatics::GetMemoryInfo()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15129);

	UTslStatics_GetMemoryInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetGappLobbyUrl
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslStatics::GetGappLobbyUrl()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15127);

	UTslStatics_GetGappLobbyUrl_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetGameVersion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslStatics::GetGameVersion()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15125);

	UTslStatics_GetGameVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetGamepadTabMaximumDelay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslPlayerController*    TslPlayerController            (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::GetGamepadTabMaximumDelay(class ATslPlayerController* TslPlayerController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15122);

	UTslStatics_GetGamepadTabMaximumDelay_Params params;
	params.TslPlayerController = TslPlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetFullGameVersion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslStatics::GetFullGameVersion()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15120);

	UTslStatics_GetFullGameVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetConsoleValue
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ConsloeName                    (Parm, ZeroConstructor)
// float                          OutValueFloat                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            OutValueInt                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FString                 OutValueString                 (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::GetConsoleValue(const struct FString& ConsloeName, float* OutValueFloat, int* OutValueInt, struct FString* OutValueString)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15114);

	UTslStatics_GetConsoleValue_Params params;
	params.ConsloeName = ConsloeName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValueFloat != nullptr)
		*OutValueFloat = params.OutValueFloat;
	if (OutValueInt != nullptr)
		*OutValueInt = params.OutValueInt;
	if (OutValueString != nullptr)
		*OutValueString = params.OutValueString;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetBluezoneRadius
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::GetBluezoneRadius(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15111);

	UTslStatics_GetBluezoneRadius_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetBluezonePosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UTslStatics::GetBluezonePosition(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15108);

	UTslStatics_GetBluezonePosition_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetBallisticDropScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::GetBallisticDropScale()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15106);

	UTslStatics_GetBallisticDropScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.GetBallisticDragScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslStatics::GetBallisticDragScale()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15104);

	UTslStatics_GetBallisticDragScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.ConeVolumeLineTraceTest
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          HalfConeAngle                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          RayLength                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::ConeVolumeLineTraceTest(class UObject* WorldContextObject, const struct FVector& Origin, float HalfConeAngle, float RayLength)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15098);

	UTslStatics_ConeVolumeLineTraceTest_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Origin = Origin;
	params.HalfConeAngle = HalfConeAngle;
	params.RayLength = RayLength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.ConeVolumeLineTraceSingle
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutHitPoint                    (Parm, OutParm, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          HalfConeAngle                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          RayLength                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::ConeVolumeLineTraceSingle(class UObject* WorldContextObject, const struct FVector& Origin, float HalfConeAngle, float RayLength, struct FVector* OutHitPoint)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15091);

	UTslStatics_ConeVolumeLineTraceSingle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Origin = Origin;
	params.HalfConeAngle = HalfConeAngle;
	params.RayLength = RayLength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHitPoint != nullptr)
		*OutHitPoint = params.OutHitPoint;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.ConeVolumeLineTraceMulti
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FVector>         OutHitPoints                   (Parm, OutParm, ZeroConstructor)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// int                            SamplingNum                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfConeAngle                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          RayLength                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslStatics::ConeVolumeLineTraceMulti(class UObject* WorldContextObject, const struct FVector& Origin, int SamplingNum, float HalfConeAngle, float RayLength, TArray<struct FVector>* OutHitPoints)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15082);

	UTslStatics_ConeVolumeLineTraceMulti_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Origin = Origin;
	params.SamplingNum = SamplingNum;
	params.HalfConeAngle = HalfConeAngle;
	params.RayLength = RayLength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHitPoints != nullptr)
		*OutHitPoints = params.OutHitPoints;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.CanVehicleSeatInteraction
// (Final, Native, Static, Public)
// Parameters:
// class ATslCharacter*           InTslCharacter                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::CanVehicleSeatInteraction(class ATslCharacter* InTslCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15079);

	UTslStatics_CanVehicleSeatInteraction_Params params;
	params.InTslCharacter = InTslCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.CanCancelCasting
// (Final, Native, Static, Public)
// Parameters:
// class ATslCharacter*           InTslCharacter                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::CanCancelCasting(class ATslCharacter* InTslCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15076);

	UTslStatics_CanCancelCasting_Params params;
	params.InTslCharacter = InTslCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.ApplyRadialDamageWithFalloff
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseDamage                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinimumDamage                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          DamageInnerRadius              (Parm, ZeroConstructor, IsPlainOldData)
// float                          DamageOuterRadius              (Parm, ZeroConstructor, IsPlainOldData)
// float                          DamageFalloff                  (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  DamageTypeClass                (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AActor*>          IgnoreActors                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FAttackId               AttackId                       (Parm)
// bool                           bIsTargetDestructible          (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// class AController*             InstigatedByController         (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<ECollisionChannel> DamagePreventionChannel        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bExplode                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::ApplyRadialDamageWithFalloff(class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, const struct FAttackId& AttackId, bool bIsTargetDestructible, class AActor* DamageCauser, class AController* InstigatedByController, TEnumAsByte<ECollisionChannel> DamagePreventionChannel, bool bExplode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15058);

	UTslStatics_ApplyRadialDamageWithFalloff_Params params;
	params.WorldContextObject = WorldContextObject;
	params.BaseDamage = BaseDamage;
	params.MinimumDamage = MinimumDamage;
	params.Origin = Origin;
	params.DamageInnerRadius = DamageInnerRadius;
	params.DamageOuterRadius = DamageOuterRadius;
	params.DamageFalloff = DamageFalloff;
	params.DamageTypeClass = DamageTypeClass;
	params.IgnoreActors = IgnoreActors;
	params.AttackId = AttackId;
	params.bIsTargetDestructible = bIsTargetDestructible;
	params.DamageCauser = DamageCauser;
	params.InstigatedByController = InstigatedByController;
	params.DamagePreventionChannel = DamagePreventionChannel;
	params.bExplode = bExplode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.ApplyRadialDamageWithCurve
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseDamage                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          DamageRadius                   (Parm, ZeroConstructor, IsPlainOldData)
// class UCurveFloat*             DamageCurve                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  DamageTypeClass                (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AActor*>          IgnoreActors                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FAttackId               AttackId                       (Parm)
// bool                           bIsTargetDestructible          (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// class AController*             InstigatedByController         (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<ECollisionChannel> DamagePreventionChannel        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bExplode                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::ApplyRadialDamageWithCurve(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, class UCurveFloat* DamageCurve, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, const struct FAttackId& AttackId, bool bIsTargetDestructible, class AActor* DamageCauser, class AController* InstigatedByController, TEnumAsByte<ECollisionChannel> DamagePreventionChannel, bool bExplode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15042);

	UTslStatics_ApplyRadialDamageWithCurve_Params params;
	params.WorldContextObject = WorldContextObject;
	params.BaseDamage = BaseDamage;
	params.Origin = Origin;
	params.DamageRadius = DamageRadius;
	params.DamageCurve = DamageCurve;
	params.DamageTypeClass = DamageTypeClass;
	params.IgnoreActors = IgnoreActors;
	params.AttackId = AttackId;
	params.bIsTargetDestructible = bIsTargetDestructible;
	params.DamageCauser = DamageCauser;
	params.InstigatedByController = InstigatedByController;
	params.DamagePreventionChannel = DamagePreventionChannel;
	params.bExplode = bExplode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.ApplyRadialDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseDamage                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          DamageRadius                   (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  DamageTypeClass                (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AActor*>          IgnoreActors                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FAttackId               AttackId                       (Parm)
// bool                           bIsTargetDestructible          (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// class AController*             InstigatedByController         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDoFullDamage                  (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<ECollisionChannel> DamagePreventionChannel        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bExplode                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslStatics::ApplyRadialDamage(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, const struct FAttackId& AttackId, bool bIsTargetDestructible, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, TEnumAsByte<ECollisionChannel> DamagePreventionChannel, bool bExplode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15026);

	UTslStatics_ApplyRadialDamage_Params params;
	params.WorldContextObject = WorldContextObject;
	params.BaseDamage = BaseDamage;
	params.Origin = Origin;
	params.DamageRadius = DamageRadius;
	params.DamageTypeClass = DamageTypeClass;
	params.IgnoreActors = IgnoreActors;
	params.AttackId = AttackId;
	params.bIsTargetDestructible = bIsTargetDestructible;
	params.DamageCauser = DamageCauser;
	params.InstigatedByController = InstigatedByController;
	params.bDoFullDamage = bDoFullDamage;
	params.DamagePreventionChannel = DamagePreventionChannel;
	params.bExplode = bExplode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslStatics.ApplyDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                  DamagedActor                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseDamage                     (Parm, ZeroConstructor, IsPlainOldData)
// class AController*             EventInstigator                (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  DamageTypeClass                (Parm, ZeroConstructor, IsPlainOldData)
// struct FAttackId               AttackId                       (Parm)

void UTslStatics::ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, class UClass* DamageTypeClass, const struct FAttackId& AttackId)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15019);

	UTslStatics_ApplyDamage_Params params;
	params.DamagedActor = DamagedActor;
	params.BaseDamage = BaseDamage;
	params.EventInstigator = EventInstigator;
	params.DamageCauser = DamageCauser;
	params.DamageTypeClass = DamageTypeClass;
	params.AttackId = AttackId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStatics.AddTslParticleGroupInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   GroupName                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaxObjectCount                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bCullByDistance                (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxDistance                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bCullByFrustum                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bCullByLastRenderedTime        (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxRenderDuration              (Parm, ZeroConstructor, IsPlainOldData)

void UTslStatics::AddTslParticleGroupInfo(class UObject* WorldContextObject, const struct FName& GroupName, int MaxObjectCount, bool bCullByDistance, float MaxDistance, bool bCullByFrustum, bool bCullByLastRenderedTime, float MaxRenderDuration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15010);

	UTslStatics_AddTslParticleGroupInfo_Params params;
	params.WorldContextObject = WorldContextObject;
	params.GroupName = GroupName;
	params.MaxObjectCount = MaxObjectCount;
	params.bCullByDistance = bCullByDistance;
	params.MaxDistance = MaxDistance;
	params.bCullByFrustum = bCullByFrustum;
	params.bCullByLastRenderedTime = bCullByLastRenderedTime;
	params.MaxRenderDuration = MaxRenderDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CastComponent.StartCastOnClient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class UCastableInterface> CastableInterface              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UCastComponent::StartCastOnClient(const TScriptInterface<class UCastableInterface>& CastableInterface)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15376);

	UCastComponent_StartCastOnClient_Params params;
	params.CastableInterface = CastableInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastComponent.GetTotalCastTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UCastComponent::GetTotalCastTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15374);

	UCastComponent_GetTotalCastTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastComponent.GetElapsedCastTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UCastComponent::GetElapsedCastTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15372);

	UCastComponent_GetElapsedCastTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastComponent.GetCastPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECastPriority                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ECastPriority UCastComponent::GetCastPriority()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15369);

	UCastComponent_GetCastPriority_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastComponent.GetCastObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UObject* UCastComponent::GetCastObject()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15367);

	UCastComponent_GetCastObject_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastComponent.GetCastName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UCastComponent::GetCastName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15365);

	UCastComponent_GetCastName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastComponent.GetCastLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECastLevel                     ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ECastLevel UCastComponent::GetCastLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15362);

	UCastComponent_GetCastLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastComponent.GetCastAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECastAnim                      ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ECastAnim UCastComponent::GetCastAnim()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15359);

	UCastComponent_GetCastAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CastComponent.CancelCastOnClient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UCastComponent::CancelCastOnClient()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15357);

	UCastComponent_CancelCastOnClient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.OnRep_Breath
// (Final, Native, Private)
// Parameters:
// float                          LastBreath                     (Parm, ZeroConstructor, IsPlainOldData)

void UCharacterBreathComponent::OnRep_Breath(float LastBreath)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15397);

	UCharacterBreathComponent_OnRep_Breath_Params params;
	params.LastBreath = LastBreath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CharacterBreathComponent.IsInApnea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UCharacterBreathComponent::IsInApnea()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15395);

	UCharacterBreathComponent_IsInApnea_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.IsConsuming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UCharacterBreathComponent::IsConsuming()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15393);

	UCharacterBreathComponent_IsConsuming_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.GetBreathRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UCharacterBreathComponent::GetBreathRatio()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15391);

	UCharacterBreathComponent_GetBreathRatio_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.GetBreathMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UCharacterBreathComponent::GetBreathMax()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15389);

	UCharacterBreathComponent_GetBreathMax_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.GetBreath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UCharacterBreathComponent::GetBreath()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15387);

	UCharacterBreathComponent_GetBreath_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.CanStartSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UCharacterBreathComponent::CanStartSprinting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15385);

	UCharacterBreathComponent_CanStartSprinting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.CanStartHoldingBreath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UCharacterBreathComponent::CanStartHoldingBreath()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15383);

	UCharacterBreathComponent_CanStartHoldingBreath_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.AddBreath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UCharacterBreathComponent::AddBreath(float Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15381);

	UCharacterBreathComponent_AddBreath_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CharacterStudio.Update
// (Final, Native, Public, BlueprintCallable)

void ACharacterStudio::Update()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15425);

	ACharacterStudio_Update_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CharacterStudio.SetSceneCaptureMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic* Mid                            (Parm, ZeroConstructor, IsPlainOldData)

void ACharacterStudio::SetSceneCaptureMaterial(class UMaterialInstanceDynamic* Mid)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15423);

	ACharacterStudio_SetSceneCaptureMaterial_Params params;
	params.Mid = Mid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CharacterStudio.SetCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)

void ACharacterStudio::SetCharacter(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15421);

	ACharacterStudio_SetCharacter_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CharacterStudio.IsUsingDynamicResolution
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ACharacterStudio::IsUsingDynamicResolution()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15419);

	ACharacterStudio_IsUsingDynamicResolution_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterStudio.IsCharacterValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ACharacterStudio::IsCharacterValid()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15417);

	ACharacterStudio_IsCharacterValid_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterStudio.GetSceneCaptureMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UMaterialInstanceDynamic* ACharacterStudio::GetSceneCaptureMaterial()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15415);

	ACharacterStudio_GetSceneCaptureMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterStudio.GetCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ACharacterStudio::GetCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15413);

	ACharacterStudio_GetCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterStudio.AddYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Yaw                            (Parm, ZeroConstructor, IsPlainOldData)

void ACharacterStudio::AddYaw(float Yaw)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15411);

	ACharacterStudio_AddYaw_Params params;
	params.Yaw = Yaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CoherentCommonBinder.Test
// (Final, Native, Private)

void UCoherentCommonBinder::Test()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15441);

	UCoherentCommonBinder_Test_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CoherentCommonBinder.OnWebPageOnPlatformFailed
// (Final, Native, Private)

void UCoherentCommonBinder::OnWebPageOnPlatformFailed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15440);

	UCoherentCommonBinder_OnWebPageOnPlatformFailed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CoherentCommonBinder.BindUI
// (Native, Protected)

void UCoherentCommonBinder::BindUI()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15439);

	UCoherentCommonBinder_BindUI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CoherentCommonBinder.BindDelegate
// (Native, Protected)

void UCoherentCommonBinder::BindDelegate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15438);

	UCoherentCommonBinder_BindDelegate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBasePlayerController.Server_SetBPFactor
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                          factor                         (Parm, ZeroConstructor, IsPlainOldData)

void ATslBasePlayerController::Server_SetBPFactor(float factor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15914);

	ATslBasePlayerController_Server_SetBPFactor_Params params;
	params.factor = factor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBasePlayerController.HandleClipboard
// (Native, Protected)

void ATslBasePlayerController::HandleClipboard()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15913);

	ATslBasePlayerController_HandleClipboard_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.UpdateHud
// (Final, Native, Private, BlueprintCallable)

void ATslPlayerController::UpdateHud()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16314);

	ATslPlayerController_UpdateHud_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.UnreliablePong
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            SeqID                          (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        DateTimeTickFromServer         (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::UnreliablePong(int SeqID, int64_t DateTimeTickFromServer)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16311);

	ATslPlayerController_UnreliablePong_Params params;
	params.SeqID = SeqID;
	params.DateTimeTickFromServer = DateTimeTickFromServer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.UnreliablePing
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// int                            SeqID                          (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        DateTimeTick                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::UnreliablePing(int SeqID, int64_t DateTimeTick)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16308);

	ATslPlayerController_UnreliablePing_Params params;
	params.SeqID = SeqID;
	params.DateTimeTick = DateTimeTick;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ToggleInventory
// (Final, Native, Private, BlueprintCallable)

void ATslPlayerController::ToggleInventory()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16307);

	ATslPlayerController_ToggleInventory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.Test_SpawnVehicle
// (Final, Native, Private)

void ATslPlayerController::Test_SpawnVehicle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16306);

	ATslPlayerController_Test_SpawnVehicle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.Suicide
// (Exec, Native, Public)

void ATslPlayerController::Suicide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16305);

	ATslPlayerController_Suicide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.SimulateInputKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                    Key                            (Parm)
// bool                           bPressed                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::SimulateInputKey(const struct FKey& Key, bool bPressed)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16302);

	ATslPlayerController_SimulateInputKey_Params params;
	params.Key = Key;
	params.bPressed = bPressed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ShowTslDebugInfomation
// (Final, Exec, Native, Public)

void ATslPlayerController::ShowTslDebugInfomation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16301);

	ATslPlayerController_ShowTslDebugInfomation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ShowTeamDeathPopup
// (Final, Native, Private)

void ATslPlayerController::ShowTeamDeathPopup()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16300);

	ATslPlayerController_ShowTeamDeathPopup_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ShowPlayerControllerBindActions_Admin
// (Final, Exec, Native, Public)

void ATslPlayerController::ShowPlayerControllerBindActions_Admin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16299);

	ATslPlayerController_ShowPlayerControllerBindActions_Admin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ShowMatchResult
// (Final, Native, Private)

void ATslPlayerController::ShowMatchResult()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16298);

	ATslPlayerController_ShowMatchResult_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ShowInGameMenu_Gamepad
// (Final, Native, Private)

void ATslPlayerController::ShowInGameMenu_Gamepad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16297);

	ATslPlayerController_ShowInGameMenu_Gamepad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ShowInGameMenu
// (Final, Native, Private, BlueprintCallable)

void ATslPlayerController::ShowInGameMenu()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16296);

	ATslPlayerController_ShowInGameMenu_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ShowGotoLobbyPopUp
// (Final, Native, Public)
// Parameters:
// EPopupButtonID                 ButtonID                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ShowGotoLobbyPopUp(EPopupButtonID ButtonID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16293);

	ATslPlayerController_ShowGotoLobbyPopUp_Params params;
	params.ButtonID = ButtonID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ShowEmoteWheel
// (Final, Native, Private, BlueprintCallable)

void ATslPlayerController::ShowEmoteWheel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16292);

	ATslPlayerController_ShowEmoteWheel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.SetDefaultFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewFOV                         (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::SetDefaultFOV(float NewFOV)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16290);

	ATslPlayerController_SetDefaultFOV_Params params;
	params.NewFOV = NewFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.SetCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bOn                            (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::SetCustomDepth(bool bOn)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16288);

	ATslPlayerController_SetCustomDepth_Params params;
	params.bOn = bOn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.SetCanSeeTerrainThroughFogInTheAir
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bCanSee                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::SetCanSeeTerrainThroughFogInTheAir(bool bCanSee)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16286);

	ATslPlayerController_SetCanSeeTerrainThroughFogInTheAir_Params params;
	params.bCanSee = bCanSee;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerViewTargetReplicateUpdate
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslPlayerController::ServerViewTargetReplicateUpdate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16285);

	ATslPlayerController_ServerViewTargetReplicateUpdate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSystemInfo
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FString                 OsLanguage                     (Parm, ZeroConstructor)
// struct FString                 GameLanguage                   (Parm, ZeroConstructor)
// struct FString                 OsVersion                      (Parm, ZeroConstructor)
// struct FString                 CpuName                        (Parm, ZeroConstructor)
// struct FString                 GpuName                        (Parm, ZeroConstructor)
// uint32_t                       RamInGB                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 BaseBoardSerial                (Parm, ZeroConstructor)
// TArray<struct FString>         MemorySerials                  (ConstParm, Parm, ZeroConstructor, ReferenceParm)
// int                            ArpIpCount                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerSystemInfo(const struct FString& OsLanguage, const struct FString& GameLanguage, const struct FString& OsVersion, const struct FString& CpuName, const struct FString& GpuName, uint32_t RamInGB, const struct FString& BaseBoardSerial, TArray<struct FString> MemorySerials, int ArpIpCount)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16274);

	ATslPlayerController_ServerSystemInfo_Params params;
	params.OsLanguage = OsLanguage;
	params.GameLanguage = GameLanguage;
	params.OsVersion = OsVersion;
	params.CpuName = CpuName;
	params.GpuName = GpuName;
	params.RamInGB = RamInGB;
	params.BaseBoardSerial = BaseBoardSerial;
	params.MemorySerials = MemorySerials;
	params.ArpIpCount = ArpIpCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSuicide
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslPlayerController::ServerSuicide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16273);

	ATslPlayerController_ServerSuicide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerStopHoldRotation
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FRotator                DeltaRotation                  (Parm, IsPlainOldData)
// bool                           bUseInterp                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerStopHoldRotation(const struct FRotator& DeltaRotation, bool bUseInterp)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16270);

	ATslPlayerController_ServerStopHoldRotation_Params params;
	params.DeltaRotation = DeltaRotation;
	params.bUseInterp = bUseInterp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerStat
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// TEnumAsByte<EServerStatType>   StatType                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Password                       (Parm, ZeroConstructor)

void ATslPlayerController::ServerStat(TEnumAsByte<EServerStatType> StatType, const struct FString& Password)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16267);

	ATslPlayerController_ServerStat_Params params;
	params.StatType = StatType;
	params.Password = Password;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerStartHoldRotation
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FRotator                Current                        (Parm, IsPlainOldData)

void ATslPlayerController::ServerStartHoldRotation(const struct FRotator& Current)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16265);

	ATslPlayerController_ServerStartHoldRotation_Params params;
	params.Current = Current;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSpawnVehicle
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void ATslPlayerController::ServerSpawnVehicle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16264);

	ATslPlayerController_ServerSpawnVehicle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSetViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                  NewViewTarget                  (Parm, ZeroConstructor, IsPlainOldData)
// EObserverCameraMode            ObserverCameraMode             (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerSetViewTarget(class AActor* NewViewTarget, EObserverCameraMode ObserverCameraMode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16260);

	ATslPlayerController_ServerSetViewTarget_Params params;
	params.NewViewTarget = NewViewTarget;
	params.ObserverCameraMode = ObserverCameraMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSetThirdPerson
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           bNewThirdPerson                (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerSetThirdPerson(bool bNewThirdPerson)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16258);

	ATslPlayerController_ServerSetThirdPerson_Params params;
	params.bNewThirdPerson = bNewThirdPerson;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSetIsReviving
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           InbIsReviving                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerSetIsReviving(bool InbIsReviving)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16256);

	ATslPlayerController_ServerSetIsReviving_Params params;
	params.InbIsReviving = InbIsReviving;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSetControlRotation
// (Net, NetReliable, Native, Event, Protected, HasDefaults, NetClient)
// Parameters:
// struct FRotator                Rotation                       (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslPlayerController::ServerSetControlRotation(const struct FRotator& Rotation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16254);

	ATslPlayerController_ServerSetControlRotation_Params params;
	params.Rotation = Rotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSetClientFps
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                          Fps                            (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerSetClientFps(float Fps)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16252);

	ATslPlayerController_ServerSetClientFps_Params params;
	params.Fps = Fps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSetAccumViewRotation
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantizeNormal InAccumViewRotation            (ConstParm, Parm, ReferenceParm)

void ATslPlayerController::ServerSetAccumViewRotation(const struct FVector_NetQuantizeNormal& InAccumViewRotation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16250);

	ATslPlayerController_ServerSetAccumViewRotation_Params params;
	params.InAccumViewRotation = InAccumViewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSendTPPacketReliable
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<unsigned char>          Packet                         (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void ATslPlayerController::ServerSendTPPacketReliable(TArray<unsigned char> Packet)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16247);

	ATslPlayerController_ServerSendTPPacketReliable_Params params;
	params.Packet = Packet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSendPacketUnreliable
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<unsigned char>          Packet                         (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void ATslPlayerController::ServerSendPacketUnreliable(TArray<unsigned char> Packet)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16244);

	ATslPlayerController_ServerSendPacketUnreliable_Params params;
	params.Packet = Packet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSendPacketReliable
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<unsigned char>          Packet                         (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void ATslPlayerController::ServerSendPacketReliable(TArray<unsigned char> Packet)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16241);

	ATslPlayerController_ServerSendPacketReliable_Params params;
	params.Packet = Packet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerSay
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FString                 Msg                            (Parm, ZeroConstructor)

void ATslPlayerController::ServerSay(const struct FString& Msg)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16239);

	ATslPlayerController_ServerSay_Params params;
	params.Msg = Msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerPickUpItemFromPackage
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UItem*                   Item                           (Parm, ZeroConstructor, IsPlainOldData)
// class AItemPackage*            Package                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   TargetContainer                (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)

void ATslPlayerController::ServerPickUpItemFromPackage(class UItem* Item, class AItemPackage* Package, const struct FName& TargetContainer, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16234);

	ATslPlayerController_ServerPickUpItemFromPackage_Params params;
	params.Item = Item;
	params.Package = Package;
	params.TargetContainer = TargetContainer;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerPickUpDroppedItem
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UObject*                 DroppedItemObject              (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   TargetContainer                (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)

void ATslPlayerController::ServerPickUpDroppedItem(class UObject* DroppedItemObject, const struct FName& TargetContainer, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16230);

	ATslPlayerController_ServerPickUpDroppedItem_Params params;
	params.DroppedItemObject = DroppedItemObject;
	params.TargetContainer = TargetContainer;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerNotifyHitToGlassWindowInst
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UTslInstancedGlassWindowComponent* GlassWindowInstComponent       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FHitResult              Hit                            (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslPlayerController::ServerNotifyHitToGlassWindowInst(class UTslInstancedGlassWindowComponent* GlassWindowInstComponent, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16227);

	ATslPlayerController_ServerNotifyHitToGlassWindowInst_Params params;
	params.GlassWindowInstComponent = GlassWindowInstComponent;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerNotifyHitToGlassWindow
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UTslGlassWindowComponent* GlassWindowComponent           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FHitResult              Hit                            (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslPlayerController::ServerNotifyHitToGlassWindow(class UTslGlassWindowComponent* GlassWindowComponent, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16224);

	ATslPlayerController_ServerNotifyHitToGlassWindow_Params params;
	params.GlassWindowComponent = GlassWindowComponent;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerNextSetViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           bIsPrev                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerNextSetViewTarget(bool bIsPrev)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16222);

	ATslPlayerController_ServerNextSetViewTarget_Params params;
	params.bIsPrev = bIsPrev;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerMoveToVehicleSeat
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            SeatIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerMoveToVehicleSeat(int SeatIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16220);

	ATslPlayerController_ServerMoveToVehicleSeat_Params params;
	params.SeatIndex = SeatIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerMapLoadFinishedOnClient
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslPlayerController::ServerMapLoadFinishedOnClient()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16219);

	ATslPlayerController_ServerMapLoadFinishedOnClient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerLogXboxUnautorizedDevice
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            DetectCount                    (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerLogXboxUnautorizedDevice(int DetectCount)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16217);

	ATslPlayerController_ServerLogXboxUnautorizedDevice_Params params;
	params.DetectCount = DetectCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerLeaveMatchIntentionally
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslPlayerController::ServerLeaveMatchIntentionally()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16216);

	ATslPlayerController_ServerLeaveMatchIntentionally_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerKickCharacter
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ATslCharacter*           TslCharacter                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Reason                         (ConstParm, Parm, ReferenceParm)

void ATslPlayerController::ServerKickCharacter(class ATslCharacter* TslCharacter, const struct FText& Reason)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16213);

	ATslPlayerController_ServerKickCharacter_Params params;
	params.TslCharacter = TslCharacter;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerCheat
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FString                 Msg                            (Parm, ZeroConstructor)

void ATslPlayerController::ServerCheat(const struct FString& Msg)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16211);

	ATslPlayerController_ServerCheat_Params params;
	params.Msg = Msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerCancelInteraction
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UActorComponent*         InteractionComponent           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslPlayerController::ServerCancelInteraction(class UActorComponent* InteractionComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16209);

	ATslPlayerController_ServerCancelInteraction_Params params;
	params.InteractionComponent = InteractionComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerBroadCastUpdateCameraInfo
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           InbFirstPerson                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbIsInVehicle                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbIsScoping                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerBroadCastUpdateCameraInfo(bool InbFirstPerson, bool InbIsInVehicle, bool InbIsScoping)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16205);

	ATslPlayerController_ServerBroadCastUpdateCameraInfo_Params params;
	params.InbFirstPerson = InbFirstPerson;
	params.InbIsInVehicle = InbIsInVehicle;
	params.InbIsScoping = InbIsScoping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerBroadCastCastingBar
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                          CastTime                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   CastName                       (ConstParm, Parm, ReferenceParm)
// bool                           OnOff                          (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ServerBroadCastCastingBar(float CastTime, const struct FText& CastName, bool OnOff)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16201);

	ATslPlayerController_ServerBroadCastCastingBar_Params params;
	params.CastTime = CastTime;
	params.CastName = CastName;
	params.OnOff = OnOff;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerBEServerCommand
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FString                 Command                        (Parm, ZeroConstructor)
// struct FString                 Arg0                           (Parm, ZeroConstructor)
// struct FString                 Arg1                           (Parm, ZeroConstructor)
// struct FString                 Arg2                           (Parm, ZeroConstructor)

void ATslPlayerController::ServerBEServerCommand(const struct FString& Command, const struct FString& Arg0, const struct FString& Arg1, const struct FString& Arg2)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16196);

	ATslPlayerController_ServerBEServerCommand_Params params;
	params.Command = Command;
	params.Arg0 = Arg0;
	params.Arg1 = Arg1;
	params.Arg2 = Arg2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ServerAdmin
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FString                 AdminCommand                   (Parm, ZeroConstructor)

void ATslPlayerController::ServerAdmin(const struct FString& AdminCommand)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16194);

	ATslPlayerController_ServerAdmin_Params params;
	params.AdminCommand = AdminCommand;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.SendUnderFpsToServer
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            UnderFps30                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            UnderFps60                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::SendUnderFpsToServer(int UnderFps30, int UnderFps60)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16191);

	ATslPlayerController_SendUnderFpsToServer_Params params;
	params.UnderFps30 = UnderFps30;
	params.UnderFps60 = UnderFps60;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.SendSystemMessage
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// ESystemMessageType             MessageType                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Message                        (ConstParm, Parm, ReferenceParm)
// float                          MessageDuration                (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::SendSystemMessage(ESystemMessageType MessageType, const struct FText& Message, float MessageDuration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16186);

	ATslPlayerController_SendSystemMessage_Params params;
	params.MessageType = MessageType;
	params.Message = Message;
	params.MessageDuration = MessageDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.Say
// (Exec, Native, Public)
// Parameters:
// struct FString                 Msg                            (Parm, ZeroConstructor)

void ATslPlayerController::Say(const struct FString& Msg)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16184);

	ATslPlayerController_Say_Params params;
	params.Msg = Msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.SaveGearProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            ProfileIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UClass*>          inArray                        (Parm, ZeroConstructor)

void ATslPlayerController::SaveGearProfile(int ProfileIndex, TArray<class UClass*> inArray)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16180);

	ATslPlayerController_SaveGearProfile_Params params;
	params.ProfileIndex = ProfileIndex;
	params.inArray = inArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ReliablePong
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            SeqID                          (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        DateTimeTickFromServer         (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ReliablePong(int SeqID, int64_t DateTimeTickFromServer)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16177);

	ATslPlayerController_ReliablePong_Params params;
	params.SeqID = SeqID;
	params.DateTimeTickFromServer = DateTimeTickFromServer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ReliablePing
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// int                            SeqID                          (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        DateTimeTick                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ReliablePing(int SeqID, int64_t DateTimeTick)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16174);

	ATslPlayerController_ReliablePing_Params params;
	params.SeqID = SeqID;
	params.DateTimeTick = DateTimeTick;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnToggleInventoryPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::OnToggleInventoryPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16172);

	ATslPlayerController_OnToggleInventoryPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.OnToggleInGameMenuPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::OnToggleInGameMenuPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16170);

	ATslPlayerController_OnToggleInGameMenuPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.OnToggleCameraPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::OnToggleCameraPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16168);

	ATslPlayerController_OnToggleCameraPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.OnToggleCamera
// (Final, Native, Public)

void ATslPlayerController::OnToggleCamera()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16167);

	ATslPlayerController_OnToggleCamera_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnStopHoldRotationPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::OnStopHoldRotationPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16165);

	ATslPlayerController_OnStopHoldRotationPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.OnStartHoldRotationPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::OnStartHoldRotationPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16163);

	ATslPlayerController_OnStartHoldRotationPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.OnShowCastingBarWidget
// (Final, Native, Protected)
// Parameters:
// float                          CastTime                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   CastName                       (Parm)
// bool                           OnOff                          (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::OnShowCastingBarWidget(float CastTime, const struct FText& CastName, bool OnOff)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16159);

	ATslPlayerController_OnShowCastingBarWidget_Params params;
	params.CastTime = CastTime;
	params.CastName = CastName;
	params.OnOff = OnOff;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnRep_Team
// (Final, Native, Private)

void ATslPlayerController::OnRep_Team()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16158);

	ATslPlayerController_OnRep_Team_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnRep_CameraViewBehaviour
// (Final, Native, Private)

void ATslPlayerController::OnRep_CameraViewBehaviour()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16157);

	ATslPlayerController_OnRep_CameraViewBehaviour_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnRep_bUseTPAntibotClient
// (Final, Native, Private)

void ATslPlayerController::OnRep_bUseTPAntibotClient()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16156);

	ATslPlayerController_OnRep_bUseTPAntibotClient_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnMoveToVehicleSeat
// (Final, Native, Public)
// Parameters:
// unsigned char                  idx                            (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::OnMoveToVehicleSeat(unsigned char idx)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16154);

	ATslPlayerController_OnMoveToVehicleSeat_Params params;
	params.idx = idx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnItemStackCountHandlingMode
// (Final, Native, Public, BlueprintCallable)

void ATslPlayerController::OnItemStackCountHandlingMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16153);

	ATslPlayerController_OnItemStackCountHandlingMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnInteractInVehiclePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::OnInteractInVehiclePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16151);

	ATslPlayerController_OnInteractInVehiclePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.OnInteractGamepad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::OnInteractGamepad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16149);

	ATslPlayerController_OnInteractGamepad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.OnFinishInteractionCastOnServer
// (Final, Native, Public)
// Parameters:
// class UObject*                 CastObject                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::OnFinishInteractionCastOnServer(class UObject* CastObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16147);

	ATslPlayerController_OnFinishInteractionCastOnServer_Params params;
	params.CastObject = CastObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnFinishInteractionCastOnClient
// (Final, Native, Public)
// Parameters:
// class UObject*                 CastObject                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::OnFinishInteractionCastOnClient(class UObject* CastObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16145);

	ATslPlayerController_OnFinishInteractionCastOnClient_Params params;
	params.CastObject = CastObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnExecuteExitCommand
// (Final, Native, Private)

void ATslPlayerController::OnExecuteExitCommand()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16144);

	ATslPlayerController_OnExecuteExitCommand_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnClickedReportButton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EReportCause                   ReportCause                    (Parm, ZeroConstructor, IsPlainOldData)
// ESubjectToReport               SubjectToReport                (Parm, ZeroConstructor, IsPlainOldData)
// TArray<EReportDetailCauseType> ReportDetailCauseTypeList      (Parm, ZeroConstructor)

void ATslPlayerController::OnClickedReportButton(EReportCause ReportCause, ESubjectToReport SubjectToReport, TArray<EReportDetailCauseType> ReportDetailCauseTypeList)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16136);

	ATslPlayerController_OnClickedReportButton_Params params;
	params.ReportCause = ReportCause;
	params.SubjectToReport = SubjectToReport;
	params.ReportDetailCauseTypeList = ReportDetailCauseTypeList;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OnCancelInteractionCast
// (Final, Native, Public)
// Parameters:
// class UObject*                 CastObject                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::OnCancelInteractionCast(class UObject* CastObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16134);

	ATslPlayerController_OnCancelInteractionCast_Params params;
	params.CastObject = CastObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.OffItemStackCountHandlingMode
// (Final, Native, Public, BlueprintCallable)

void ATslPlayerController::OffItemStackCountHandlingMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16133);

	ATslPlayerController_OffItemStackCountHandlingMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ObserverTeleportTo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Location                       (Parm, IsPlainOldData)

void ATslPlayerController::ObserverTeleportTo(const struct FVector& Location)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16131);

	ATslPlayerController_ObserverTeleportTo_Params params;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.NextSetViewTarget
// (Final, Native, Public, BlueprintCallable)

void ATslPlayerController::NextSetViewTarget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16130);

	ATslPlayerController_NextSetViewTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.MobileBodiesStatistics
// (Final, Exec, Native, Public)

void ATslPlayerController::MobileBodiesStatistics()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16129);

	ATslPlayerController_MobileBodiesStatistics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.KickCharacter
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class ATslCharacter*           TslCharacter                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Reason                         (ConstParm, Parm, OutParm, ReferenceParm)

void ATslPlayerController::KickCharacter(class ATslCharacter* TslCharacter, const struct FText& Reason)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16126);

	ATslPlayerController_KickCharacter_Params params;
	params.TslCharacter = TslCharacter;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.IsSpectatorState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsSpectatorState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16124);

	ATslPlayerController_IsSpectatorState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsSpectating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsSpectating()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16122);

	ATslPlayerController_IsSpectating_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsSameObservingCameraMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverCameraMode            CameraType                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsSameObservingCameraMode(EObserverCameraMode CameraType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16118);

	ATslPlayerController_IsSameObservingCameraMode_Params params;
	params.CameraType = CameraType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsReplayingKillcam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsReplayingKillcam()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16116);

	ATslPlayerController_IsReplayingKillcam_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsReplaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsReplaying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16114);

	ATslPlayerController_IsReplaying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsObserving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsObserving()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16112);

	ATslPlayerController_IsObserving_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsItemStackCountHandlingMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsItemStackCountHandlingMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16110);

	ATslPlayerController_IsItemStackCountHandlingMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsHighPing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsHighPing()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16108);

	ATslPlayerController_IsHighPing_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsGroggying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsGroggying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16106);

	ATslPlayerController_IsGroggying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsGamepadHoldProcessing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsGamepadHoldProcessing()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16104);

	ATslPlayerController_IsGamepadHoldProcessing_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.IsGameInputAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::IsGameInputAllowed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16102);

	ATslPlayerController_IsGameInputAllowed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.HideTslDebugInfomation
// (Final, Exec, Native, Public)

void ATslPlayerController::HideTslDebugInfomation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16101);

	ATslPlayerController_HideTslDebugInfomation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.HideMatchResult
// (Final, Native, Private)

void ATslPlayerController::HideMatchResult()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16100);

	ATslPlayerController_HideMatchResult_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.HideEmoteWheel
// (Final, Native, Private, BlueprintCallable)

void ATslPlayerController::HideEmoteWheel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16099);

	ATslPlayerController_HideEmoteWheel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.GetVivoxComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVivoxComponent*         ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UVivoxComponent* ATslPlayerController::GetVivoxComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16097);

	ATslPlayerController_GetVivoxComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetViewTargetTslCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ATslPlayerController::GetViewTargetTslCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16095);

	ATslPlayerController_GetViewTargetTslCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetViewTargetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATeam*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATeam* ATslPlayerController::GetViewTargetTeam()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16093);

	ATslPlayerController_GetViewTargetTeam_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTslZombieMatchResultInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FTslPlayerMatchResultInfo> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslPlayerMatchResultInfo> ATslPlayerController::GetTslZombieMatchResultInfos()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16090);

	ATslPlayerController_GetTslZombieMatchResultInfos_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTslPlayerMatchResultInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FTslPlayerMatchResultInfo> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslPlayerMatchResultInfo> ATslPlayerController::GetTslPlayerMatchResultInfos()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16087);

	ATslPlayerController_GetTslPlayerMatchResultInfos_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTslHumanMatchResultInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FTslPlayerMatchResultInfo> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslPlayerMatchResultInfo> ATslPlayerController::GetTslHumanMatchResultInfos()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16084);

	ATslPlayerController_GetTslHumanMatchResultInfos_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTslCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ATslPlayerController::GetTslCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16082);

	ATslPlayerController_GetTslCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTeamOverallKillCountAtObserving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslPlayerController::GetTeamOverallKillCountAtObserving()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16080);

	ATslPlayerController_GetTeamOverallKillCountAtObserving_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTeamMemberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslPlayerController::GetTeamMemberCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16078);

	ATslPlayerController_GetTeamMemberCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTargetViewRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATslPlayerController::GetTargetViewRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16076);

	ATslPlayerController_GetTargetViewRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetSpectatingPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATslPlayerController::GetSpectatingPlayerName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16074);

	ATslPlayerController_GetSpectatingPlayerName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetReplicateTeamMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ATslCharacter*>   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class ATslCharacter*> ATslPlayerController::GetReplicateTeamMembers()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16071);

	ATslPlayerController_GetReplicateTeamMembers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetReplicateCharacters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ATslCharacter*>   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class ATslCharacter*> ATslPlayerController::GetReplicateCharacters()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16068);

	ATslPlayerController_GetReplicateCharacters_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetReplicateCarePackageItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACarePackageItem*> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class ACarePackageItem*> ATslPlayerController::GetReplicateCarePackageItems()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16065);

	ATslPlayerController_GetReplicateCarePackageItems_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetOtherElapsedCastTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPlayerController::GetOtherElapsedCastTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16063);

	ATslPlayerController_GetOtherElapsedCastTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetOtherCastTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPlayerController::GetOtherCastTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16061);

	ATslPlayerController_GetOtherCastTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetOtherCastingName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText ATslPlayerController::GetOtherCastingName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16059);

	ATslPlayerController_GetOtherCastingName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetObserverCameraMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverCameraMode            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EObserverCameraMode ATslPlayerController::GetObserverCameraMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16056);

	ATslPlayerController_GetObserverCameraMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetObserverAuthorityType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverAuthorityType         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EObserverAuthorityType ATslPlayerController::GetObserverAuthorityType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16053);

	ATslPlayerController_GetObserverAuthorityType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetKillerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATslPlayerController::GetKillerName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16051);

	ATslPlayerController_GetKillerName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetHudDebugText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText ATslPlayerController::GetHudDebugText()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16049);

	ATslPlayerController_GetHudDebugText_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetGearProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            ProfileIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UClass*>          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UClass*> ATslPlayerController::GetGearProfile(int ProfileIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16045);

	ATslPlayerController_GetGearProfile_Params params;
	params.ProfileIndex = ProfileIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetCurrentHoldProgressRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPlayerController::GetCurrentHoldProgressRate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16043);

	ATslPlayerController_GetCurrentHoldProgressRate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetClientTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           IncludeSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class ATeam*>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class ATeam*> ATslPlayerController::GetClientTeam(bool IncludeSelf)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16039);

	ATslPlayerController_GetClientTeam_Params params;
	params.IncludeSelf = IncludeSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetCanAllSpectate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::GetCanAllSpectate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16037);

	ATslPlayerController_GetCanAllSpectate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.GetAliveTeamMemberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslPlayerController::GetAliveTeamMemberCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16035);

	ATslPlayerController_GetAliveTeamMemberCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.ForceGotoLobbyPopUpHandler
// (Final, Native, Public)
// Parameters:
// EPopupButtonID                 ButtonID                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ForceGotoLobbyPopUpHandler(EPopupButtonID ButtonID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16032);

	ATslPlayerController_ForceGotoLobbyPopUpHandler_Params params;
	params.ButtonID = ButtonID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.DumpActorDetailByRaycast
// (Final, Exec, Native, Public)

void ATslPlayerController::DumpActorDetailByRaycast()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16031);

	ATslPlayerController_DumpActorDetailByRaycast_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.DropItem
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 ItemTypeName                   (Parm, ZeroConstructor)

void ATslPlayerController::DropItem(const struct FString& ItemTypeName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16029);

	ATslPlayerController_DropItem_Params params;
	params.ItemTypeName = ItemTypeName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.CompleteReportKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::CompleteReportKiller()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16027);

	ATslPlayerController_CompleteReportKiller_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.CloseKickPlayerWarningPopup
// (Final, Native, Public)
// Parameters:
// EPopupButtonID                 ButtonID                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::CloseKickPlayerWarningPopup(EPopupButtonID ButtonID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16024);

	ATslPlayerController_CloseKickPlayerWarningPopup_Params params;
	params.ButtonID = ButtonID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientWasWarnedTobeKickedTP
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FText                   KickReason                     (ConstParm, Parm, ReferenceParm)

void ATslPlayerController::ClientWasWarnedTobeKickedTP(const struct FText& KickReason)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16022);

	ATslPlayerController_ClientWasWarnedTobeKickedTP_Params params;
	params.KickReason = KickReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientWasKickedToLobbyTP
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FText                   KickReason                     (ConstParm, Parm, ReferenceParm)

void ATslPlayerController::ClientWasKickedToLobbyTP(const struct FText& KickReason)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16020);

	ATslPlayerController_ClientWasKickedToLobbyTP_Params params;
	params.KickReason = KickReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientWasKickedAndExitTP
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FText                   KickReason                     (ConstParm, Parm, ReferenceParm)

void ATslPlayerController::ClientWasKickedAndExitTP(const struct FText& KickReason)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16018);

	ATslPlayerController_ClientWasKickedAndExitTP_Params params;
	params.KickReason = KickReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientUpdateSpectatorCameraMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FName                   InCameraName                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbFirstPerson                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbIsInVehicle                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbIsScoping                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientUpdateSpectatorCameraMode(const struct FName& InCameraName, bool InbFirstPerson, bool InbIsInVehicle, bool InbIsScoping)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16013);

	ATslPlayerController_ClientUpdateSpectatorCameraMode_Params params;
	params.InCameraName = InCameraName;
	params.InbFirstPerson = InbFirstPerson;
	params.InbIsInVehicle = InbIsInVehicle;
	params.InbIsScoping = InbIsScoping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientUpdateDropPackageAchievement
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientUpdateDropPackageAchievement()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16012);

	ATslPlayerController_ClientUpdateDropPackageAchievement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientUpdateCarePackageAchievement
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientUpdateCarePackageAchievement()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16011);

	ATslPlayerController_ClientUpdateCarePackageAchievement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientStartOnlineGame
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientStartOnlineGame()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16010);

	ATslPlayerController_ClientStartOnlineGame_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientShowMatchResult
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ATslPlayerController::ClientShowMatchResult()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16009);

	ATslPlayerController_ClientShowMatchResult_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientShowCastingBar
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                          CastTime                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   CastName                       (ConstParm, Parm, ReferenceParm)
// bool                           OnOff                          (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientShowCastingBar(float CastTime, const struct FText& CastName, bool OnOff)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16005);

	ATslPlayerController_ClientShowCastingBar_Params params;
	params.CastTime = CastTime;
	params.CastName = CastName;
	params.OnOff = OnOff;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientSetTslPlayerMatchResultInfos
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FTslPlayerMatchResultInfo> InTslPlayerMatchResultInfos    (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void ATslPlayerController::ClientSetTslPlayerMatchResultInfos(TArray<struct FTslPlayerMatchResultInfo> InTslPlayerMatchResultInfos)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16002);

	ATslPlayerController_ClientSetTslPlayerMatchResultInfos_Params params;
	params.InTslPlayerMatchResultInfos = InTslPlayerMatchResultInfos;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientSetCanAllSpectate
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           InbCanSpectate                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientSetCanAllSpectate(bool InbCanSpectate)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16000);

	ATslPlayerController_ClientSetCanAllSpectate_Params params;
	params.InbCanSpectate = InbCanSpectate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientSendTPPacketReliable
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<unsigned char>          Packet                         (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void ATslPlayerController::ClientSendTPPacketReliable(TArray<unsigned char> Packet)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15997);

	ATslPlayerController_ClientSendTPPacketReliable_Params params;
	params.Packet = Packet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientSendRoundEndEvent
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           bIsWinner                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            ExpendedTimeInSeconds          (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientSendRoundEndEvent(bool bIsWinner, int ExpendedTimeInSeconds)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15994);

	ATslPlayerController_ClientSendRoundEndEvent_Params params;
	params.bIsWinner = bIsWinner;
	params.ExpendedTimeInSeconds = ExpendedTimeInSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientSendPacketUnreliable
// (Net, Native, Event, Public, NetClient)
// Parameters:
// TArray<unsigned char>          Packet                         (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void ATslPlayerController::ClientSendPacketUnreliable(TArray<unsigned char> Packet)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15991);

	ATslPlayerController_ClientSendPacketUnreliable_Params params;
	params.Packet = Packet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientSendPacketReliable
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<unsigned char>          Packet                         (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void ATslPlayerController::ClientSendPacketReliable(TArray<unsigned char> Packet)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15988);

	ATslPlayerController_ClientSendPacketReliable_Params params;
	params.Packet = Packet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientRestoreSpectatorOnReconnection
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientRestoreSpectatorOnReconnection()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15987);

	ATslPlayerController_ClientRestoreSpectatorOnReconnection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientOnCharacterRestart
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientOnCharacterRestart()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15986);

	ATslPlayerController_ClientOnCharacterRestart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientOnCharacterDeath
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           bIsTeamMatch                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bHasAliveTeamMember            (Parm, ZeroConstructor, IsPlainOldData)
// struct FTslReportUserInfo      InKillerInfo                   (Parm)
// bool                           InbCanReport                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientOnCharacterDeath(bool bIsTeamMatch, bool bHasAliveTeamMember, const struct FTslReportUserInfo& InKillerInfo, bool InbCanReport)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15981);

	ATslPlayerController_ClientOnCharacterDeath_Params params;
	params.bIsTeamMatch = bIsTeamMatch;
	params.bHasAliveTeamMember = bHasAliveTeamMember;
	params.InKillerInfo = InKillerInfo;
	params.InbCanReport = InbCanReport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyStartBuff
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// struct FName                   BuffName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bStart                         (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientNotifyStartBuff(const struct FName& BuffName, bool bStart)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15978);

	ATslPlayerController_ClientNotifyStartBuff_Params params;
	params.BuffName = BuffName;
	params.bStart = bStart;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifySpeedBoost
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                          Boost                          (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientNotifySpeedBoost(float Boost)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15976);

	ATslPlayerController_ClientNotifySpeedBoost_Params params;
	params.Boost = Boost;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyRestrictingPlayArea
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ATslPlayerController::ClientNotifyRestrictingPlayArea()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15975);

	ATslPlayerController_ClientNotifyRestrictingPlayArea_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyPlayerEndWithoutHitInfo
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// int                            Ranking                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FTslPlayerStatistics    Statistics                     (Parm)
// struct FTslPlayerStatisticsForOwner StatisticsForOwner             (Parm)

void ATslPlayerController::ClientNotifyPlayerEndWithoutHitInfo(int Ranking, const struct FTslPlayerStatistics& Statistics, const struct FTslPlayerStatisticsForOwner& StatisticsForOwner)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15971);

	ATslPlayerController_ClientNotifyPlayerEndWithoutHitInfo_Params params;
	params.Ranking = Ranking;
	params.Statistics = Statistics;
	params.StatisticsForOwner = StatisticsForOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyPlayerEnd
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// int                            Ranking                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FTslPlayerStatistics    Statistics                     (Parm)
// struct FTslPlayerStatisticsForOwner StatisticsForOwner             (Parm)
// struct FTakeHitInfo            LastTakeHitInfo                (Parm)

void ATslPlayerController::ClientNotifyPlayerEnd(int Ranking, const struct FTslPlayerStatistics& Statistics, const struct FTslPlayerStatisticsForOwner& StatisticsForOwner, const struct FTakeHitInfo& LastTakeHitInfo)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15966);

	ATslPlayerController_ClientNotifyPlayerEnd_Params params;
	params.Ranking = Ranking;
	params.Statistics = Statistics;
	params.StatisticsForOwner = StatisticsForOwner;
	params.LastTakeHitInfo = LastTakeHitInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyNextGasIn
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// struct FVector_NetQuantize     PoisonGasWarningPosition       (Parm)
// float                          PoisonGasWarningRadius         (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientNotifyNextGasIn(const struct FVector_NetQuantize& PoisonGasWarningPosition, float PoisonGasWarningRadius)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15963);

	ATslPlayerController_ClientNotifyNextGasIn_Params params;
	params.PoisonGasWarningPosition = PoisonGasWarningPosition;
	params.PoisonGasWarningRadius = PoisonGasWarningRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyHealAmount_Unreliable
// (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                          Heal                           (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientNotifyHealAmount_Unreliable(float Heal)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15961);

	ATslPlayerController_ClientNotifyHealAmount_Unreliable_Params params;
	params.Heal = Heal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyHealAmount_Reliable
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                          Heal                           (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientNotifyHealAmount_Reliable(float Heal)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15959);

	ATslPlayerController_ClientNotifyHealAmount_Reliable_Params params;
	params.Heal = Heal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyHealAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Heal                           (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientNotifyHealAmount(float Heal)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15957);

	ATslPlayerController_ClientNotifyHealAmount_Params params;
	params.Heal = Heal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyHeal_Unreliable
// (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                          HealthStart                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Health                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxHealth                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientNotifyHeal_Unreliable(float HealthStart, float Health, float MaxHealth)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15953);

	ATslPlayerController_ClientNotifyHeal_Unreliable_Params params;
	params.HealthStart = HealthStart;
	params.Health = Health;
	params.MaxHealth = MaxHealth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyHeal_Reliable
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                          HealthStart                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Health                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxHealth                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientNotifyHeal_Reliable(float HealthStart, float Health, float MaxHealth)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15949);

	ATslPlayerController_ClientNotifyHeal_Reliable_Params params;
	params.HealthStart = HealthStart;
	params.Health = Health;
	params.MaxHealth = MaxHealth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientNotifyHeal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          HealthStart                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Health                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxHealth                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientNotifyHeal(float HealthStart, float Health, float MaxHealth)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15945);

	ATslPlayerController_ClientNotifyHeal_Params params;
	params.HealthStart = HealthStart;
	params.Health = Health;
	params.MaxHealth = MaxHealth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientInteractByComponent
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class UActorComponent*         TargetComponent                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslPlayerController::ClientInteractByComponent(class UActorComponent* TargetComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15943);

	ATslPlayerController_ClientInteractByComponent_Params params;
	params.TargetComponent = TargetComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientInteract
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                  TargetObject                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::ClientInteract(class AActor* TargetObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15941);

	ATslPlayerController_ClientInteract_Params params;
	params.TargetObject = TargetObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientGameStarted
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientGameStarted()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15940);

	ATslPlayerController_ClientGameStarted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientEndOnlineGame
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientEndOnlineGame()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15939);

	ATslPlayerController_ClientEndOnlineGame_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.ClientAdminCopyString
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)

void ATslPlayerController::ClientAdminCopyString(const struct FString& inString)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15937);

	ATslPlayerController_ClientAdminCopyString_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.Cheat_ServerSpawnVehicle
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            VehicleIndex                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::Cheat_ServerSpawnVehicle(int VehicleIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15935);

	ATslPlayerController_Cheat_ServerSpawnVehicle_Params params;
	params.VehicleIndex = VehicleIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.CastInteractionOnServer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AActor*                  TargetActor                    (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::CastInteractionOnServer(class AActor* TargetActor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15933);

	ATslPlayerController_CastInteractionOnServer_Params params;
	params.TargetActor = TargetActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.CastInteractionByComponentOnServer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UActorComponent*         TargetComponent                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslPlayerController::CastInteractionByComponentOnServer(class UActorComponent* TargetComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15931);

	ATslPlayerController_CastInteractionByComponentOnServer_Params params;
	params.TargetComponent = TargetComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.CanSeeTerrainThroughFogInTheAir
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::CanSeeTerrainThroughFogInTheAir()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15929);

	ATslPlayerController_CanSeeTerrainThroughFogInTheAir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.CanReport
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerController::CanReport()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15927);

	ATslPlayerController_CanReport_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerController.BP_Test_SpawnVehicle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            VehicleIndex                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerController::BP_Test_SpawnVehicle(int VehicleIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15925);

	ATslPlayerController_BP_Test_SpawnVehicle_Params params;
	params.VehicleIndex = VehicleIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.BEServer
// (Final, Exec, Native, Private)
// Parameters:
// struct FString                 Command                        (Parm, ZeroConstructor)
// struct FString                 Arg0                           (Parm, ZeroConstructor)
// struct FString                 Arg1                           (Parm, ZeroConstructor)
// struct FString                 Arg2                           (Parm, ZeroConstructor)

void ATslPlayerController::BEServer(const struct FString& Command, const struct FString& Arg0, const struct FString& Arg1, const struct FString& Arg2)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15920);

	ATslPlayerController_BEServer_Params params;
	params.Command = Command;
	params.Arg0 = Arg0;
	params.Arg1 = Arg1;
	params.Arg2 = Arg2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.BEClient
// (Final, Exec, Native, Private)
// Parameters:
// struct FString                 Command                        (Parm, ZeroConstructor)

void ATslPlayerController::BEClient(const struct FString& Command)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15918);

	ATslPlayerController_BEClient_Params params;
	params.Command = Command;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerController.Admin
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 ServerAdminCommand             (Parm, ZeroConstructor)

void ATslPlayerController::Admin(const struct FString& ServerAdminCommand)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(15916);

	ATslPlayerController_Admin_Params params;
	params.ServerAdminCommand = ServerAdminCommand;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ConsoleCommandExecutor.ExecuteConsoleCommands
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FString>         Commands                       (Parm, ZeroConstructor)

void AConsoleCommandExecutor::ExecuteConsoleCommands(TArray<struct FString> Commands)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16347);

	AConsoleCommandExecutor_ExecuteConsoleCommands_Params params;
	params.Commands = Commands;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.SlotInterface.IsWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USlotInterface::IsWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16394);

	USlotInterface_IsWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.IsStackable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USlotInterface::IsStackable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16392);

	USlotInterface_IsStackable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.IsPackageItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USlotInterface::IsPackageItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16390);

	USlotInterface_IsPackageItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.IsEquipable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USlotInterface::IsEquipable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16388);

	USlotInterface_IsEquipable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.IsCastableItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USlotInterface::IsCastableItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16386);

	USlotInterface_IsCastableItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.IsAttachment
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USlotInterface::IsAttachment()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16384);

	USlotInterface_IsAttachment_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetUnitSpace
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float USlotInterface::GetUnitSpace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16382);

	USlotInterface_GetUnitSpace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetToolTipIconTexture
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture* USlotInterface::GetToolTipIconTexture()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16380);

	USlotInterface_GetToolTipIconTexture_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetToolTipIconSizeRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float USlotInterface::GetToolTipIconSizeRatio()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16378);

	USlotInterface_GetToolTipIconSizeRatio_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetStackCountMax
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int USlotInterface::GetStackCountMax()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16376);

	USlotInterface_GetStackCountMax_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetStackCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int USlotInterface::GetStackCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16374);

	USlotInterface_GetStackCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetSpace
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float USlotInterface::GetSpace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16372);

	USlotInterface_GetSpace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetSortPriority
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int USlotInterface::GetSortPriority()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16370);

	USlotInterface_GetSortPriority_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetSlotName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText USlotInterface::GetSlotName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16368);

	USlotInterface_GetSlotName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetSlotDetailedName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText USlotInterface::GetSlotDetailedName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16366);

	USlotInterface_GetSlotDetailedName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetSlotDescription
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText USlotInterface::GetSlotDescription()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16364);

	USlotInterface_GetSlotDescription_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetSlotCategory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText USlotInterface::GetSlotCategory()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16362);

	USlotInterface_GetSlotCategory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetSkin
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkinItem*               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class USkinItem* USlotInterface::GetSkin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16360);

	USlotInterface_GetSkin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetIconTexture
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture* USlotInterface::GetIconTexture()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16358);

	USlotInterface_GetIconTexture_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetIconSizeRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float USlotInterface::GetIconSizeRatio()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16356);

	USlotInterface_GetIconSizeRatio_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotInterface.GetDropSound
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkAudioEvent*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAkAudioEvent* USlotInterface::GetDropSound()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16354);

	USlotInterface_GetDropSound_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotContainerInterface.ShowSlotContextMenu
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)

void USlotContainerInterface::ShowSlotContextMenu(const TScriptInterface<class USlotInterface>& Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16436);

	USlotContainerInterface_ShowSlotContextMenu_Params params;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.SlotContainerInterface.IsEnableAction
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// TScriptInterface<class USlotContainerInterface> OtherContainer                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USlotContainerInterface::IsEnableAction(const TScriptInterface<class USlotInterface>& Slot, const TScriptInterface<class USlotContainerInterface>& OtherContainer, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16431);

	USlotContainerInterface_IsEnableAction_Params params;
	params.Slot = Slot;
	params.OtherContainer = OtherContainer;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotContainerInterface.HideSlotContextMenu
// (Native, Public, BlueprintCallable)

void USlotContainerInterface::HideSlotContextMenu()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16430);

	USlotContainerInterface_HideSlotContextMenu_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.SlotContainerInterface.GetSlotContext
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class USlotInterface> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TScriptInterface<class USlotInterface> USlotContainerInterface::GetSlotContext()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16428);

	USlotContainerInterface_GetSlotContext_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetSlotContainerOwner
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AActor* USlotContainerInterface::GetSlotContainerOwner()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16426);

	USlotContainerInterface_GetSlotContainerOwner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetSlotContainerName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName USlotContainerInterface::GetSlotContainerName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16424);

	USlotContainerInterface_GetSlotContainerName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetDefaultActionName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName USlotContainerInterface::GetDefaultActionName(const TScriptInterface<class USlotInterface>& Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16421);

	USlotContainerInterface_GetDefaultActionName_Params params;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetAvailableSlotActions
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FName>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FName> USlotContainerInterface::GetAvailableSlotActions(const TScriptInterface<class USlotInterface>& Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16417);

	USlotContainerInterface_GetAvailableSlotActions_Params params;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetAllSlots
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TScriptInterface<class USlotInterface>> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<TScriptInterface<class USlotInterface>> USlotContainerInterface::GetAllSlots()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16414);

	USlotContainerInterface_GetAllSlots_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetActionName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// TScriptInterface<class USlotContainerInterface> OtherContainer                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName USlotContainerInterface::GetActionName(const TScriptInterface<class USlotInterface>& Slot, const TScriptInterface<class USlotContainerInterface>& OtherContainer, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16409);

	USlotContainerInterface_GetActionName_Params params;
	params.Slot = Slot;
	params.OtherContainer = OtherContainer;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SlotContainerInterface.DropSlotOnOtherContainer
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// TScriptInterface<class USlotContainerInterface> OtherContainer                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)

void USlotContainerInterface::DropSlotOnOtherContainer(const TScriptInterface<class USlotInterface>& Slot, const TScriptInterface<class USlotContainerInterface>& OtherContainer, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16405);

	USlotContainerInterface_DropSlotOnOtherContainer_Params params;
	params.Slot = Slot;
	params.OtherContainer = OtherContainer;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.SlotContainerInterface.DoSlotActionDefault
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)

void USlotContainerInterface::DoSlotActionDefault(const TScriptInterface<class USlotInterface>& Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16403);

	USlotContainerInterface_DoSlotActionDefault_Params params;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.SlotContainerInterface.DoSlotAction
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ActionName                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)

void USlotContainerInterface::DoSlotAction(const struct FName& ActionName, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16400);

	USlotContainerInterface_DoSlotAction_Params params;
	params.ActionName = ActionName;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.SlotContainerInterface.DoActionWithSlot
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ActionName                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)

void USlotContainerInterface::DoActionWithSlot(const TScriptInterface<class USlotInterface>& Slot, const struct FName& ActionName, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16396);

	USlotContainerInterface_DoActionWithSlot_Params params;
	params.Slot = Slot;
	params.ActionName = ActionName;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemExplorerInterface.UpdateItemList
// (Native, Public, BlueprintCallable)

void UItemExplorerInterface::UpdateItemList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16443);

	UItemExplorerInterface_UpdateItemList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemExplorerInterface.GetExplorableItemSlotList
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TScriptInterface<class USlotInterface>> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<TScriptInterface<class USlotInterface>> UItemExplorerInterface::GetExplorableItemSlotList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16440);

	UItemExplorerInterface_GetExplorableItemSlotList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ExplorableItemInterface.IsValidExplorableItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UExplorableItemInterface::IsValidExplorableItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16450);

	UExplorableItemInterface_IsValidExplorableItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ExplorableItemInterface.GetInteractiveActionName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UExplorableItemInterface::GetInteractiveActionName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16448);

	UExplorableItemInterface_GetInteractiveActionName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ExplorableItemInterface.GetExplorationDistance
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UExplorableItemInterface::GetExplorationDistance()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16446);

	UExplorableItemInterface_GetExplorationDistance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Item.UseBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UItem::UseBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16471);

	UItem_UseBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Item.PickUpBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   TargetContainer                (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UItem::PickUpBy(class ATslCharacter* Character, const struct FName& TargetContainer, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16466);

	UItem_PickUpBy_Params params;
	params.Character = Character;
	params.TargetContainer = TargetContainer;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Item.IsWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UItem::IsWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16464);

	UItem_IsWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Item.IsToy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UItem::IsToy()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16462);

	UItem_IsToy_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Item.IsPackageItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UItem::IsPackageItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16460);

	UItem_IsPackageItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Item.IsEquipable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UItem::IsEquipable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16458);

	UItem_IsEquipable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Item.IsCastableItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UItem::IsCastableItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16456);

	UItem_IsCastableItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Item.IsAttachment
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UItem::IsAttachment()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16454);

	UItem_IsAttachment_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Item.GetIconTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture* UItem::GetIconTexture()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16452);

	UItem_GetIconTexture_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ItemPackage.Items_RepNotify
// (Final, Native, Private)

void AItemPackage::Items_RepNotify()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16512);

	AItemPackage_Items_RepNotify_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemPackage.IsOpenedBy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AItemPackage::IsOpenedBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16509);

	AItemPackage_IsOpenedBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ItemPackage.ClientOnInteractBy
// (Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (Parm, ZeroConstructor, IsPlainOldData)

void AItemPackage::ClientOnInteractBy(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16507);

	AItemPackage_ClientOnInteractBy_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemPackage.AllowInteract
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AItemPackage::AllowInteract(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16504);

	AItemPackage_AllowInteract_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.DoorFrameComponent.GetDoorStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMesh*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UStaticMesh* UDoorFrameComponent::GetDoorStaticMesh()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16552);

	UDoorFrameComponent_GetDoorStaticMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.DoorFrameComponent.DisableSubComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bDisable                       (Parm, ZeroConstructor, IsPlainOldData)

void UDoorFrameComponent::DisableSubComponents(bool bDisable)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16550);

	UDoorFrameComponent_DisableSubComponents_Params params;
	params.bDisable = bDisable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.SkinItem.CheckSkin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class USkinnableInterface> SkinnableInterface             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USkinItem::CheckSkin(const TScriptInterface<class USkinnableInterface>& SkinnableInterface)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16564);

	USkinItem_CheckSkin_Params params;
	params.SkinnableInterface = SkinnableInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SkinItem.ApplySkin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class USkinnableInterface> SkinnableInterface             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USkinItem::ApplySkin(const TScriptInterface<class USkinnableInterface>& SkinnableInterface)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16561);

	USkinItem_ApplySkin_Params params;
	params.SkinnableInterface = SkinnableInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SkinnableInterface.HasSkin
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USkinnableInterface::HasSkin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16572);

	USkinnableInterface_HasSkin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SkinnableInterface.ClearSkin
// (Native, Public, BlueprintCallable)

void USkinnableInterface::ClearSkin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16571);

	USkinnableInterface_ClearSkin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.DroppedItem.OnStaticMeshLoaded
// (Final, Native, Protected)

void ADroppedItem::OnStaticMeshLoaded()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16576);

	ADroppedItem_OnStaticMeshLoaded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.DroppedItem.OnRep_SkinData
// (Final, Native, Protected)

void ADroppedItem::OnRep_SkinData()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16575);

	ADroppedItem_OnRep_SkinData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.DroppedItem.Item_RepNotify
// (Final, Native, Protected)

void ADroppedItem::Item_RepNotify()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16574);

	ADroppedItem_Item_RepNotify_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.DroppedItemGroup.OnItemEndPlay
// (Final, Native, Private)

void ADroppedItemGroup::OnItemEndPlay()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16587);

	ADroppedItemGroup_OnItemEndPlay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.DroppedItemGroup.OnItemBeginPlay
// (Final, Native, Private)

void ADroppedItemGroup::OnItemBeginPlay()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16586);

	ADroppedItemGroup_OnItemBeginPlay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.DroppedItemGroup.AddItem
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UItem*                   NewItem                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewWorldLocation               (Parm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ADroppedItemGroup::AddItem(class UItem* NewItem, const struct FVector& NewWorldLocation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16582);

	ADroppedItemGroup_AddItem_Params params;
	params.NewItem = NewItem;
	params.NewWorldLocation = NewWorldLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.DroppedItemInterface.GetDroppedItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItem*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UItem* UDroppedItemInterface::GetDroppedItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16590);

	UDroppedItemInterface_GetDroppedItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.FlashBangCaptureActor.CaptureScreen
// (Final, Native, Public)

void AFlashBangCaptureActor::CaptureScreen()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16606);

	AFlashBangCaptureActor_CaptureScreen_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.FlashBangCaptureActor.CaptureINIT
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// bool                           bDoDelay                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          CaptureDelay                   (Parm, ZeroConstructor, IsPlainOldData)
// class APawn*                   PlayerRef                      (Parm, ZeroConstructor, IsPlainOldData)
// class UTextureRenderTarget2D*  RenderTexture                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FPostProcessSettings    PP_Settings                    (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           bHidePawn                      (Parm, ZeroConstructor, IsPlainOldData)

void AFlashBangCaptureActor::CaptureINIT(bool bDoDelay, float CaptureDelay, class APawn* PlayerRef, class UTextureRenderTarget2D* RenderTexture, const struct FPostProcessSettings& PP_Settings, bool bHidePawn)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16599);

	AFlashBangCaptureActor_CaptureINIT_Params params;
	params.bDoDelay = bDoDelay;
	params.CaptureDelay = CaptureDelay;
	params.PlayerRef = PlayerRef;
	params.RenderTexture = RenderTexture;
	params.PP_Settings = PP_Settings;
	params.bHidePawn = bHidePawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.GeneralItemSpawner.CreateItems
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UItem*>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UItem*> UGeneralItemSpawner::CreateItems()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16628);

	UGeneralItemSpawner_CreateItems_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.GeneralItemSpawner.CreateItemInitiators
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FItemInitiator>  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FItemInitiator> UGeneralItemSpawner::CreateItemInitiators()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16625);

	UGeneralItemSpawner_CreateItemInitiators_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.HackReporterComponent.ServerOnWallHackDetected
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class ATslCharacter*           Victim                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)

void UHackReporterComponent::ServerOnWallHackDetected(class ATslCharacter* Victim, float Distance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16635);

	UHackReporterComponent_ServerOnWallHackDetected_Params params;
	params.Victim = Victim;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.HighlightSession.RecordRemainEvents
// (Final, Native, Private)

void UHighlightSession::RecordRemainEvents()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16645);

	UHighlightSession_RecordRemainEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.HighlightSession.MatchEnded
// (Final, Native, Private)

void UHighlightSession::MatchEnded()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16644);

	UHighlightSession_MatchEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.HighlightSession.KillOtherPlayer
// (Final, Native, Private)
// Parameters:
// bool                           bGroggy                        (Parm, ZeroConstructor, IsPlainOldData)

void UHighlightSession::KillOtherPlayer(bool bGroggy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16642);

	UHighlightSession_KillOtherPlayer_Params params;
	params.bGroggy = bGroggy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.HighlightSession.Die
// (Final, Native, Private)
// Parameters:
// bool                           bGroggy                        (Parm, ZeroConstructor, IsPlainOldData)

void UHighlightSession::Die(bool bGroggy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16640);

	UHighlightSession_Die_Params params;
	params.bGroggy = bGroggy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.HighlightSession.DeathCamFinished
// (Final, Native, Private)
// Parameters:
// float                          DeathCamRunningTime            (Parm, ZeroConstructor, IsPlainOldData)

void UHighlightSession::DeathCamFinished(float DeathCamRunningTime)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16638);

	UHighlightSession_DeathCamFinished_Params params;
	params.DeathCamRunningTime = DeathCamRunningTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.InteractionInterface.GetInteractiveObjectName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UInteractionInterface::GetInteractiveObjectName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16658);

	UInteractionInterface_GetInteractiveObjectName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InteractionInterface.GetInteractionVerb
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UInteractionInterface::GetInteractionVerb()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16656);

	UInteractionInterface_GetInteractionVerb_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InteractionInterface.AllowInteractBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UInteractionInterface::AllowInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16653);

	UInteractionInterface_AllowInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InteractionComponent.GetInteractiveObjectName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UInteractionComponent::GetInteractiveObjectName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16665);

	UInteractionComponent_GetInteractiveObjectName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InteractionComponent.GetInteractionVerb
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UInteractionComponent::GetInteractionVerb()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16663);

	UInteractionComponent_GetInteractionVerb_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InteractionComponent.AllowInteractBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UInteractionComponent::AllowInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16660);

	UInteractionComponent_AllowInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.DroppedItemActorComponent.OnInteractDelegate
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (Parm, ZeroConstructor, IsPlainOldData)

void UDroppedItemActorComponent::OnInteractDelegate(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16683);

	UDroppedItemActorComponent_OnInteractDelegate_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.DroppedItemActorComponent.AllowInteractDelegate
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UDroppedItemActorComponent::AllowInteractDelegate(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16680);

	UDroppedItemActorComponent_AllowInteractDelegate_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ReticlePostprocessData.GetPostprocessData
// (Final, Native, Public, Const)
// Parameters:
// struct FWeaponPPSettings       ReturnValue                    (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm)

struct FWeaponPPSettings UReticlePostprocessData::GetPostprocessData()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16689);

	UReticlePostprocessData_GetPostprocessData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.AttachableItem.GetAttachmentSlotID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   WeaponTag                      (Parm, ZeroConstructor, IsPlainOldData)
// EWeaponAttachmentSlotID        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EWeaponAttachmentSlotID UAttachableItem::GetAttachmentSlotID(const struct FName& WeaponTag)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16698);

	UAttachableItem_GetAttachmentSlotID_Params params;
	params.WeaponTag = WeaponTag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.AttachableItem.GetAttachmentData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   WeaponTag                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FWeaponAttachmentData   ReturnValue                    (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm)

struct FWeaponAttachmentData UAttachableItem::GetAttachmentData(const struct FName& WeaponTag)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16695);

	UAttachableItem_GetAttachmentData_Params params;
	params.WeaponTag = WeaponTag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.HealItem.GetHealLimit
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           TslCharacter                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UHealItem::GetHealLimit(class ATslCharacter* TslCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16713);

	UHealItem_GetHealLimit_Params params;
	params.TslCharacter = TslCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.EquipableItem.UnequipBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)

void UEquipableItem::UnequipBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16725);

	UEquipableItem_UnequipBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.EquipableItem.EquipBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEquipPosition          Position                       (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEquipableItem::EquipBy(class ATslCharacter* Character, const struct FEquipPosition& Position)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16721);

	UEquipableItem_EquipBy_Params params;
	params.Character = Character;
	params.Position = Position;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.EquipableItem.CanEquipTo
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEquipableItem::CanEquipTo(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16718);

	UEquipableItem_CanEquipTo_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ThrowableItem.GetEquippedWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* UThrowableItem::GetEquippedWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16753);

	UThrowableItem_GetEquippedWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ThrowableItem.GetDefaultWeaponObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* UThrowableItem::GetDefaultWeaponObject()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16751);

	UThrowableItem_GetDefaultWeaponObject_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.Weapon_AttachShoulder
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon::Weapon_AttachShoulder()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16854);

	ATslWeapon_Weapon_AttachShoulder_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.Weapon_AttachHand
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon::Weapon_AttachHand()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16853);

	ATslWeapon_Weapon_AttachHand_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.SimulatePhysicalBodyHit
// (Final, Native, Protected, HasOutParms, HasDefaults)
// Parameters:
// struct FHitResult              Impact                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ShotDirection                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void ATslWeapon::SimulatePhysicalBodyHit(const struct FHitResult& Impact, const struct FVector& ShotDirection)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16850);

	ATslWeapon_SimulatePhysicalBodyHit_Params params;
	params.Impact = Impact;
	params.ShotDirection = ShotDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.ServerLogFireWeapon
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FAttackId               AttackId                       (Parm)

void ATslWeapon::ServerLogFireWeapon(const struct FAttackId& AttackId)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16848);

	ATslWeapon_ServerLogFireWeapon_Params params;
	params.AttackId = AttackId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.OnRep_SkinData
// (Final, Native, Private)

void ATslWeapon::OnRep_SkinData()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16847);

	ATslWeapon_OnRep_SkinData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.OnRep_MyPawn
// (Native, Protected)

void ATslWeapon::OnRep_MyPawn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16846);

	ATslWeapon_OnRep_MyPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.OnRep_AttachedItemClasses
// (Native, Protected, HasOutParms)
// Parameters:
// TArray<class UClass*>          OldVal                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void ATslWeapon::OnRep_AttachedItemClasses(TArray<class UClass*> OldVal)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16843);

	ATslWeapon_OnRep_AttachedItemClasses_Params params;
	params.OldVal = OldVal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.OnAttachmentStaticMeshLoaded
// (Final, Native, Public)

void ATslWeapon::OnAttachmentStaticMeshLoaded()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16842);

	ATslWeapon_OnAttachmentStaticMeshLoaded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.OnAnimationNotify
// (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*  MeshComp                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   NotifyName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void ATslWeapon::OnAnimationNotify(class USkeletalMeshComponent* MeshComp, const struct FName& NotifyName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16839);

	ATslWeapon_OnAnimationNotify_Params params;
	params.MeshComp = MeshComp;
	params.NotifyName = NotifyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.IsWeaponAttachedToShoulder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon::IsWeaponAttachedToShoulder()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16837);

	ATslWeapon_IsWeaponAttachedToShoulder_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.IsCustomSightAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID        SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon::IsCustomSightAttached(EWeaponAttachmentSlotID SlotID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16833);

	ATslWeapon_IsCustomSightAttached_Params params;
	params.SlotID = SlotID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponReadyDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon::GetWeaponReadyDuration()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16831);

	ATslWeapon_GetWeaponReadyDuration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class USkeletalMeshComponent* ATslWeapon::GetWeaponMesh()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16829);

	ATslWeapon_GetWeaponMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEquipableItem*          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEquipableItem* ATslWeapon::GetWeaponItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16827);

	ATslWeapon_GetWeaponItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponGripTypeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponGripLeftHand            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EWeaponGripLeftHand ATslWeapon::GetWeaponGripTypeLeft()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16824);

	ATslWeapon_GetWeaponGripTypeLeft_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponEquipDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon::GetWeaponEquipDuration()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16822);

	ATslWeapon_GetWeaponEquipDuration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponDamage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon::GetWeaponDamage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16820);

	ATslWeapon_GetWeaponDamage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWeaponData             ReturnValue                    (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm)

struct FWeaponData ATslWeapon::GetWeaponConfig()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16818);

	ATslWeapon_GetWeaponConfig_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponClassEnum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponClass                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EWeaponClass ATslWeapon::GetWeaponClassEnum()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16815);

	ATslWeapon_GetWeaponClassEnum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAttachmentPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID        SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName ATslWeapon::GetWeaponAttachmentPoint(EWeaponAttachmentSlotID SlotID, const struct FName& Tag)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16810);

	ATslWeapon_GetWeaponAttachmentPoint_Params params;
	params.SlotID = SlotID;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAttachmentData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID        SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FWeaponAttachmentData   ReturnValue                    (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm)

struct FWeaponAttachmentData ATslWeapon::GetWeaponAttachmentData(EWeaponAttachmentSlotID SlotID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16806);

	ATslWeapon_GetWeaponAttachmentData_Params params;
	params.SlotID = SlotID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAttachmentAssetDatas
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FWeaponAttachmentAssetData> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FWeaponAttachmentAssetData> ATslWeapon::GetWeaponAttachmentAssetDatas()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16803);

	ATslWeapon_GetWeaponAttachmentAssetDatas_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAttachmentAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID        SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FWeaponAttachmentAssetData ReturnValue                    (ConstParm, Parm, OutParm, ReturnParm)

struct FWeaponAttachmentAssetData ATslWeapon::GetWeaponAttachmentAsset(EWeaponAttachmentSlotID SlotID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16799);

	ATslWeapon_GetWeaponAttachmentAsset_Params params;
	params.SlotID = SlotID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAnimationKick
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon::GetWeaponAnimationKick()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16797);

	ATslWeapon_GetWeaponAnimationKick_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetThrownType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EThrownWeaponType              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EThrownWeaponType ATslWeapon::GetThrownType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16794);

	ATslWeapon_GetThrownType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetSwayModifier
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslWeapon::GetSwayModifier()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16792);

	ATslWeapon_GetSwayModifier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetStanceSwayModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimStance                    Stance                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon::GetStanceSwayModifier(EAnimStance Stance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16788);

	ATslWeapon_GetStanceSwayModifier_Params params;
	params.Stance = Stance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetRecoilMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon::GetRecoilMontage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16786);

	ATslWeapon_GetRecoilMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetPawnOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ATslWeapon::GetPawnOwner()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16784);

	ATslWeapon_GetPawnOwner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetLowerRailOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslWeapon::GetLowerRailOffset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16782);

	ATslWeapon_GetLowerRailOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetItemName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText ATslWeapon::GetItemName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16780);

	ATslWeapon_GetItemName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetDoGripPose
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon::GetDoGripPose()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16778);

	ATslWeapon_GetDoGripPose_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetAttachedStaticComponentMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<EWeaponAttachmentSlotID, class UAsyncStaticMeshComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TMap<EWeaponAttachmentSlotID, class UAsyncStaticMeshComponent*> ATslWeapon::GetAttachedStaticComponentMap()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16773);

	ATslWeapon_GetAttachedStaticComponentMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetAttachedMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UAsyncStaticMeshComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UAsyncStaticMeshComponent*> ATslWeapon::GetAttachedMesh()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16770);

	ATslWeapon_GetAttachedMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetAnimWeaponType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimWeaponType                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EAnimWeaponType ATslWeapon::GetAnimWeaponType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16767);

	ATslWeapon_GetAnimWeaponType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetAllWeaponAttachmentData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FWeaponAttachmentData> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FWeaponAttachmentData> ATslWeapon::GetAllWeaponAttachmentData()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16764);

	ATslWeapon_GetAllWeaponAttachmentData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.GetAllWeaponAttachmentAssets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FWeaponAttachmentAssetData> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FWeaponAttachmentAssetData> ATslWeapon::GetAllWeaponAttachmentAssets()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16761);

	ATslWeapon_GetAllWeaponAttachmentAssets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon.ClientInitByReconnection
// (Final, Net, NetReliable, Native, Event, Private, NetClient, NetValidate)
// Parameters:
// bool                           bIsArmed                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon::ClientInitByReconnection(bool bIsArmed)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16759);

	ATslWeapon_ClientInitByReconnection_Params params;
	params.bIsArmed = bIsArmed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.AttachWeaponToSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon::AttachWeaponToSlot(int SlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16757);

	ATslWeapon_AttachWeaponToSlot_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon.AttachWeaponToMesh
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon::AttachWeaponToMesh()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16756);

	ATslWeapon_AttachWeaponToMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponItem.SetFiringMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFiringMode                    fMode                          (Parm, ZeroConstructor, IsPlainOldData)

void UWeaponItem::SetFiringMode(EFiringMode fMode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16953);

	UWeaponItem_SetFiringMode_Params params;
	params.fMode = fMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponItem.IsAttachable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAttachableItem*         Item                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UWeaponItem::IsAttachable(class UAttachableItem* Item)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16950);

	UWeaponItem_IsAttachable_Params params;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponItem.HasAttachmentSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID        SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UWeaponItem::HasAttachmentSlot(EWeaponAttachmentSlotID SlotID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16946);

	UWeaponItem_HasAttachmentSlot_Params params;
	params.SlotID = SlotID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponItem.GetFiringMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFiringMode                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EFiringMode UWeaponItem::GetFiringMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16943);

	UWeaponItem_GetFiringMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponItem.GetEquippedWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* UWeaponItem::GetEquippedWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16941);

	UWeaponItem_GetEquippedWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponItem.GetDefaultWeaponObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* UWeaponItem::GetDefaultWeaponObject()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16939);

	UWeaponItem_GetDefaultWeaponObject_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponItem.GetAttachedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID        SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// class UAttachableItem*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAttachableItem* UWeaponItem::GetAttachedItem(EWeaponAttachmentSlotID SlotID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16935);

	UWeaponItem_GetAttachedItem_Params params;
	params.SlotID = SlotID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponItem.GetAttachableItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UWeaponItem::GetAttachableItemCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16933);

	UWeaponItem_GetAttachableItemCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponItem.GetAllAttachedItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UAttachableItem*> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UAttachableItem*> UWeaponItem::GetAllAttachedItems()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16930);

	UWeaponItem_GetAllAttachedItems_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponItem.DetachItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EWeaponAttachmentSlotID        SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// class UAttachableItem*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAttachableItem* UWeaponItem::DetachItem(EWeaponAttachmentSlotID SlotID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16926);

	UWeaponItem_DetachItem_Params params;
	params.SlotID = SlotID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponItem.AttachItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAttachableItem*         Item                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UWeaponItem::AttachItem(class UAttachableItem* Item)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16923);

	UWeaponItem_AttachItem_Params params;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_Thrown
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UCustomEquipableItem::GetOffset_Thrown()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16975);

	UCustomEquipableItem_GetOffset_Thrown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_SideArm
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UCustomEquipableItem::GetOffset_SideArm()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16973);

	UCustomEquipableItem_GetOffset_SideArm_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_Secondary
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UCustomEquipableItem::GetOffset_Secondary()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16971);

	UCustomEquipableItem_GetOffset_Secondary_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_Primary
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UCustomEquipableItem::GetOffset_Primary()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16969);

	UCustomEquipableItem_GetOffset_Primary_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_Melee
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UCustomEquipableItem::GetOffset_Melee()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16967);

	UCustomEquipableItem_GetOffset_Melee_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetItemLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UCustomEquipableItem::GetItemLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16965);

	UCustomEquipableItem_GetItemLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ItemSpawnProcessor.ProcessSpawnItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UItemSpotGroupComponent* Spawner                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UItemSpawnProcessor::ProcessSpawnItem(class UItemSpotGroupComponent* Spawner)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17002);

	UItemSpawnProcessor_ProcessSpawnItem_Params params;
	params.Spawner = Spawner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemSpawnProcessor.ProcessGroup
// (Native, Event, Protected, HasOutParms, BlueprintEvent)
// Parameters:
// class UItemSpotGroupComponent* SpotGroup                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// TArray<class UItemSpotComponent*> Spots                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UItemSpawnProcessor::ProcessGroup(class UItemSpotGroupComponent* SpotGroup, TArray<class UItemSpotComponent*> Spots)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16998);

	UItemSpawnProcessor_ProcessGroup_Params params;
	params.SpotGroup = SpotGroup;
	params.Spots = Spots;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemSpawnProcessor.CheckItemGroup
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UItemSpotGroupComponent* SpotGroup                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UItemSpawnProcessor::CheckItemGroup(class UItemSpotGroupComponent* SpotGroup)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(16995);

	UItemSpawnProcessor_CheckItemGroup_Params params;
	params.SpotGroup = SpotGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ItemStudio.UpdateComponentToWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*          Mesh                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void AItemStudio::UpdateComponentToWorld(class UMeshComponent* Mesh)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17020);

	AItemStudio_UpdateComponentToWorld_Params params;
	params.Mesh = Mesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemStudio.SetTextureRenderTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*  NewTextureTarget               (Parm, ZeroConstructor, IsPlainOldData)

void AItemStudio::SetTextureRenderTarget(class UTextureRenderTarget2D* NewTextureTarget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17018);

	AItemStudio_SetTextureRenderTarget_Params params;
	params.NewTextureTarget = NewTextureTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemStudio.SetItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UItem*                   Item                           (Parm, ZeroConstructor, IsPlainOldData)

void AItemStudio::SetItem(class UItem* Item)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17016);

	AItemStudio_SetItem_Params params;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemStudio.AddYaw
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void AItemStudio::AddYaw(float Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17014);

	AItemStudio_AddYaw_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponStudio.UpdateWeaponMesh
// (Native, Event, Public, BlueprintEvent)

void AWeaponStudio::UpdateWeaponMesh()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17038);

	AWeaponStudio_UpdateWeaponMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponStudio.UpdateSkin
// (Final, Native, Public)

void AWeaponStudio::UpdateSkin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17037);

	AWeaponStudio_UpdateSkin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponStudio.UpdateAttachment
// (Final, Native, Public)

void AWeaponStudio::UpdateAttachment()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17036);

	AWeaponStudio_UpdateAttachment_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponStudio.OnUpdateSkin
// (Event, Public, BlueprintEvent)

void AWeaponStudio::OnUpdateSkin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17035);

	AWeaponStudio_OnUpdateSkin_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponStudio.OnUpdateAttachment
// (Event, Public, BlueprintEvent)

void AWeaponStudio::OnUpdateAttachment()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17034);

	AWeaponStudio_OnUpdateAttachment_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponStudio.GetWeaonMesh
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UMeshComponent*          ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UMeshComponent* AWeaponStudio::GetWeaonMesh()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17032);

	AWeaponStudio_GetWeaonMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponStudio.GetCachedWeaponItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseWeaponItem*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBaseWeaponItem* AWeaponStudio::GetCachedWeaponItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17030);

	AWeaponStudio_GetCachedWeaponItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponStudio.GetCachedTslWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Gun*          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon_Gun* AWeaponStudio::GetCachedTslWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17028);

	AWeaponStudio_GetCachedTslWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ItemToolTipWidget.UpdateVicinityOrInventorySlotItemToolTip
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEquipableItem*          EquipableItem                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEquipableItem*          EquipmentSlotItem              (Parm, ZeroConstructor, IsPlainOldData)

void UItemToolTipWidget::UpdateVicinityOrInventorySlotItemToolTip(class UEquipableItem* EquipableItem, class UEquipableItem* EquipmentSlotItem)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17289);

	UItemToolTipWidget_UpdateVicinityOrInventorySlotItemToolTip_Params params;
	params.EquipableItem = EquipableItem;
	params.EquipmentSlotItem = EquipmentSlotItem;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemToolTipWidget.UpdateToolTipBySlotInterface
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class USlotInterface> SlotInterface                  (Parm, ZeroConstructor, IsPlainOldData)
// TScriptInterface<class USlotContainerInterface> Container                      (Parm, ZeroConstructor, IsPlainOldData)

void UItemToolTipWidget::UpdateToolTipBySlotInterface(const TScriptInterface<class USlotInterface>& SlotInterface, const TScriptInterface<class USlotContainerInterface>& Container)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17286);

	UItemToolTipWidget_UpdateToolTipBySlotInterface_Params params;
	params.SlotInterface = SlotInterface;
	params.Container = Container;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemToolTipWidget.UpdateSlotInfo
// (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
// TScriptInterface<class USlotInterface> SlotInterface                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UItemToolTipWidget::UpdateSlotInfo(const TScriptInterface<class USlotInterface>& SlotInterface)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17284);

	UItemToolTipWidget_UpdateSlotInfo_Params params;
	params.SlotInterface = SlotInterface;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemToolTipWidget.UpdateEquipmentSlotItemToolTip
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEquipableItem*          EquipableItem                  (Parm, ZeroConstructor, IsPlainOldData)

void UItemToolTipWidget::UpdateEquipmentSlotItemToolTip(class UEquipableItem* EquipableItem)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17282);

	UItemToolTipWidget_UpdateEquipmentSlotItemToolTip_Params params;
	params.EquipableItem = EquipableItem;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyWidget.GameStateChanging
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FName                   NewState                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   OldState                       (Parm, ZeroConstructor, IsPlainOldData)

void ULobbyWidget::GameStateChanging(const struct FName& NewState, const struct FName& OldState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17307);

	ULobbyWidget_GameStateChanging_Params params;
	params.NewState = NewState;
	params.OldState = OldState;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MatchPreparer.TimerGameStartCountDown
// (Native, Protected)

void UMatchPreparer::TimerGameStartCountDown()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17310);

	UMatchPreparer_TimerGameStartCountDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.AirborneMatchPreparer.AllowDealDamage
// (Final, Native, Private)

void UAirborneMatchPreparer::AllowDealDamage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17313);

	UAirborneMatchPreparer_AllowDealDamage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ModeController.SendSystemMessageToAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESystemMessageType             MessageType                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Message                        (Parm)
// float                          MessageDuration                (Parm, ZeroConstructor, IsPlainOldData)

void AModeController::SendSystemMessageToAll(ESystemMessageType MessageType, const struct FText& Message, float MessageDuration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17419);

	AModeController_SendSystemMessageToAll_Params params;
	params.MessageType = MessageType;
	params.Message = Message;
	params.MessageDuration = MessageDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ModeController.IsPlayInEditor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AModeController::IsPlayInEditor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17417);

	AModeController_IsPlayInEditor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ModeController.HandleServerAdminBlueprint
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FString                 AdminCommand                   (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AModeController::HandleServerAdminBlueprint(const struct FString& AdminCommand)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17414);

	AModeController_HandleServerAdminBlueprint_Params params;
	params.AdminCommand = AdminCommand;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ModeController.GetGameState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslGameState*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslGameState* AModeController::GetGameState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17412);

	AModeController_GetGameState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ModeController.GetGameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslGameMode*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslGameMode* AModeController::GetGameMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17410);

	AModeController_GetGameMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ModeController.CanDealDamage
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ATslPlayerState*         DamageInstigator               (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class ATslPlayerState*         DamagedPlayer                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AModeController::CanDealDamage(class ATslPlayerState* DamageInstigator, class ATslPlayerState* DamagedPlayer)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17406);

	AModeController_CanDealDamage_Params params;
	params.DamageInstigator = DamageInstigator;
	params.DamagedPlayer = DamagedPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.BattleRoyaleModeController.UpdateGamePhase
// (Final, Native, Public, BlueprintCallable)

void ABattleRoyaleModeController::UpdateGamePhase()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17436);

	ABattleRoyaleModeController_UpdateGamePhase_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.BattleRoyaleModeController.SetNextGasInBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ABattleRoyaleModeController::SetNextGasInBlackboard()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17434);

	ABattleRoyaleModeController_SetNextGasInBlackboard_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.BattleRoyaleModeController.LastCircleAlgorithm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ABattleRoyaleModeController::LastCircleAlgorithm()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17432);

	ABattleRoyaleModeController_LastCircleAlgorithm_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.BattleRoyaleModeController.InitRadius
// (Final, Native, Public, BlueprintCallable)

void ABattleRoyaleModeController::InitRadius()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17431);

	ABattleRoyaleModeController_InitRadius_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.BattleRoyaleModeController.GetPoisonGasDamagePerSecond
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          CharaterToCenterDistance       (Parm, ZeroConstructor, IsPlainOldData)
// float                          SafetyZoneRadius               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PoisonGasWarningRadius         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ABattleRoyaleModeController::GetPoisonGasDamagePerSecond(float CharaterToCenterDistance, float SafetyZoneRadius, float PoisonGasWarningRadius)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17426);

	ABattleRoyaleModeController_GetPoisonGasDamagePerSecond_Params params;
	params.CharaterToCenterDistance = CharaterToCenterDistance;
	params.SafetyZoneRadius = SafetyZoneRadius;
	params.PoisonGasWarningRadius = PoisonGasWarningRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.BattleRoyaleModeController.GetMaxPhaseCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ABattleRoyaleModeController::GetMaxPhaseCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17424);

	ABattleRoyaleModeController_GetMaxPhaseCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CarePackageController.SpawnAircraftCarePackageCustom
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 DropLocation                   (Parm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ACarePackageController::SpawnAircraftCarePackageCustom(const struct FVector& DropLocation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17463);

	ACarePackageController_SpawnAircraftCarePackageCustom_Params params;
	params.DropLocation = DropLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CarePackageController.SpawnAircraftCarePackage
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                           CopyIntersectionInfo           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ACarePackageController::SpawnAircraftCarePackage(bool CopyIntersectionInfo)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17460);

	ACarePackageController_SpawnAircraftCarePackage_Params params;
	params.CopyIntersectionInfo = CopyIntersectionInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CarePackageController.SetNextCarePackageInBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ACarePackageController::SetNextCarePackageInBlackboard()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17458);

	ACarePackageController_SetNextCarePackageInBlackboard_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CarePackageController.InitCarePackageSetting
// (Final, Native, Public, BlueprintCallable)

void ACarePackageController::InitCarePackageSetting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17457);

	ACarePackageController_InitCarePackageSetting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CarePackageController.GetSpawnInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ACarePackageController::GetSpawnInterval()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17455);

	ACarePackageController_GetSpawnInterval_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.RedZoneController.SpawnBombProjectile
// (Final, Native, Public, BlueprintCallable)

void ARedZoneController::SpawnBombProjectile()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17486);

	ARedZoneController_SpawnBombProjectile_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.RedZoneController.SetNextRedZoneInBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ARedZoneController::SetNextRedZoneInBlackboard()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17484);

	ARedZoneController_SetNextRedZoneInBlackboard_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.RedZoneController.OnBombingStart
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 RedZonePosition                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void ARedZoneController::OnBombingStart(const struct FVector& RedZonePosition)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17482);

	ARedZoneController_OnBombingStart_Params params;
	params.RedZonePosition = RedZonePosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.RedZoneController.InitRedZoneSetting
// (Final, Native, Public, BlueprintCallable)

void ARedZoneController::InitRedZoneSetting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17481);

	ARedZoneController_InitRedZoneSetting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.RedZoneController.GetRandomBombingInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ARedZoneController::GetRandomBombingInterval()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17479);

	ARedZoneController_GetRandomBombingInterval_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MutableCharacter.UpdateAppearence
// (Final, Native, Public, BlueprintCallable)

void AMutableCharacter::UpdateAppearence()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17798);

	AMutableCharacter_UpdateAppearence_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MutableCharacter.OnRep_InstanceDescriptor
// (Final, Native, Protected)

void AMutableCharacter::OnRep_InstanceDescriptor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17797);

	AMutableCharacter_OnRep_InstanceDescriptor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MutableCharacter.GetGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGender                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EGender AMutableCharacter::GetGender()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17794);

	AMutableCharacter_GetGender_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyCharacter.IsInCustomizationScene
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ALobbyCharacter::IsInCustomizationScene()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17811);

	ALobbyCharacter_IsInCustomizationScene_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyCharacter.GetSlotId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ALobbyCharacter::GetSlotId()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17809);

	ALobbyCharacter_GetSlotId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyCharacter.GetNickName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ALobbyCharacter::GetNickName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17807);

	ALobbyCharacter_GetNickName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyCharacter.GetNetId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ALobbyCharacter::GetNetId()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17805);

	ALobbyCharacter_GetNetId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVaultingHelper.GetActorAttachScene
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslVaultingHelper::GetActorAttachScene()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17824);

	ATslVaultingHelper_GetActorAttachScene_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.WeaponCycleDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon_Gun::WeaponCycleDone()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17987);

	ATslWeapon_Gun_WeaponCycleDone_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.StopReloadAnimByOne
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ATslWeapon_Gun::StopReloadAnimByOne()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17986);

	ATslWeapon_Gun_StopReloadAnimByOne_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.StartManualFireCycle
// (Final, Native, Protected)

void ATslWeapon_Gun::StartManualFireCycle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17985);

	ATslWeapon_Gun_StartManualFireCycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.SimulateWeaponReload
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// EWeaponReloadAnimExec          ReloadAnimExec                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void ATslWeapon_Gun::SimulateWeaponReload(EWeaponReloadAnimExec ReloadAnimExec)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17982);

	ATslWeapon_Gun_SimulateWeaponReload_Params params;
	params.ReloadAnimExec = ReloadAnimExec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.SetWeaponReloadInterrupted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bIsInterrupted                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Gun::SetWeaponReloadInterrupted(bool bIsInterrupted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17980);

	ATslWeapon_Gun_SetWeaponReloadInterrupted_Params params;
	params.bIsInterrupted = bIsInterrupted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.SetSpawnBulletFromBarrel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           DoSpawnBulletFromBarrel        (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Gun::SetSpawnBulletFromBarrel(bool DoSpawnBulletFromBarrel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17978);

	ATslWeapon_Gun_SetSpawnBulletFromBarrel_Params params;
	params.DoSpawnBulletFromBarrel = DoSpawnBulletFromBarrel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.SetFiringMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFiringMode                    FiringMode                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Gun::SetFiringMode(EFiringMode FiringMode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17975);

	ATslWeapon_Gun_SetFiringMode_Params params;
	params.FiringMode = FiringMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ServerStopReload
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::ServerStopReload()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17974);

	ATslWeapon_Gun_ServerStopReload_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ServerStopFire
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::ServerStopFire()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17973);

	ATslWeapon_Gun_ServerStopFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ServerStartReload
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::ServerStartReload()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17972);

	ATslWeapon_Gun_ServerStartReload_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ServerStartFire
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::ServerStartFire()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17971);

	ATslWeapon_Gun_ServerStartFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ServerSetHip
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           bNewIsHipped                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Gun::ServerSetHip(bool bNewIsHipped)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17969);

	ATslWeapon_Gun_ServerSetHip_Params params;
	params.bNewIsHipped = bNewIsHipped;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ServerSetCurrentZeroLevel
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// int                            ZeroLevel                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Gun::ServerSetCurrentZeroLevel(int ZeroLevel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17967);

	ATslWeapon_Gun_ServerSetCurrentZeroLevel_Params params;
	params.ZeroLevel = ZeroLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ServerHandleFiring
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FHitResult              ExceptTrajectoryHitResult      (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslWeapon_Gun::ServerHandleFiring(const struct FHitResult& ExceptTrajectoryHitResult)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17965);

	ATslWeapon_Gun_ServerHandleFiring_Params params;
	params.ExceptTrajectoryHitResult = ExceptTrajectoryHitResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ServerCancelReload
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslWeapon_Gun::ServerCancelReload()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17964);

	ATslWeapon_Gun_ServerCancelReload_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.Server_StartManualFireCycle
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::Server_StartManualFireCycle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17963);

	ATslWeapon_Gun_Server_StartManualFireCycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ProcessBoltAction
// (Final, Native, Protected)

void ATslWeapon_Gun::ProcessBoltAction()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17962);

	ATslWeapon_Gun_ProcessBoltAction_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.PlayWeaponCycleCameraAnim
// (Final, Native, Protected)

void ATslWeapon_Gun::PlayWeaponCycleCameraAnim()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17961);

	ATslWeapon_Gun_PlayWeaponCycleCameraAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.PlayLongTailSound
// (Final, Native, Protected)

void ATslWeapon_Gun::PlayLongTailSound()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17960);

	ATslWeapon_Gun_PlayLongTailSound_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.OnRep_MyPawn
// (Native, Protected)

void ATslWeapon_Gun::OnRep_MyPawn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17959);

	ATslWeapon_Gun_OnRep_MyPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.OnRep_FiringModeIndex
// (Final, Native, Public)

void ATslWeapon_Gun::OnRep_FiringModeIndex()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17958);

	ATslWeapon_Gun_OnRep_FiringModeIndex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.OnRep_CurrentZeroLevel
// (Final, Native, Protected)
// Parameters:
// int                            LastCurrentZeroLevel           (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Gun::OnRep_CurrentZeroLevel(int LastCurrentZeroLevel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17956);

	ATslWeapon_Gun_OnRep_CurrentZeroLevel_Params params;
	params.LastCurrentZeroLevel = LastCurrentZeroLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.OnRep_AttachedItemClasses
// (Native, Protected, HasOutParms)
// Parameters:
// TArray<class UClass*>          OldVal                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void ATslWeapon_Gun::OnRep_AttachedItemClasses(TArray<class UClass*> OldVal)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17953);

	ATslWeapon_Gun_OnRep_AttachedItemClasses_Params params;
	params.OldVal = OldVal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.OnRep_AmmoCount
// (Final, Native, Protected)
// Parameters:
// int                            LastCurrentAmmoInClip          (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Gun::OnRep_AmmoCount(int LastCurrentAmmoInClip)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17951);

	ATslWeapon_Gun_OnRep_AmmoCount_Params params;
	params.LastCurrentAmmoInClip = LastCurrentAmmoInClip;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.OnInventoryUpdated
// (Final, Native, Protected)

void ATslWeapon_Gun::OnInventoryUpdated()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17950);

	ATslWeapon_Gun_OnInventoryUpdated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.OnAttachmentScopeLoaded
// (Final, Native, Protected)

void ATslWeapon_Gun::OnAttachmentScopeLoaded()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17949);

	ATslWeapon_Gun_OnAttachmentScopeLoaded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.OnAnimationNotify
// (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*  MeshComp                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   NotifyName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void ATslWeapon_Gun::OnAnimationNotify(class USkeletalMeshComponent* MeshComp, const struct FName& NotifyName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17946);

	ATslWeapon_Gun_OnAnimationNotify_Params params;
	params.MeshComp = MeshComp;
	params.NotifyName = NotifyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ManualFireCycleFinished
// (Final, Native, Protected)

void ATslWeapon_Gun::ManualFireCycleFinished()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17945);

	ATslWeapon_Gun_ManualFireCycleFinished_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.IsWeaponCycleInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon_Gun::IsWeaponCycleInProgress()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17943);

	ATslWeapon_Gun_IsWeaponCycleInProgress_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.IsWeaponCycleAnimActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon_Gun::IsWeaponCycleAnimActive()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17941);

	ATslWeapon_Gun_IsWeaponCycleAnimActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.IsReloadInterrupted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon_Gun::IsReloadInterrupted()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17939);

	ATslWeapon_Gun_IsReloadInterrupted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.IsReloading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon_Gun::IsReloading()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17937);

	ATslWeapon_Gun_IsReloading_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponTacticalReload
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetWeaponTacticalReload()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17935);

	ATslWeapon_Gun_GetWeaponTacticalReload_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponPostprocessSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWeaponPPSettings       ReturnValue                    (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm)

struct FWeaponPPSettings ATslWeapon_Gun::GetWeaponPostprocessSettings()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17933);

	ATslWeapon_Gun_GetWeaponPostprocessSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponOrScopePostprocessSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWeaponPPSettings       ReturnValue                    (Parm, OutParm, ReturnParm)

struct FWeaponPPSettings ATslWeapon_Gun::GetWeaponOrScopePostprocessSettings()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17931);

	ATslWeapon_Gun_GetWeaponOrScopePostprocessSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponHandOffsetFPP
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslWeapon_Gun::GetWeaponHandOffsetFPP()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17929);

	ATslWeapon_Gun_GetWeaponHandOffsetFPP_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponHandOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslWeapon_Gun::GetWeaponHandOffset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17927);

	ATslWeapon_Gun_GetWeaponHandOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponGunConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWeaponGunData          ReturnValue                    (Parm, OutParm, ReturnParm)

struct FWeaponGunData ATslWeapon_Gun::GetWeaponGunConfig()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17925);

	ATslWeapon_Gun_GetWeaponGunConfig_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponGunAnimConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWeaponGunAnim          ReturnValue                    (Parm, OutParm, ReturnParm)

struct FWeaponGunAnim ATslWeapon_Gun::GetWeaponGunAnimConfig()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17923);

	ATslWeapon_Gun_GetWeaponGunAnimConfig_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponFullReloadTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetWeaponFullReloadTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17921);

	ATslWeapon_Gun_GetWeaponFullReloadTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponFullRealoadTimeWithAttachments
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetWeaponFullRealoadTimeWithAttachments()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17919);

	ATslWeapon_Gun_GetWeaponFullRealoadTimeWithAttachments_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponCurrentRecoilValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetWeaponCurrentRecoilValue()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17917);

	ATslWeapon_Gun_GetWeaponCurrentRecoilValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponCurrentDeviationValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetWeaponCurrentDeviationValue()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17915);

	ATslWeapon_Gun_GetWeaponCurrentDeviationValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponChargeReload
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetWeaponChargeReload()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17913);

	ATslWeapon_Gun_GetWeaponChargeReload_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetReloadAnimationPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetReloadAnimationPlayRate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17911);

	ATslWeapon_Gun_GetReloadAnimationPlayRate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetRecoilADSSocketOffsetScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslWeapon_Gun::GetRecoilADSSocketOffsetScale()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17909);

	ATslWeapon_Gun_GetRecoilADSSocketOffsetScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetNumOfFiringMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslWeapon_Gun::GetNumOfFiringMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17907);

	ATslWeapon_Gun_GetNumOfFiringMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMovementModifierScope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetMovementModifierScope()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17905);

	ATslWeapon_Gun_GetMovementModifierScope_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMovementModifierAim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetMovementModifierAim()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17903);

	ATslWeapon_Gun_GetMovementModifierAim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMaxAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslWeapon_Gun::GetMaxAmmo()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17901);

	ATslWeapon_Gun_GetMaxAmmo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMagOutDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetMagOutDuration()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17899);

	ATslWeapon_Gun_GetMagOutDuration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMagDropLinearVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslWeapon_Gun::GetMagDropLinearVelocity()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17897);

	ATslWeapon_Gun_GetMagDropLinearVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMagDropAngularVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslWeapon_Gun::GetMagDropAngularVelocity()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17895);

	ATslWeapon_Gun_GetMagDropAngularVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetGripTypeIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslWeapon_Gun::GetGripTypeIndex()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17893);

	ATslWeapon_Gun_GetGripTypeIndex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetFiringMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFiringMode                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EFiringMode ATslWeapon_Gun::GetFiringMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17890);

	ATslWeapon_Gun_GetFiringMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetDefaultAmmoObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAmmoItem*               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAmmoItem* ATslWeapon_Gun::GetDefaultAmmoObject()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17888);

	ATslWeapon_Gun_GetDefaultAmmoObject_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCurrentDeviation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetCurrentDeviation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17886);

	ATslWeapon_Gun_GetCurrentDeviation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCurrentAmmoInInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslWeapon_Gun::GetCurrentAmmoInInventory()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17884);

	ATslWeapon_Gun_GetCurrentAmmoInInventory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCurrentAmmoInClip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslWeapon_Gun::GetCurrentAmmoInClip()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17882);

	ATslWeapon_Gun_GetCurrentAmmoInClip_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCurrentAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslWeapon_Gun::GetCurrentAmmo()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17880);

	ATslWeapon_Gun_GetCurrentAmmo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterTacticalReloadFromAttach
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterTacticalReloadFromAttach()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17878);

	ATslWeapon_Gun_GetCharacterTacticalReloadFromAttach_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadTacticalMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadTacticalMontage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17876);

	ATslWeapon_Gun_GetCharacterReloadTacticalMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadChargeMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadChargeMontage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17874);

	ATslWeapon_Gun_GetCharacterReloadChargeMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadByOneStopMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadByOneStopMontage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17872);

	ATslWeapon_Gun_GetCharacterReloadByOneStopMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadByOneStartMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadByOneStartMontage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17870);

	ATslWeapon_Gun_GetCharacterReloadByOneStartMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadByOneSingleMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadByOneSingleMontage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17868);

	ATslWeapon_Gun_GetCharacterReloadByOneSingleMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterLHGripBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpaceBase* ATslWeapon_Gun::GetCharacterLHGripBlendspace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17866);

	ATslWeapon_Gun_GetCharacterLHGripBlendspace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterGripBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpace1D*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpace1D* ATslWeapon_Gun::GetCharacterGripBlendspace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17864);

	ATslWeapon_Gun_GetCharacterGripBlendspace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterFireSelectorMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterFireSelectorMontage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17862);

	ATslWeapon_Gun_GetCharacterFireSelectorMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterFireMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterFireMontage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17860);

	ATslWeapon_Gun_GetCharacterFireMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterFireCycle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterFireCycle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17858);

	ATslWeapon_Gun_GetCharacterFireCycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterChargeReloadFromAttach
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* ATslWeapon_Gun::GetCharacterChargeReloadFromAttach()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17856);

	ATslWeapon_Gun_GetCharacterChargeReloadFromAttach_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetAmmoPerClip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslWeapon_Gun::GetAmmoPerClip()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17854);

	ATslWeapon_Gun_GetAmmoPerClip_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetAmmoItemClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* ATslWeapon_Gun::GetAmmoItemClass()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17852);

	ATslWeapon_Gun_GetAmmoItemClass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetADSRecoilKick
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Gun::GetADSRecoilKick()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17850);

	ATslWeapon_Gun_GetADSRecoilKick_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.ClientStopSimulatingWeaponFire
// (Net, Native, Event, NetMulticast, Protected)

void ATslWeapon_Gun::ClientStopSimulatingWeaponFire()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17849);

	ATslWeapon_Gun_ClientStopSimulatingWeaponFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ClientSimulateWeaponFire
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FHitResult              ExceptTrajectoryHitResult      (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslWeapon_Gun::ClientSimulateWeaponFire(const struct FHitResult& ExceptTrajectoryHitResult)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17847);

	ATslWeapon_Gun_ClientSimulateWeaponFire_Params params;
	params.ExceptTrajectoryHitResult = ExceptTrajectoryHitResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ClientSetFiringMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EFiringMode                    FiringMode                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Gun::ClientSetFiringMode(EFiringMode FiringMode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17844);

	ATslWeapon_Gun_ClientSetFiringMode_Params params;
	params.FiringMode = FiringMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ClientNotifyStopReloadByOne
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ATslWeapon_Gun::ClientNotifyStopReloadByOne()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17843);

	ATslWeapon_Gun_ClientNotifyStopReloadByOne_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ClientNotifyOutOfAmmo
// (Net, NetReliable, Native, Event, NetMulticast, Protected, NetClient, NetValidate)

void ATslWeapon_Gun::ClientNotifyOutOfAmmo()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17842);

	ATslWeapon_Gun_ClientNotifyOutOfAmmo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ClientNotifyAmmo
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int                            InCurrentAmmoInClip            (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Gun::ClientNotifyAmmo(int InCurrentAmmoInClip)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17840);

	ATslWeapon_Gun_ClientNotifyAmmo_Params params;
	params.InCurrentAmmoInClip = InCurrentAmmoInClip;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.ClientCancelReload
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ATslWeapon_Gun::ClientCancelReload()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17839);

	ATslWeapon_Gun_ClientCancelReload_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.Client_StartManualFireCycle
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ATslWeapon_Gun::Client_StartManualFireCycle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17838);

	ATslWeapon_Gun_Client_StartManualFireCycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.CheckMiddlePointCollision
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon_Gun::CheckMiddlePointCollision()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17836);

	ATslWeapon_Gun_CheckMiddlePointCollision_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.CancelReloadImpl
// (Final, Native, Public)

void ATslWeapon_Gun::CancelReloadImpl()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17835);

	ATslWeapon_Gun_CancelReloadImpl_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.BroadcastOutOfAmmo
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::BroadcastOutOfAmmo()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17834);

	ATslWeapon_Gun_BroadcastOutOfAmmo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.AnimCall_ToggleFireMode
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_ToggleFireMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17833);

	ATslWeapon_Gun_AnimCall_ToggleFireMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.AnimCall_ReloadTacticalWeapon
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_ReloadTacticalWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17832);

	ATslWeapon_Gun_AnimCall_ReloadTacticalWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.AnimCall_ReloadChargeWeapon
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_ReloadChargeWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17831);

	ATslWeapon_Gun_AnimCall_ReloadChargeWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.AnimCall_ReloadByOneStop
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_ReloadByOneStop()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17830);

	ATslWeapon_Gun_AnimCall_ReloadByOneStop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.AnimCall_FireWeaponCycle
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_FireWeaponCycle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17829);

	ATslWeapon_Gun_AnimCall_FireWeaponCycle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun.AnimCall_FireWeapon
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_FireWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(17828);

	ATslWeapon_Gun_AnimCall_FireWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VehicleSeatActor.OnRep_Rider
// (Final, Native, Private)

void AVehicleSeatActor::OnRep_Rider()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18046);

	AVehicleSeatActor_OnRep_Rider_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VehicleSeatActor.IsWeaponClassAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponClass                   InClass                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AVehicleSeatActor::IsWeaponClassAllowed(EWeaponClass InClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18042);

	AVehicleSeatActor_IsWeaponClassAllowed_Params params;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.IsEntryAllowedByVelocity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AVehicleSeatActor::IsEntryAllowedByVelocity()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18040);

	AVehicleSeatActor_IsEntryAllowedByVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetVehicleSeatComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslVehicleSeatComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslVehicleSeatComponent* AVehicleSeatActor::GetVehicleSeatComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18038);

	AVehicleSeatActor_GetVehicleSeatComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetVehiclePawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class APawn* AVehicleSeatActor::GetVehiclePawn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18036);

	AVehicleSeatActor_GetVehiclePawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetVehicleInterface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class UTslVehicleInterface> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TScriptInterface<class UTslVehicleInterface> AVehicleSeatActor::GetVehicleInterface()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18034);

	AVehicleSeatActor_GetVehicleInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetVehicleAnimType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVehicleAnimType               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EVehicleAnimType AVehicleSeatActor::GetVehicleAnimType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18031);

	AVehicleSeatActor_GetVehicleAnimType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetTransitionOutBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpaceBase* AVehicleSeatActor::GetTransitionOutBlendspace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18029);

	AVehicleSeatActor_GetTransitionOutBlendspace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetTransitionInBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpaceBase* AVehicleSeatActor::GetTransitionInBlendspace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18027);

	AVehicleSeatActor_GetTransitionInBlendspace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetSeatIdleAO
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAimOffsetBlendSpace*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAimOffsetBlendSpace* AVehicleSeatActor::GetSeatIdleAO()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18025);

	AVehicleSeatActor_GetSeatIdleAO_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetSeatIdleAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimSequenceBase* AVehicleSeatActor::GetSeatIdleAnimation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18023);

	AVehicleSeatActor_GetSeatIdleAnimation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetSeatAimingBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpaceBase* AVehicleSeatActor::GetSeatAimingBlendspace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18021);

	AVehicleSeatActor_GetSeatAimingBlendspace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetRider
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* AVehicleSeatActor::GetRider()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18019);

	AVehicleSeatActor_GetRider_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetMinPitchByYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          CurrentYaw                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AVehicleSeatActor::GetMinPitchByYaw(float CurrentYaw)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18016);

	AVehicleSeatActor_GetMinPitchByYaw_Params params;
	params.CurrentYaw = CurrentYaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetMaxPitchByYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          CurrentYaw                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AVehicleSeatActor::GetMaxPitchByYaw(float CurrentYaw)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18013);

	AVehicleSeatActor_GetMaxPitchByYaw_Params params;
	params.CurrentYaw = CurrentYaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetCanFireOnlyWhileAimed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AVehicleSeatActor::GetCanFireOnlyWhileAimed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18011);

	AVehicleSeatActor_GetCanFireOnlyWhileAimed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetAdditionalMessage
// (Final, Native, Public)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText AVehicleSeatActor::GetAdditionalMessage(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18008);

	AVehicleSeatActor_GetAdditionalMessage_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatActor.AllowInteract
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AVehicleSeatActor::AllowInteract(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18005);

	AVehicleSeatActor_AllowInteract_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.SimulateUnArmWeapon
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int                            WeaponIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNeedAnimation                 (Parm, ZeroConstructor, IsPlainOldData)

void AWeaponProcessor::SimulateUnArmWeapon(int WeaponIndex, bool bNeedAnimation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18112);

	AWeaponProcessor_SimulateUnArmWeapon_Params params;
	params.WeaponIndex = WeaponIndex;
	params.bNeedAnimation = bNeedAnimation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponProcessor.SimulateArmWeapon
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int                            WeaponIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNeedAnimation                 (Parm, ZeroConstructor, IsPlainOldData)

void AWeaponProcessor::SimulateArmWeapon(int WeaponIndex, bool bNeedAnimation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18109);

	AWeaponProcessor_SimulateArmWeapon_Params params;
	params.WeaponIndex = WeaponIndex;
	params.bNeedAnimation = bNeedAnimation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponProcessor.ServerUnarmCurrentWeapon
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           bNeedAnimation                 (Parm, ZeroConstructor, IsPlainOldData)

void AWeaponProcessor::ServerUnarmCurrentWeapon(bool bNeedAnimation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18107);

	AWeaponProcessor_ServerUnarmCurrentWeapon_Params params;
	params.bNeedAnimation = bNeedAnimation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponProcessor.ServerArmWeapon
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// int                            WeaponIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNeedAnimation                 (Parm, ZeroConstructor, IsPlainOldData)

void AWeaponProcessor::ServerArmWeapon(int WeaponIndex, bool bNeedAnimation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18104);

	AWeaponProcessor_ServerArmWeapon_Params params;
	params.WeaponIndex = WeaponIndex;
	params.bNeedAnimation = bNeedAnimation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponProcessor.OnRep_EquippedWeapons
// (Final, Native, Protected)
// Parameters:
// TArray<class ATslWeapon*>      LastEquippedWeapons            (Parm, ZeroConstructor)

void AWeaponProcessor::OnRep_EquippedWeapons(TArray<class ATslWeapon*> LastEquippedWeapons)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18101);

	AWeaponProcessor_OnRep_EquippedWeapons_Params params;
	params.LastEquippedWeapons = LastEquippedWeapons;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponProcessor.OnRep_CurrentWeaponIndex
// (Final, Native, Protected)

void AWeaponProcessor::OnRep_CurrentWeaponIndex()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18100);

	AWeaponProcessor_OnRep_CurrentWeaponIndex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponProcessor.NotifyWeaponUpdate
// (Final, Native, Private)

void AWeaponProcessor::NotifyWeaponUpdate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18099);

	AWeaponProcessor_NotifyWeaponUpdate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponProcessor.IsUnarmedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            WeaponIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AWeaponProcessor::IsUnarmedWeapon(int WeaponIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18096);

	AWeaponProcessor_IsUnarmedWeapon_Params params;
	params.WeaponIndex = WeaponIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.IsUnarmed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AWeaponProcessor::IsUnarmed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18094);

	AWeaponProcessor_IsUnarmed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeaponThrowable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Throwable*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon_Throwable* AWeaponProcessor::GetWeaponThrowable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18092);

	AWeaponProcessor_GetWeaponThrowable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeaponProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Gun_Projectile* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon_Gun_Projectile* AWeaponProcessor::GetWeaponProjectile()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18090);

	AWeaponProcessor_GetWeaponProjectile_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AWeaponProcessor::GetWeaponIndex()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18088);

	AWeaponProcessor_GetWeaponIndex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeaponGun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Gun*          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon_Gun* AWeaponProcessor::GetWeaponGun()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18086);

	AWeaponProcessor_GetWeaponGun_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeaponByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* AWeaponProcessor::GetWeaponByIndex(int Index)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18083);

	AWeaponProcessor_GetWeaponByIndex_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* AWeaponProcessor::GetWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18081);

	AWeaponProcessor_GetWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetUnarmedWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AWeaponProcessor::GetUnarmedWeaponIndex()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18079);

	AWeaponProcessor_GetUnarmedWeaponIndex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetCurrentWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* AWeaponProcessor::GetCurrentWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18077);

	AWeaponProcessor_GetCurrentWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.FindWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  WeaponClass                    (Parm, ZeroConstructor, IsPlainOldData)
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* AWeaponProcessor::FindWeapon(class UClass* WeaponClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18074);

	AWeaponProcessor_FindWeapon_Params params;
	params.WeaponClass = WeaponClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponProcessor.ClientSetWeaponIndex
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int                            WeaponIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void AWeaponProcessor::ClientSetWeaponIndex(int WeaponIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18072);

	AWeaponProcessor_ClientSetWeaponIndex_Params params;
	params.WeaponIndex = WeaponIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponProcessor.ClientInitByReconnection
// (Net, NetReliable, Native, Event, Protected, NetClient, NetValidate)
// Parameters:
// int                            InitWeaponIndex                (Parm, ZeroConstructor, IsPlainOldData)

void AWeaponProcessor::ClientInitByReconnection(int InitWeaponIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18070);

	AWeaponProcessor_ClientInitByReconnection_Params params;
	params.InitWeaponIndex = InitWeaponIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponProcessor.ClientForceRemoveWeapon
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int                            WeaponIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void AWeaponProcessor::ClientForceRemoveWeapon(int WeaponIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18068);

	AWeaponProcessor_ClientForceRemoveWeapon_Params params;
	params.WeaponIndex = WeaponIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VaultingData.GetVaultAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           bHasRifle                      (Parm, ZeroConstructor, IsPlainOldData)
// class UAnimSequenceBase*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimSequenceBase* UVaultingData::GetVaultAnimation(bool bHasRifle)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18126);

	UVaultingData_GetVaultAnimation_Params params;
	params.bHasRifle = bHasRifle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VaultingData.GetBlendSpeedByDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InDistance                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UVaultingData::GetBlendSpeedByDistance(float InDistance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18123);

	UVaultingData_GetBlendSpeedByDistance_Params params;
	params.InDistance = InDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VaultingData.GetAnimationLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UVaultingData::GetAnimationLength()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18121);

	UVaultingData_GetAnimationLength_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VaultingData.GetAnimationCurve
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCurveFloat*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UCurveFloat* UVaultingData::GetAnimationCurve()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18119);

	UVaultingData_GetAnimationCurve_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslEmoteComponent.Server_EmotePlay
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FName                   EmoteName                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsRNG                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   SectionName                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslEmoteComponent::Server_EmotePlay(const struct FName& EmoteName, bool bIsRNG, const struct FName& SectionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18209);

	UTslEmoteComponent_Server_EmotePlay_Params params;
	params.EmoteName = EmoteName;
	params.bIsRNG = bIsRNG;
	params.SectionName = SectionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEmoteComponent.SendSystemMessageEmoteUnavailable
// (Final, Native, Public, BlueprintCallable, Const)

void UTslEmoteComponent::SendSystemMessageEmoteUnavailable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18208);

	UTslEmoteComponent_SendSystemMessageEmoteUnavailable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEmoteComponent.SendSystemMessageEmoteBlocked
// (Final, Native, Public, BlueprintCallable, Const)

void UTslEmoteComponent::SendSystemMessageEmoteBlocked()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18207);

	UTslEmoteComponent_SendSystemMessageEmoteBlocked_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEmoteComponent.GetEmoteTextureByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FName                   EmoteName                      (Parm, ZeroConstructor, IsPlainOldData)
// class UTexture2D*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture2D* UTslEmoteComponent::GetEmoteTextureByName(const struct FName& EmoteName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18204);

	UTslEmoteComponent_GetEmoteTextureByName_Params params;
	params.EmoteName = EmoteName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslEmoteComponent.GetEmoteNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FName>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FName> UTslEmoteComponent::GetEmoteNames()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18201);

	UTslEmoteComponent_GetEmoteNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslEmoteComponent.GetEmoteMontageByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FName                   EmoteName                      (Parm, ZeroConstructor, IsPlainOldData)
// class UAnimMontage*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimMontage* UTslEmoteComponent::GetEmoteMontageByName(const struct FName& EmoteName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18198);

	UTslEmoteComponent_GetEmoteMontageByName_Params params;
	params.EmoteName = EmoteName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslEmoteComponent.GetEmoteMaterialByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FName                   EmoteName                      (Parm, ZeroConstructor, IsPlainOldData)
// class UMaterialInterface*      ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UMaterialInterface* UTslEmoteComponent::GetEmoteMaterialByName(const struct FName& EmoteName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18195);

	UTslEmoteComponent_GetEmoteMaterialByName_Params params;
	params.EmoteName = EmoteName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslEmoteComponent.GetEmoteLocalizedName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FName                   EmoteName                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UTslEmoteComponent::GetEmoteLocalizedName(const struct FName& EmoteName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18192);

	UTslEmoteComponent_GetEmoteLocalizedName_Params params;
	params.EmoteName = EmoteName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslEmoteComponent.GetEmoteDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UDataTable* UTslEmoteComponent::GetEmoteDataTable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18190);

	UTslEmoteComponent_GetEmoteDataTable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslEmoteComponent.Emote_TryToPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   EmoteName                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsLobby                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslEmoteComponent::Emote_TryToPlay(const struct FName& EmoteName, bool bIsLobby)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18187);

	UTslEmoteComponent_Emote_TryToPlay_Params params;
	params.EmoteName = EmoteName;
	params.bIsLobby = bIsLobby;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEmoteComponent.Client_EmotePlay
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FName                   EmoteName                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsRNG                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   SectionName                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslEmoteComponent::Client_EmotePlay(const struct FName& EmoteName, bool bIsRNG, const struct FName& SectionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18183);

	UTslEmoteComponent_Client_EmotePlay_Params params;
	params.EmoteName = EmoteName;
	params.bIsRNG = bIsRNG;
	params.SectionName = SectionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEmoteComponent.CanOpenEmoteWheel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslEmoteComponent::CanOpenEmoteWheel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18181);

	UTslEmoteComponent_CanOpenEmoteWheel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.UpdateWeaponAttachPoint
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::UpdateWeaponAttachPoint()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19019);

	ATslCharacter_UpdateWeaponAttachPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.UnBindCallbackToHUD
// (Final, Native, Public)
// Parameters:
// class ATslPlayerController*    InController                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::UnBindCallbackToHUD(class ATslPlayerController* InController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19017);

	ATslCharacter_UnBindCallbackToHUD_Params params;
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.TryClearWeaponSkin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::TryClearWeaponSkin(int SlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19015);

	ATslCharacter_TryClearWeaponSkin_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.TryApplyWeaponSkin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::TryApplyWeaponSkin(int SlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19013);

	ATslCharacter_TryApplyWeaponSkin_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ToggleInvincibility
// (Event, Public, BlueprintEvent)

void ATslCharacter::ToggleInvincibility()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19012);

	ATslCharacter_ToggleInvincibility_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ToggleFreeMode
// (Event, Public, BlueprintEvent)

void ATslCharacter::ToggleFreeMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19011);

	ATslCharacter_ToggleFreeMode_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ToggleAnimDynamics
// (Final, Exec, Native, Public)

void ATslCharacter::ToggleAnimDynamics()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19010);

	ATslCharacter_ToggleAnimDynamics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.TickOptimization_ShouldRunMovementUpdate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::TickOptimization_ShouldRunMovementUpdate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19008);

	ATslCharacter_TickOptimization_ShouldRunMovementUpdate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.TickOptimization_ShouldRunAnimUpdate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::TickOptimization_ShouldRunAnimUpdate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19006);

	ATslCharacter_TickOptimization_ShouldRunAnimUpdate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.TickOptimization_IsOverMinimumDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::TickOptimization_IsOverMinimumDistance()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19004);

	ATslCharacter_TickOptimization_IsOverMinimumDistance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.TickOptimization_Eval
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::TickOptimization_Eval()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19003);

	ATslCharacter_TickOptimization_Eval_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.TestWeaponSkinApplyByItemReference
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 Reference                      (Parm, ZeroConstructor)

void ATslCharacter::TestWeaponSkinApplyByItemReference(const struct FString& Reference)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19001);

	ATslCharacter_TestWeaponSkinApplyByItemReference_Params params;
	params.Reference = Reference;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.TestSkinLoad
// (Final, Exec, Native, Public)

void ATslCharacter::TestSkinLoad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19000);

	ATslCharacter_TestSkinLoad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.StopAllAnimMontages
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::StopAllAnimMontages()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18999);

	ATslCharacter_StopAllAnimMontages_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.STAT_TickEnd
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::STAT_TickEnd()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18998);

	ATslCharacter_STAT_TickEnd_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.STAT_TickBegin
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::STAT_TickBegin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18997);

	ATslCharacter_STAT_TickBegin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SpawnPunchImpact_Reliable
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                 InLocation                     (Parm, IsPlainOldData)
// struct FRotator                InRotation                     (Parm, IsPlainOldData)

void ATslCharacter::SpawnPunchImpact_Reliable(const struct FVector& InLocation, const struct FRotator& InRotation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18994);

	ATslCharacter_SpawnPunchImpact_Reliable_Params params;
	params.InLocation = InLocation;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SpawnPunchImpact
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                 InLocation                     (Parm, IsPlainOldData)
// struct FRotator                InRotation                     (Parm, IsPlainOldData)

void ATslCharacter::SpawnPunchImpact(const struct FVector& InLocation, const struct FRotator& InRotation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18991);

	ATslCharacter_SpawnPunchImpact_Params params;
	params.InLocation = InLocation;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SpawnBulletPassByEffect
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                 Location                       (Parm, IsPlainOldData)
// float                          BulletVelocity                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SpawnBulletPassByEffect(const struct FVector& Location, float BulletVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18988);

	ATslCharacter_SpawnBulletPassByEffect_Params params;
	params.Location = Location;
	params.BulletVelocity = BulletVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SimulatePhysicalHitRecovery
// (Final, Native, Protected)

void ATslCharacter::SimulatePhysicalHitRecovery()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18987);

	ATslCharacter_SimulatePhysicalHitRecovery_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SimulateHeadShot
// (Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// struct FTransform              SpawnTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              ImpactTransform                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void ATslCharacter::SimulateHeadShot(const struct FTransform& SpawnTransform, const struct FTransform& ImpactTransform)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18984);

	ATslCharacter_SimulateHeadShot_Params params;
	params.SpawnTransform = SpawnTransform;
	params.ImpactTransform = ImpactTransform;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ShowDynamicCrosshair
// (Final, Exec, Native, Public)
// Parameters:
// bool                           bShow                          (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ShowDynamicCrosshair(bool bShow)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18982);

	ATslCharacter_ShowDynamicCrosshair_Params params;
	params.bShow = bShow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ShowCharacterInformation
// (Final, Exec, Native, Public)
// Parameters:
// bool                           bFullInfo                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ShowCharacterInformation(bool bFullInfo)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18980);

	ATslCharacter_ShowCharacterInformation_Params params;
	params.bFullInfo = bFullInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetWorldTransformIdentity
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::SetWorldTransformIdentity()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18979);

	ATslCharacter_SetWorldTransformIdentity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetWeaponInertia
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                InInertia                      (Parm, IsPlainOldData)

void ATslCharacter::SetWeaponInertia(const struct FRotator& InInertia)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18977);

	ATslCharacter_SetWeaponInertia_Params params;
	params.InInertia = InInertia;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetupWeaponBlueprint
// (Event, Public, BlueprintEvent)

void ATslCharacter::SetupWeaponBlueprint()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18976);

	ATslCharacter_SetupWeaponBlueprint_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetTPPSpringarmOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          VerticalOffset                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetTPPSpringarmOffset(float VerticalOffset)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18974);

	ATslCharacter_SetTPPSpringarmOffset_Params params;
	params.VerticalOffset = VerticalOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetTickOptimization_Movement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bActivate                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetTickOptimization_Movement(bool bActivate)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18972);

	ATslCharacter_SetTickOptimization_Movement_Params params;
	params.bActivate = bActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetTickOptimization_Anim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bActivate                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetTickOptimization_Anim(bool bActivate)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18970);

	ATslCharacter_SetTickOptimization_Anim_Params params;
	params.bActivate = bActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetTickOptimization_Actor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bActivate                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetTickOptimization_Actor(bool bActivate)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18968);

	ATslCharacter_SetTickOptimization_Actor_Params params;
	params.bActivate = bActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetSwayDebuffParameters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          SwaySpeed                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          SwayVerticalMultiplier         (Parm, ZeroConstructor, IsPlainOldData)
// float                          SwayHorizontalMultiplier       (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetSwayDebuffParameters(float SwaySpeed, float SwayVerticalMultiplier, float SwayHorizontalMultiplier)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18964);

	ATslCharacter_SetSwayDebuffParameters_Params params;
	params.SwaySpeed = SwaySpeed;
	params.SwayVerticalMultiplier = SwayVerticalMultiplier;
	params.SwayHorizontalMultiplier = SwayHorizontalMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetServerVaultFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           InFinished                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetServerVaultFinished(bool InFinished)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18962);

	ATslCharacter_SetServerVaultFinished_Params params;
	params.InFinished = InFinished;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetParachuteLandingAssist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bAssistActive                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetParachuteLandingAssist(bool bAssistActive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18960);

	ATslCharacter_SetParachuteLandingAssist_Params params;
	params.bAssistActive = bAssistActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetMovementEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           IsEnabled                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetMovementEnabled(bool IsEnabled)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18958);

	ATslCharacter_SetMovementEnabled_Params params;
	params.IsEnabled = IsEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetLaunchEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FAttackId               AttackId                       (Parm)
// class ATslPlayerState*         InPlayerState                  (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  Causer                         (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  DamageTypeClass                (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetLaunchEvent(const struct FAttackId& AttackId, class ATslPlayerState* InPlayerState, class AActor* Causer, class UClass* DamageTypeClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18953);

	ATslCharacter_SetLaunchEvent_Params params;
	params.AttackId = AttackId;
	params.InPlayerState = InPlayerState;
	params.Causer = Causer;
	params.DamageTypeClass = DamageTypeClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetJumpStartLocationAndFallheight
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 JumpStartLoc                   (Parm, IsPlainOldData)
// float                          FallHeight                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetJumpStartLocationAndFallheight(const struct FVector& JumpStartLoc, float FallHeight)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18950);

	ATslCharacter_SetJumpStartLocationAndFallheight_Params params;
	params.JumpStartLoc = JumpStartLoc;
	params.FallHeight = FallHeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetDebugCameraLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           InLock                         (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetDebugCameraLock(bool InLock)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18948);

	ATslCharacter_SetDebugCameraLock_Params params;
	params.InLock = InLock;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bOn                            (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetCustomDepth(bool bOn)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18946);

	ATslCharacter_SetCustomDepth_Params params;
	params.bOn = bOn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetCharacterVaultingData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InVaultTimer                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InIsVaulting                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InIsClimbing                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InEndVaultToFall               (Parm, ZeroConstructor, IsPlainOldData)
// float                          InDirection                    (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetCharacterVaultingData(float InVaultTimer, bool InIsVaulting, bool InIsClimbing, bool InEndVaultToFall, float InDirection)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18940);

	ATslCharacter_SetCharacterVaultingData_Params params;
	params.InVaultTimer = InVaultTimer;
	params.InIsVaulting = InIsVaulting;
	params.InIsClimbing = InIsClimbing;
	params.InEndVaultToFall = InEndVaultToFall;
	params.InDirection = InDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetCanGroggyDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInCanGroggyDamage             (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetCanGroggyDamage(bool bInCanGroggyDamage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18938);

	ATslCharacter_SetCanGroggyDamage_Params params;
	params.bInCanGroggyDamage = bInCanGroggyDamage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetBulletSpawnOverride
// (Final, Native, Public)
// Parameters:
// bool                           InOverride                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetBulletSpawnOverride(bool InOverride)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18936);

	ATslCharacter_SetBulletSpawnOverride_Params params;
	params.InOverride = InOverride;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetBuffFinalSpreadFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          FinalSpreadFactor              (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetBuffFinalSpreadFactor(float FinalSpreadFactor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18934);

	ATslCharacter_SetBuffFinalSpreadFactor_Params params;
	params.FinalSpreadFactor = FinalSpreadFactor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetBoostGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewBoostGauge                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetBoostGauge(float NewBoostGauge)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18932);

	ATslCharacter_SetBoostGauge_Params params;
	params.NewBoostGauge = NewBoostGauge;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetAnimationAkSwitch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 SwitchGroup                    (Parm, ZeroConstructor)
// struct FString                 SwitchState                    (Parm, ZeroConstructor)

void ATslCharacter::SetAnimationAkSwitch(const struct FString& SwitchGroup, const struct FString& SwitchState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18929);

	ATslCharacter_SetAnimationAkSwitch_Params params;
	params.SwitchGroup = SwitchGroup;
	params.SwitchState = SwitchState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetAnimationAkRTPC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 RTPCName                       (Parm, ZeroConstructor)
// float                          RTPCValue                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetAnimationAkRTPC(const struct FString& RTPCName, float RTPCValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18926);

	ATslCharacter_SetAnimationAkRTPC_Params params;
	params.RTPCName = RTPCName;
	params.RTPCValue = RTPCValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetAimStateActive
// (Final, Native, Protected)
// Parameters:
// bool                           IsActive                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetAimStateActive(bool IsActive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18924);

	ATslCharacter_SetAimStateActive_Params params;
	params.IsActive = IsActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetADSSocketOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewOffset                      (Parm, IsPlainOldData)

void ATslCharacter::SetADSSocketOffset(const struct FVector& NewOffset)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18922);

	ATslCharacter_SetADSSocketOffset_Params params;
	params.NewOffset = NewOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetActiveRagdoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bIsActive                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetActiveRagdoll(bool bIsActive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18920);

	ATslCharacter_SetActiveRagdoll_Params params;
	params.bIsActive = bIsActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetAccessorySlot_Thrown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*  AccessoryComponent             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslCharacter::SetAccessorySlot_Thrown(class UTslAccessoryComponent* AccessoryComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18918);

	ATslCharacter_SetAccessorySlot_Thrown_Params params;
	params.AccessoryComponent = AccessoryComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetAccessorySlot_SideArm
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*  AccessoryComponent             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslCharacter::SetAccessorySlot_SideArm(class UTslAccessoryComponent* AccessoryComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18916);

	ATslCharacter_SetAccessorySlot_SideArm_Params params;
	params.AccessoryComponent = AccessoryComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetAccessorySlot_Secondary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*  AccessoryComponent             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslCharacter::SetAccessorySlot_Secondary(class UTslAccessoryComponent* AccessoryComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18914);

	ATslCharacter_SetAccessorySlot_Secondary_Params params;
	params.AccessoryComponent = AccessoryComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetAccessorySlot_Primary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*  AccessoryComponent             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslCharacter::SetAccessorySlot_Primary(class UTslAccessoryComponent* AccessoryComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18912);

	ATslCharacter_SetAccessorySlot_Primary_Params params;
	params.AccessoryComponent = AccessoryComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetAccessorySlot_Melee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*  AccessoryComponent             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslCharacter::SetAccessorySlot_Melee(class UTslAccessoryComponent* AccessoryComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18910);

	ATslCharacter_SetAccessorySlot_Melee_Params params;
	params.AccessoryComponent = AccessoryComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SetAccessorySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*  AccessoryComponent             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// EAccessorySlot                 Slot                           (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::SetAccessorySlot(class UTslAccessoryComponent* AccessoryComponent, EAccessorySlot Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18906);

	ATslCharacter_SetAccessorySlot_Params params;
	params.AccessoryComponent = AccessoryComponent;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerTestSkinLoad
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslCharacter::ServerTestSkinLoad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18905);

	ATslCharacter_ServerTestSkinLoad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetTargeting
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// ETargetingType                 NewTargetingType               (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerSetTargeting(ETargetingType NewTargetingType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18902);

	ATslCharacter_ServerSetTargeting_Params params;
	params.NewTargetingType = NewTargetingType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetSprintingAuto
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           bNewSprintingAuto              (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerSetSprintingAuto(bool bNewSprintingAuto)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18900);

	ATslCharacter_ServerSetSprintingAuto_Params params;
	params.bNewSprintingAuto = bNewSprintingAuto;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetSprinting
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           bNewSprinting                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerSetSprinting(bool bNewSprinting)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18898);

	ATslCharacter_ServerSetSprinting_Params params;
	params.bNewSprinting = bNewSprinting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetRunning
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           bNewRunning                    (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerSetRunning(bool bNewRunning)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18896);

	ATslCharacter_ServerSetRunning_Params params;
	params.bNewRunning = bNewRunning;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetRolling
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           bNewRolling                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsLeft                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerSetRolling(bool bNewRolling, bool bIsLeft)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18893);

	ATslCharacter_ServerSetRolling_Params params;
	params.bNewRolling = bNewRolling;
	params.bIsLeft = bIsLeft;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetPeekRight
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           bNewPeekRight                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbUseRightShoulderAiming      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerSetPeekRight(bool bNewPeekRight, bool InbUseRightShoulderAiming)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18890);

	ATslCharacter_ServerSetPeekRight_Params params;
	params.bNewPeekRight = bNewPeekRight;
	params.InbUseRightShoulderAiming = InbUseRightShoulderAiming;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetPeekLeft
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           bNewPeekLeft                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbUseRightShoulderAiming      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerSetPeekLeft(bool bNewPeekLeft, bool InbUseRightShoulderAiming)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18887);

	ATslCharacter_ServerSetPeekLeft_Params params;
	params.bNewPeekLeft = bNewPeekLeft;
	params.InbUseRightShoulderAiming = InbUseRightShoulderAiming;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetHoldingBreath
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           bNewHoldingBreath              (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerSetHoldingBreath(bool bNewHoldingBreath)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18885);

	ATslCharacter_ServerSetHoldingBreath_Params params;
	params.bNewHoldingBreath = bNewHoldingBreath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetGunDirectionSway
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FRotator                InGunDirectionSway             (Parm, IsPlainOldData)

void ATslCharacter::ServerSetGunDirectionSway(const struct FRotator& InGunDirectionSway)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18883);

	ATslCharacter_ServerSetGunDirectionSway_Params params;
	params.InGunDirectionSway = InGunDirectionSway;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetCurrentWeaponZoomLevel
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// unsigned char                  ZoomLevel                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerSetCurrentWeaponZoomLevel(unsigned char ZoomLevel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18881);

	ATslCharacter_ServerSetCurrentWeaponZoomLevel_Params params;
	params.ZoomLevel = ZoomLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerSetAimOffsets
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantizeNormal NewAimOffsets                  (Parm)

void ATslCharacter::ServerSetAimOffsets(const struct FVector_NetQuantizeNormal& NewAimOffsets)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18879);

	ATslCharacter_ServerSetAimOffsets_Params params;
	params.NewAimOffsets = NewAimOffsets;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ServerBroadCastAimingRemote
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           InbIsAming                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ServerBroadCastAimingRemote(bool InbIsAming)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18877);

	ATslCharacter_ServerBroadCastAimingRemote_Params params;
	params.InbIsAming = InbIsAming;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_UnarmedHitNotify
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FHitResult              Hit                            (Parm, IsPlainOldData)
// TEnumAsByte<EPunchDamageType>  PunchDamageType                (Parm, ZeroConstructor, IsPlainOldData)
// TArray<float>                  AimSpeeds                      (ConstParm, Parm, ZeroConstructor, ReferenceParm)
// uint32_t                       HitSeq                         (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_UnarmedHitNotify(const struct FHitResult& Hit, TEnumAsByte<EPunchDamageType> PunchDamageType, TArray<float> AimSpeeds, uint32_t HitSeq)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18871);

	ATslCharacter_Server_UnarmedHitNotify_Params params;
	params.Hit = Hit;
	params.PunchDamageType = PunchDamageType;
	params.AimSpeeds = AimSpeeds;
	params.HitSeq = HitSeq;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_SetWeaponObstruction
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// bool                           bNewObstruction                (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_SetWeaponObstruction(bool bNewObstruction)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18869);

	ATslCharacter_Server_SetWeaponObstruction_Params params;
	params.bNewObstruction = bNewObstruction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_SetVaultCancel
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           InCancel                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_SetVaultCancel(bool InCancel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18867);

	ATslCharacter_Server_SetVaultCancel_Params params;
	params.InCancel = InCancel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_SetThrowMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           bNewVal                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_SetThrowMode(bool bNewVal)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18865);

	ATslCharacter_Server_SetThrowMode_Params params;
	params.bNewVal = bNewVal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_SetParachuteLandingAssist
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                           bAssistActive                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_SetParachuteLandingAssist(bool bAssistActive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18863);

	ATslCharacter_Server_SetParachuteLandingAssist_Params params;
	params.bAssistActive = bAssistActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_SetFiringMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EFiringMode                    fMode                          (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_SetFiringMode(EFiringMode fMode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18860);

	ATslCharacter_Server_SetFiringMode_Params params;
	params.fMode = fMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_SetCoatEquipped
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           IsEquipped                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_SetCoatEquipped(bool IsEquipped)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18858);

	ATslCharacter_Server_SetCoatEquipped_Params params;
	params.IsEquipped = IsEquipped;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_SetCastAnim
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// ECastAnim                      InCastAnim                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_SetCastAnim(ECastAnim InCastAnim)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18855);

	ATslCharacter_Server_SetCastAnim_Params params;
	params.InCastAnim = InCastAnim;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_SetCanGroggyDamage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           bInCanGroggyDamage             (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_SetCanGroggyDamage(bool bInCanGroggyDamage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18853);

	ATslCharacter_Server_SetCanGroggyDamage_Params params;
	params.bInCanGroggyDamage = bInCanGroggyDamage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_SetAimState
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                           IsActive                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_SetAimState(bool IsActive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18851);

	ATslCharacter_Server_SetAimState_Params params;
	params.IsActive = IsActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_PlayUnarmedAttack
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int                            AnimationIndex                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_PlayUnarmedAttack(int AnimationIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18849);

	ATslCharacter_Server_PlayUnarmedAttack_Params params;
	params.AnimationIndex = AnimationIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_CastStartNotify
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UObject*                 CastObject                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Server_CastStartNotify(class UObject* CastObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18847);

	ATslCharacter_Server_CastStartNotify_Params params;
	params.CastObject = CastObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_CastFinishNotify
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslCharacter::Server_CastFinishNotify()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18846);

	ATslCharacter_Server_CastFinishNotify_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Server_CastCancelNotify
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslCharacter::Server_CastCancelNotify()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18845);

	ATslCharacter_Server_CastCancelNotify_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.SendSystemMessage
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// ESystemMessageType             MessageType                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Message                        (ConstParm, Parm, OutParm, ReferenceParm)

void ATslCharacter::SendSystemMessage(ESystemMessageType MessageType, const struct FText& Message)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18841);

	ATslCharacter_SendSystemMessage_Params params;
	params.MessageType = MessageType;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.RunVaultCheck_BP
// (Native, Event, Public, BlueprintEvent)

void ATslCharacter::RunVaultCheck_BP()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18840);

	ATslCharacter_RunVaultCheck_BP_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ResetUnarmedAttack
// (Final, Native, Public)

void ATslCharacter::ResetUnarmedAttack()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18839);

	ATslCharacter_ResetUnarmedAttack_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ResetParachute
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::ResetParachute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18838);

	ATslCharacter_ResetParachute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.RemoveParachute
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ATslCharacter::RemoveParachute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18837);

	ATslCharacter_RemoveParachute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.RemoveCrosshair
// (Event, Public, BlueprintEvent)

void ATslCharacter::RemoveCrosshair()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18836);

	ATslCharacter_RemoveCrosshair_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ReevaluaeTargetingState
// (Final, Native, Public)

void ATslCharacter::ReevaluaeTargetingState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18835);

	ATslCharacter_ReevaluaeTargetingState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.PunchStart
// (Final, Native, Public, HasOutParms)
// Parameters:
// TEnumAsByte<EPunchDamageType>  PunchDamageType                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          PunchDistance                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          PunchRadius                    (Parm, ZeroConstructor, IsPlainOldData)
// TArray<float>                  InAimSpeeds                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void ATslCharacter::PunchStart(TEnumAsByte<EPunchDamageType> PunchDamageType, float PunchDistance, float PunchRadius, TArray<float> InAimSpeeds)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18829);

	ATslCharacter_PunchStart_Params params;
	params.PunchDamageType = PunchDamageType;
	params.PunchDistance = PunchDistance;
	params.PunchRadius = PunchRadius;
	params.InAimSpeeds = InAimSpeeds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ProcessRevive
// (Event, Public, BlueprintEvent)
// Parameters:
// float                          RemainGroggyHealthPercent      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ProcessRevive(float RemainGroggyHealthPercent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18827);

	ATslCharacter_ProcessRevive_Params params;
	params.RemainGroggyHealthPercent = RemainGroggyHealthPercent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ProcessDBNO
// (Event, Public, BlueprintEvent)
// Parameters:
// float                          GroggyHealthPercent            (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ProcessDBNO(float GroggyHealthPercent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18825);

	ATslCharacter_ProcessDBNO_Params params;
	params.GroggyHealthPercent = GroggyHealthPercent;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.PrepareParachute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  ParachuteType                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::PrepareParachute(class UClass* ParachuteType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18823);

	ATslCharacter_PrepareParachute_Params params;
	params.ParachuteType = ParachuteType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.PlayCameraAnim
// (Final, Native, Public)
// Parameters:
// class UCameraAnim*             CameraAnim                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::PlayCameraAnim(class UCameraAnim* CameraAnim)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18821);

	ATslCharacter_PlayCameraAnim_Params params;
	params.CameraAnim = CameraAnim;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.PickUpItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItem*                   Item                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   TargetContainer                (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::PickUpItem(class UItem* Item, const struct FName& TargetContainer, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18816);

	ATslCharacter_PickUpItem_Params params;
	params.Item = Item;
	params.TargetContainer = TargetContainer;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnWeaponChanged
// (Event, Protected, BlueprintEvent)

void ATslCharacter::OnWeaponChanged()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18815);

	ATslCharacter_OnWeaponChanged_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnWeapon_Slot
// (Final, Native, Public)
// Parameters:
// EAccessorySlot                 Slot                           (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::OnWeapon_Slot(EAccessorySlot Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18812);

	ATslCharacter_OnWeapon_Slot_Params params;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnWeapon_6
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_6()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18811);

	ATslCharacter_OnWeapon_6_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnWeapon_5
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_5()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18810);

	ATslCharacter_OnWeapon_5_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnWeapon_4
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_4()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18809);

	ATslCharacter_OnWeapon_4_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnWeapon_3
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_3()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18808);

	ATslCharacter_OnWeapon_3_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnWeapon_2
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_2()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18807);

	ATslCharacter_OnWeapon_2_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnUnarmPadInput
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnUnarmPadInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18805);

	ATslCharacter_OnUnarmPadInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnUnarmPad
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnUnarmPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18804);

	ATslCharacter_OnUnarmPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnUnarm
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnUnarm()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18803);

	ATslCharacter_OnUnarm_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnToggleThrowModePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnToggleThrowModePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18801);

	ATslCharacter_OnToggleThrowModePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnToggleThrowMode
// (Final, Native, Public)

void ATslCharacter::OnToggleThrowMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18800);

	ATslCharacter_OnToggleThrowMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnToggleSprintingAutoPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnToggleSprintingAutoPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18798);

	ATslCharacter_OnToggleSprintingAutoPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnTogglePronePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnTogglePronePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18796);

	ATslCharacter_OnTogglePronePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnToggleProne
// (Final, Native, Public)

void ATslCharacter::OnToggleProne()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18795);

	ATslCharacter_OnToggleProne_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnToggleFiringModePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnToggleFiringModePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18793);

	ATslCharacter_OnToggleFiringModePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnToggleCrouchPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnToggleCrouchPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18791);

	ATslCharacter_OnToggleCrouchPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnToggleCrouch
// (Final, Native, Public)

void ATslCharacter::OnToggleCrouch()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18790);

	ATslCharacter_OnToggleCrouch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnThrowWeaponPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnThrowWeaponPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18788);

	ATslCharacter_OnThrowWeaponPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnTest_SetupWeapon
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnTest_SetupWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18787);

	ATslCharacter_OnTest_SetupWeapon_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnTest_InspectObject
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnTest_InspectObject()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18786);

	ATslCharacter_OnTest_InspectObject_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnStopTargetingPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStopTargetingPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18784);

	ATslCharacter_OnStopTargetingPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStopTargeting
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnStopTargeting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18783);

	ATslCharacter_OnStopTargeting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnStopScopeAdjustmentModifierPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStopScopeAdjustmentModifierPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18781);

	ATslCharacter_OnStopScopeAdjustmentModifierPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStopHoldBreathPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStopHoldBreathPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18779);

	ATslCharacter_OnStopHoldBreathPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStopFirePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStopFirePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18777);

	ATslCharacter_OnStopFirePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStopFire
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnStopFire()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18776);

	ATslCharacter_OnStopFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnStopAimPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStopAimPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18774);

	ATslCharacter_OnStopAimPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStopADSPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStopADSPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18772);

	ATslCharacter_OnStopADSPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStartTargetingPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStartTargetingPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18770);

	ATslCharacter_OnStartTargetingPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStartScopeAdjustmentModifierPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStartScopeAdjustmentModifierPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18768);

	ATslCharacter_OnStartScopeAdjustmentModifierPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStartJumpOrVaultPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStartJumpOrVaultPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18766);

	ATslCharacter_OnStartJumpOrVaultPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStartJumpOrVault
// (Final, Native, Public)

void ATslCharacter::OnStartJumpOrVault()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18765);

	ATslCharacter_OnStartJumpOrVault_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnStartInteractBy
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::OnStartInteractBy(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18763);

	ATslCharacter_OnStartInteractBy_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnStartHoldBreathPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStartHoldBreathPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18761);

	ATslCharacter_OnStartHoldBreathPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStartFirePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStartFirePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18759);

	ATslCharacter_OnStartFirePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStartFire
// (Final, Native, Public)

void ATslCharacter::OnStartFire()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18758);

	ATslCharacter_OnStartFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnStartCookingThrowablePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStartCookingThrowablePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18756);

	ATslCharacter_OnStartCookingThrowablePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStartAimPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStartAimPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18754);

	ATslCharacter_OnStartAimPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnStartADSPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnStartADSPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18752);

	ATslCharacter_OnStartADSPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnSprintPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnSprintPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18750);

	ATslCharacter_OnSprintPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnShowDynamicCrosshair
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                           bShow                          (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::OnShowDynamicCrosshair(bool bShow)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18748);

	ATslCharacter_OnShowDynamicCrosshair_Params params;
	params.bShow = bShow;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnResetZeroingPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnResetZeroingPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18746);

	ATslCharacter_OnResetZeroingPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnRep_WeaponProcessor
// (Final, Native, Protected)

void ATslCharacter::OnRep_WeaponProcessor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18745);

	ATslCharacter_OnRep_WeaponProcessor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_TargetingType
// (Final, Native, Protected)

void ATslCharacter::OnRep_TargetingType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18744);

	ATslCharacter_OnRep_TargetingType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_ShoesSoundType
// (Final, Native, Protected)

void ATslCharacter::OnRep_ShoesSoundType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18743);

	ATslCharacter_OnRep_ShoesSoundType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_ReviveCastingTime
// (Final, Native, Protected)

void ATslCharacter::OnRep_ReviveCastingTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18742);

	ATslCharacter_OnRep_ReviveCastingTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_LastTakeHitInfo
// (Final, Native, Protected)

void ATslCharacter::OnRep_LastTakeHitInfo()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18741);

	ATslCharacter_OnRep_LastTakeHitInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsWeaponObstructed
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsWeaponObstructed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18740);

	ATslCharacter_OnRep_IsWeaponObstructed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsThrowHigh
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsThrowHigh()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18739);

	ATslCharacter_OnRep_IsThrowHigh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsThirdPerson
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsThirdPerson()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18738);

	ATslCharacter_OnRep_IsThirdPerson_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsScopingRemote
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsScopingRemote()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18737);

	ATslCharacter_OnRep_IsScopingRemote_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsReviving
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsReviving()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18736);

	ATslCharacter_OnRep_IsReviving_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsPeekRight
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsPeekRight()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18735);

	ATslCharacter_OnRep_IsPeekRight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsPeekLeft
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsPeekLeft()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18734);

	ATslCharacter_OnRep_IsPeekLeft_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsInVehicleRemote
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsInVehicleRemote()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18733);

	ATslCharacter_OnRep_IsInVehicleRemote_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsGroggying
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsGroggying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18732);

	ATslCharacter_OnRep_IsGroggying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsFirstPersonRemote
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsFirstPersonRemote()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18731);

	ATslCharacter_OnRep_IsFirstPersonRemote_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsDemoVaulting
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsDemoVaulting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18730);

	ATslCharacter_OnRep_IsDemoVaulting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsCrouched
// (Native, Public)

void ATslCharacter::OnRep_IsCrouched()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18729);

	ATslCharacter_OnRep_IsCrouched_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsCoatEquipped
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsCoatEquipped()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18728);

	ATslCharacter_OnRep_IsCoatEquipped_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IsAimingRemote
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsAimingRemote()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18727);

	ATslCharacter_OnRep_IsAimingRemote_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_IgnoreRotation
// (Final, Native, Protected)

void ATslCharacter::OnRep_IgnoreRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18726);

	ATslCharacter_OnRep_IgnoreRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_Health
// (Final, Native, Protected)
// Parameters:
// float                          LastHealth                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::OnRep_Health(float LastHealth)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18724);

	ATslCharacter_OnRep_Health_Params params;
	params.LastHealth = LastHealth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_GroggyHealth
// (Final, Native, Protected)
// Parameters:
// float                          LastGroggyHealth               (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::OnRep_GroggyHealth(float LastGroggyHealth)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18722);

	ATslCharacter_OnRep_GroggyHealth_Params params;
	params.LastGroggyHealth = LastGroggyHealth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_CurrentWeaponZoomLevel
// (Final, Native, Protected)

void ATslCharacter::OnRep_CurrentWeaponZoomLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18721);

	ATslCharacter_OnRep_CurrentWeaponZoomLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_CharacterState
// (Final, Native, Protected)

void ATslCharacter::OnRep_CharacterState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18720);

	ATslCharacter_OnRep_CharacterState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_CastAnim
// (Final, Native, Protected)

void ATslCharacter::OnRep_CastAnim()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18719);

	ATslCharacter_OnRep_CastAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_BoostGauge
// (Final, Native, Protected)
// Parameters:
// float                          LastBoostGauge                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::OnRep_BoostGauge(float LastBoostGauge)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18717);

	ATslCharacter_OnRep_BoostGauge_Params params;
	params.LastBoostGauge = LastBoostGauge;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_AimStateActive
// (Final, Native, Protected)

void ATslCharacter::OnRep_AimStateActive()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18716);

	ATslCharacter_OnRep_AimStateActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnRep_AimOffsets
// (Final, Native, Protected)
// Parameters:
// struct FVector_NetQuantizeNormal PrevAimOffsets                 (Parm)

void ATslCharacter::OnRep_AimOffsets(const struct FVector_NetQuantizeNormal& PrevAimOffsets)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18714);

	ATslCharacter_OnRep_AimOffsets_Params params;
	params.PrevAimOffsets = PrevAimOffsets;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnReloadPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnReloadPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18712);

	ATslCharacter_OnReloadPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnPeekRightPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnPeekRightPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18710);

	ATslCharacter_OnPeekRightPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnPeekLeftPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnPeekLeftPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18708);

	ATslCharacter_OnPeekLeftPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnNextMainWeaponPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnNextMainWeaponPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18706);

	ATslCharacter_OnNextMainWeaponPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnMeleeOrSideWeaponPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnMeleeOrSideWeaponPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18704);

	ATslCharacter_OnMeleeOrSideWeaponPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnInvulnerable
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnInvulnerable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18703);

	ATslCharacter_OnInvulnerable_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnInteractBy
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::OnInteractBy(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18701);

	ATslCharacter_OnInteractBy_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnIncreaseZeroingPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnIncreaseZeroingPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18699);

	ATslCharacter_OnIncreaseZeroingPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnIncreaseMaxFlyAccerleration
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnIncreaseMaxFlyAccerleration()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18698);

	ATslCharacter_OnIncreaseMaxFlyAccerleration_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnHoldBreathReleased
// (Final, Native, Public)

void ATslCharacter::OnHoldBreathReleased()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18697);

	ATslCharacter_OnHoldBreathReleased_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnHoldBreathPressed
// (Final, Native, Public)

void ATslCharacter::OnHoldBreathPressed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18696);

	ATslCharacter_OnHoldBreathPressed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnFreeMoveMode
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnFreeMoveMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18695);

	ATslCharacter_OnFreeMoveMode_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnEquippedItemUpdated
// (Final, Native, Public)

void ATslCharacter::OnEquippedItemUpdated()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18694);

	ATslCharacter_OnEquippedItemUpdated_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnDecreaseZeroingPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnDecreaseZeroingPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18692);

	ATslCharacter_OnDecreaseZeroingPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.OnDecreaseMaxFlyAccerleration
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnDecreaseMaxFlyAccerleration()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18691);

	ATslCharacter_OnDecreaseMaxFlyAccerleration_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnChangeBreath
// (Final, Native, Private)
// Parameters:
// float                          Breath                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          LastBreath                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          BreathMax                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::OnChangeBreath(float Breath, float LastBreath, float BreathMax)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18687);

	ATslCharacter_OnChangeBreath_Params params;
	params.Breath = Breath;
	params.LastBreath = LastBreath;
	params.BreathMax = BreathMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnCancelInteractBy
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::OnCancelInteractBy(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18685);

	ATslCharacter_OnCancelInteractBy_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnBlockingWidgetOpened
// (Final, Native, Public)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslCharacter::OnBlockingWidgetOpened(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18683);

	ATslCharacter_OnBlockingWidgetOpened_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.OnArmPadInput
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::OnArmPadInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18681);

	ATslCharacter_OnArmPadInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.NotHaveThrowItemNotifyMessage
// (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
// struct FText                   ItemName                       (ConstParm, Parm, OutParm, ReferenceParm)

void ATslCharacter::NotHaveThrowItemNotifyMessage(const struct FText& ItemName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18679);

	ATslCharacter_NotHaveThrowItemNotifyMessage_Params params;
	params.ItemName = ItemName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.NotHaveHealItemNotifyMessage
// (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
// struct FText                   ItemName                       (ConstParm, Parm, OutParm, ReferenceParm)

void ATslCharacter::NotHaveHealItemNotifyMessage(const struct FText& ItemName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18677);

	ATslCharacter_NotHaveHealItemNotifyMessage_Params params;
	params.ItemName = ItemName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.NotHaveBoostItemNotifyMessage
// (Event, Public, BlueprintEvent)

void ATslCharacter::NotHaveBoostItemNotifyMessage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18676);

	ATslCharacter_NotHaveBoostItemNotifyMessage_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.NativeOnWeaponChanged
// (Final, Native, Private)

void ATslCharacter::NativeOnWeaponChanged()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18675);

	ATslCharacter_NativeOnWeaponChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.LocalMagazineDrop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*  PawnMesh                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslCharacter::LocalMagazineDrop(class USkeletalMeshComponent* PawnMesh)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18673);

	ATslCharacter_LocalMagazineDrop_Params params;
	params.PawnMesh = PawnMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.LocalHandleVault_CP
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                 V_Start                        (Parm, IsPlainOldData)
// struct FVector                 V_Apex                         (Parm, IsPlainOldData)
// struct FVector                 V_ApexAdditive                 (Parm, IsPlainOldData)
// struct FVector                 V_End                          (Parm, IsPlainOldData)
// bool                           bIsClimb                       (Parm, ZeroConstructor, IsPlainOldData)
// EVaultAnimType                 InVaultType                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEndToFall                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Direction                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          PlayerVelocity                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          DistanceFromObject             (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::LocalHandleVault_CP(const struct FVector& V_Start, const struct FVector& V_Apex, const struct FVector& V_ApexAdditive, const struct FVector& V_End, bool bIsClimb, EVaultAnimType InVaultType, bool bEndToFall, float Direction, float PlayerVelocity, float DistanceFromObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18661);

	ATslCharacter_LocalHandleVault_CP_Params params;
	params.V_Start = V_Start;
	params.V_Apex = V_Apex;
	params.V_ApexAdditive = V_ApexAdditive;
	params.V_End = V_End;
	params.bIsClimb = bIsClimb;
	params.InVaultType = InVaultType;
	params.bEndToFall = bEndToFall;
	params.Direction = Direction;
	params.PlayerVelocity = PlayerVelocity;
	params.DistanceFromObject = DistanceFromObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.IsZooming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsZooming()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18659);

	ATslCharacter_IsZooming_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsZombie
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsZombie()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18657);

	ATslCharacter_IsZombie_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsWeaponUsingHighMagnificationScope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsWeaponUsingHighMagnificationScope()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18655);

	ATslCharacter_IsWeaponUsingHighMagnificationScope_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsVehiclePassenger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsVehiclePassenger()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18653);

	ATslCharacter_IsVehiclePassenger_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsVehicleDriver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsVehicleDriver()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18651);

	ATslCharacter_IsVehicleDriver_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsVaultingEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsVaultingEnabled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18649);

	ATslCharacter_IsVaultingEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsVaultingDebugEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsVaultingDebugEnabled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18647);

	ATslCharacter_IsVaultingDebugEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsVaulting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsVaulting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18645);

	ATslCharacter_IsVaulting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsVaultCancelled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsVaultCancelled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18643);

	ATslCharacter_IsVaultCancelled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsUsingRightShoulderAiming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsUsingRightShoulderAiming()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18641);

	ATslCharacter_IsUsingRightShoulderAiming_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsUpperCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsUpperCollision()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18639);

	ATslCharacter_IsUpperCollision_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsUnderwater
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsUnderwater()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18637);

	ATslCharacter_IsUnderwater_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsUnderRoof
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsUnderRoof()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18635);

	ATslCharacter_IsUnderRoof_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsTeamMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsTeamMatch()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18633);

	ATslCharacter_IsTeamMatch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsTargeting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsTargeting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18631);

	ATslCharacter_IsTargeting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsSwimming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsSwimming()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18629);

	ATslCharacter_IsSwimming_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsSprinting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18627);

	ATslCharacter_IsSprinting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsSpectatingCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsSpectatingCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18625);

	ATslCharacter_IsSpectatingCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsSitting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsSitting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18623);

	ATslCharacter_IsSitting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsScoping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsScoping()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18621);

	ATslCharacter_IsScoping_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsRunning()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18619);

	ATslCharacter_IsRunning_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsRolling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsRolling()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18617);

	ATslCharacter_IsRolling_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsReviving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsReviving()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18615);

	ATslCharacter_IsReviving_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsQuitter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsQuitter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18613);

	ATslCharacter_IsQuitter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsQuickThrowHigh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsQuickThrowHigh()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18611);

	ATslCharacter_IsQuickThrowHigh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsPlayingPickUpAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsPlayingPickUpAnimation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18609);

	ATslCharacter_IsPlayingPickUpAnimation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsPeekRight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsPeekRight()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18607);

	ATslCharacter_IsPeekRight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsPeekLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsPeekLeft()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18605);

	ATslCharacter_IsPeekLeft_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsParachuting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsParachuting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18603);

	ATslCharacter_IsParachuting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsParachuteStuck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsParachuteStuck()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18601);

	ATslCharacter_IsParachuteStuck_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsMoving()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18599);

	ATslCharacter_IsMoving_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsMouseUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsMouseUse()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18597);

	ATslCharacter_IsMouseUse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsMeleeAttacking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsMeleeAttacking()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18595);

	ATslCharacter_IsMeleeAttacking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsMagazineHandAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*  PawnMesh                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsMagazineHandAttached(class USkeletalMeshComponent* PawnMesh)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18592);

	ATslCharacter_IsMagazineHandAttached_Params params;
	params.PawnMesh = PawnMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsMagazineGunAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*  WeapMesh                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsMagazineGunAttached(class USkeletalMeshComponent* WeapMesh)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18589);

	ATslCharacter_IsMagazineGunAttached_Params params;
	params.WeapMesh = WeapMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsLookingThroughScope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsLookingThroughScope()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18587);

	ATslCharacter_IsLookingThroughScope_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsLocalOrSpectating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsLocalOrSpectating()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18585);

	ATslCharacter_IsLocalOrSpectating_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsInWaterVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsInWaterVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18583);

	ATslCharacter_IsInWaterVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsInVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsInVehicle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18581);

	ATslCharacter_IsInVehicle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsInteracting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18579);

	ATslCharacter_IsInteracting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsIndoor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsIndoor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18577);

	ATslCharacter_IsIndoor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsInAircraft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsInAircraft()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18575);

	ATslCharacter_IsInAircraft_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsHoldingBreath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsHoldingBreath()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18573);

	ATslCharacter_IsHoldingBreath_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsHitted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsHitted()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18571);

	ATslCharacter_IsHitted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsHipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsHipped()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18569);

	ATslCharacter_IsHipped_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsGroggying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsGroggying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18567);

	ATslCharacter_IsGroggying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsFreelooking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsFreelooking()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18565);

	ATslCharacter_IsFreelooking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsForcingFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsForcingFall()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18563);

	ATslCharacter_IsForcingFall_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsForceRotation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsForceRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18561);

	ATslCharacter_IsForceRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsForcedProneAfterFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsForcedProneAfterFall()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18559);

	ATslCharacter_IsForcedProneAfterFall_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsFollowingCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsFollowingCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18557);

	ATslCharacter_IsFollowingCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsFloating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsFloating()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18555);

	ATslCharacter_IsFloating_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsFirstPerson
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsFirstPerson()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18553);

	ATslCharacter_IsFirstPerson_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsFiring
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsFiring()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18551);

	ATslCharacter_IsFiring_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsFallingWithParachute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsFallingWithParachute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18549);

	ATslCharacter_IsFallingWithParachute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsFallingFromHighAltitude
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsFallingFromHighAltitude()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18547);

	ATslCharacter_IsFallingFromHighAltitude_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsDying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18545);

	ATslCharacter_IsDying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsDebugCameraLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsDebugCameraLocked()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18543);

	ATslCharacter_IsDebugCameraLocked_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsCycleInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsCycleInProgress()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18541);

	ATslCharacter_IsCycleInProgress_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsCycleAnimActive
// (Final, Native, Public, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsCycleAnimActive()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18539);

	ATslCharacter_IsCycleAnimActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsCoatEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsCoatEquipped()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18537);

	ATslCharacter_IsCoatEquipped_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsCasting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsCasting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18535);

	ATslCharacter_IsCasting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsCameraUnderwater
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsCameraUnderwater()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18533);

	ATslCharacter_IsCameraUnderwater_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsAudioTestEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsAudioTestEnabled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18531);

	ATslCharacter_IsAudioTestEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsAttacked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsAttacked()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18529);

	ATslCharacter_IsAttacked_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsAnimDynamicsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsAnimDynamicsEnabled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18527);

	ATslCharacter_IsAnimDynamicsEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsAlive()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18525);

	ATslCharacter_IsAlive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.IsActiveRagdoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::IsActiveRagdoll()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18523);

	ATslCharacter_IsActiveRagdoll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.HaveNotAnyHealItemNotifyMessage
// (Event, Public, BlueprintEvent)

void ATslCharacter::HaveNotAnyHealItemNotifyMessage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18522);

	ATslCharacter_HaveNotAnyHealItemNotifyMessage_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.HasWeaponLeftHandIKSocket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::HasWeaponLeftHandIKSocket()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18520);

	ATslCharacter_HasWeaponLeftHandIKSocket_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.HasWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  WeaponClass                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::HasWeapon(class UClass* WeaponClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18517);

	ATslCharacter_HasWeapon_Params params;
	params.WeaponClass = WeaponClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.HasSkinForTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::HasSkinForTag(const struct FName& Tag)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18514);

	ATslCharacter_HasSkinForTag_Params params;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.HasSameSkin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkinItem*               TargetSkinItem                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::HasSameSkin(class USkinItem* TargetSkinItem)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18511);

	ATslCharacter_HasSameSkin_Params params;
	params.TargetSkinItem = TargetSkinItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.HasAnimatableObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimatableCustomizableTypes   InParamType                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::HasAnimatableObject(EAnimatableCustomizableTypes InParamType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18507);

	ATslCharacter_HasAnimatableObject_Params params;
	params.InParamType = InParamType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.HandleVaulting_BP
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                 ImpactLocation                 (Parm, IsPlainOldData)
// struct FVector                 CapsulePredictedLocation       (Parm, IsPlainOldData)
// struct FVector                 Normal2D                       (Parm, IsPlainOldData)
// struct FVector                 DirectionVecotor               (Parm, IsPlainOldData)
// bool                           bForceVault                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          JumpDistance                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bBlockVault                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bBlockClimb                    (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::HandleVaulting_BP(const struct FVector& ImpactLocation, const struct FVector& CapsulePredictedLocation, const struct FVector& Normal2D, const struct FVector& DirectionVecotor, bool bForceVault, float JumpDistance, bool bBlockVault, bool bBlockClimb)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18498);

	ATslCharacter_HandleVaulting_BP_Params params;
	params.ImpactLocation = ImpactLocation;
	params.CapsulePredictedLocation = CapsulePredictedLocation;
	params.Normal2D = Normal2D;
	params.DirectionVecotor = DirectionVecotor;
	params.bForceVault = bForceVault;
	params.JumpDistance = JumpDistance;
	params.bBlockVault = bBlockVault;
	params.bBlockClimb = bBlockClimb;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.HandleVaultEnd_CP
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                 InVaultEndVelocity             (Parm, IsPlainOldData)

void ATslCharacter::HandleVaultEnd_CP(const struct FVector& InVaultEndVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18496);

	ATslCharacter_HandleVaultEnd_CP_Params params;
	params.InVaultEndVelocity = InVaultEndVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.HandleCapsuleCollision
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::HandleCapsuleCollision()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18495);

	ATslCharacter_HandleCapsuleCollision_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.GiveWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  WeaponClass                    (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::GiveWeapon(class UClass* WeaponClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18493);

	ATslCharacter_GiveWeapon_Params params;
	params.WeaponClass = WeaponClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.GetWeaponThrowable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Throwable*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon_Throwable* ATslCharacter::GetWeaponThrowable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18491);

	ATslCharacter_GetWeaponThrowable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponReloadPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetWeaponReloadPlayRate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18489);

	ATslCharacter_GetWeaponReloadPlayRate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Gun_Projectile* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon_Gun_Projectile* ATslCharacter::GetWeaponProjectile()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18487);

	ATslCharacter_GetWeaponProjectile_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponProcessor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWeaponProcessor*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AWeaponProcessor* ATslCharacter::GetWeaponProcessor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18485);

	ATslCharacter_GetWeaponProcessor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponObstructionRemote
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::GetWeaponObstructionRemote()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18483);

	ATslCharacter_GetWeaponObstructionRemote_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponMovementModifierScope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetWeaponMovementModifierScope()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18481);

	ATslCharacter_GetWeaponMovementModifierScope_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponMovementModifierAim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetWeaponMovementModifierAim()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18479);

	ATslCharacter_GetWeaponMovementModifierAim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponLeftHandIKTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform ATslCharacter::GetWeaponLeftHandIKTransform()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18477);

	ATslCharacter_GetWeaponLeftHandIKTransform_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponInertia
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATslCharacter::GetWeaponInertia()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18475);

	ATslCharacter_GetWeaponInertia_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponHandIK_Right
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform ATslCharacter::GetWeaponHandIK_Right()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18473);

	ATslCharacter_GetWeaponHandIK_Right_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponHandIK_Left
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform ATslCharacter::GetWeaponHandIK_Left()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18471);

	ATslCharacter_GetWeaponHandIK_Left_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponGunCollisionAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetWeaponGunCollisionAlpha()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18469);

	ATslCharacter_GetWeaponGunCollisionAlpha_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponGun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Gun*          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon_Gun* ATslCharacter::GetWeaponGun()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18467);

	ATslCharacter_GetWeaponGun_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponADSTimeModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetWeaponADSTimeModifier()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18465);

	ATslCharacter_GetWeaponADSTimeModifier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* ATslCharacter::GetWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18463);

	ATslCharacter_GetWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetWantsToJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::GetWantsToJump()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18461);

	ATslCharacter_GetWantsToJump_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehicleSeatComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslVehicleSeatComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslVehicleSeatComponent* ATslCharacter::GetVehicleSeatComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18459);

	ATslCharacter_GetVehicleSeatComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehicleSeat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVehicleSeatInteractionComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UVehicleSeatInteractionComponent* ATslCharacter::GetVehicleSeat()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18457);

	ATslCharacter_GetVehicleSeat_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehicleRiderComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVehicleRiderComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UVehicleRiderComponent* ATslCharacter::GetVehicleRiderComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18455);

	ATslCharacter_GetVehicleRiderComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehiclePawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class APawn* ATslCharacter::GetVehiclePawn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18453);

	ATslCharacter_GetVehiclePawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehicleInterface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class UTslVehicleInterface> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TScriptInterface<class UTslVehicleInterface> ATslCharacter::GetVehicleInterface()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18451);

	ATslCharacter_GetVehicleInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetVaultTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetVaultTimer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18449);

	ATslCharacter_GetVaultTimer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetVaultingDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetVaultingDirection()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18447);

	ATslCharacter_GetVaultingDirection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetVaultingDebugType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslCharacter::GetVaultingDebugType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18445);

	ATslCharacter_GetVaultingDebugType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetVaultingDataByEnum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVaultAnimType                 InVaultType                    (Parm, ZeroConstructor, IsPlainOldData)
// class UVaultingData*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UVaultingData* ATslCharacter::GetVaultingDataByEnum(EVaultAnimType InVaultType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18441);

	ATslCharacter_GetVaultingDataByEnum_Params params;
	params.InVaultType = InVaultType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetTslPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerState*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerState* ATslCharacter::GetTslPlayerState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18439);

	ATslCharacter_GetTslPlayerState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetTslPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerController*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerController* ATslCharacter::GetTslPlayerController()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18437);

	ATslCharacter_GetTslPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetTslCharacterMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslCharacterMovement*   ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslCharacterMovement* ATslCharacter::GetTslCharacterMovement()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18435);

	ATslCharacter_GetTslCharacterMovement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetTPPSpringarmOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetTPPSpringarmOffset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18433);

	ATslCharacter_GetTPPSpringarmOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetTPPCameraCurve
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCurveFloat*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UCurveFloat* ATslCharacter::GetTPPCameraCurve()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18431);

	ATslCharacter_GetTPPCameraCurve_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATeam*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATeam* ATslCharacter::GetTeam()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18429);

	ATslCharacter_GetTeam_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetTargetingSpeedModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetTargetingSpeedModifier()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18427);

	ATslCharacter_GetTargetingSpeedModifier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<EStanceMode>       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<EStanceMode> ATslCharacter::GetStance()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18425);

	ATslCharacter_GetStance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetSprintingSpeedModifier_Stand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetSprintingSpeedModifier_Stand()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18423);

	ATslCharacter_GetSprintingSpeedModifier_Stand_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetSprintingSpeedModifier_Prone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetSprintingSpeedModifier_Prone()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18421);

	ATslCharacter_GetSprintingSpeedModifier_Prone_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetSprintingSpeedModifier_Crouch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetSprintingSpeedModifier_Crouch()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18419);

	ATslCharacter_GetSprintingSpeedModifier_Crouch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetSprintCurrentValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetSprintCurrentValue()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18417);

	ATslCharacter_GetSprintCurrentValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetSpeedModifierByWeaponClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetSpeedModifierByWeaponClass()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18415);

	ATslCharacter_GetSpeedModifierByWeaponClass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetSpeedKmPerHour2D
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetSpeedKmPerHour2D()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18413);

	ATslCharacter_GetSpeedKmPerHour2D_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetShortPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATslCharacter::GetShortPlayerName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18411);

	ATslCharacter_GetShortPlayerName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetServerVaultFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::GetServerVaultFinished()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18409);

	ATslCharacter_GetServerVaultFinished_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetRunningSpeedModifier_Stand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetRunningSpeedModifier_Stand()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18407);

	ATslCharacter_GetRunningSpeedModifier_Stand_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetRunningSpeedModifier_Prone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetRunningSpeedModifier_Prone()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18405);

	ATslCharacter_GetRunningSpeedModifier_Prone_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetRunningSpeedModifier_Crouch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetRunningSpeedModifier_Crouch()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18403);

	ATslCharacter_GetRunningSpeedModifier_Crouch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetReactionBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName ATslCharacter::GetReactionBone(const struct FName& BoneName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18400);

	ATslCharacter_GetReactionBone_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATslCharacter::GetPlayerName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18398);

	ATslCharacter_GetPlayerName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetParachuteLandingAssist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::GetParachuteLandingAssist()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18396);

	ATslCharacter_GetParachuteLandingAssist_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetParachute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AParachuteVehicle*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AParachuteVehicle* ATslCharacter::GetParachute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18394);

	ATslCharacter_GetParachute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetObjectCanInteract
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class UInteractionInterface> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TScriptInterface<class UInteractionInterface> ATslCharacter::GetObjectCanInteract()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18392);

	ATslCharacter_GetObjectCanInteract_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetMaxSprintSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetMaxSprintSpeed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18390);

	ATslCharacter_GetMaxSprintSpeed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetMaxGroundSpeedOnSlope
// (Final, Native, Public, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetMaxGroundSpeedOnSlope()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18388);

	ATslCharacter_GetMaxGroundSpeedOnSlope_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetLocationString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATslCharacter::GetLocationString()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18386);

	ATslCharacter_GetLocationString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetLeanRightAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetLeanRightAlpha()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18384);

	ATslCharacter_GetLeanRightAlpha_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetLeanLeftAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetLeanLeftAlpha()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18382);

	ATslCharacter_GetLeanLeftAlpha_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetLastMoveRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATslCharacter::GetLastMoveRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18380);

	ATslCharacter_GetLastMoveRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetInventoryFacade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInventoryFacade*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AInventoryFacade* ATslCharacter::GetInventoryFacade()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18378);

	ATslCharacter_GetInventoryFacade_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetInteractObjectLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslCharacter::GetInteractObjectLocation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18376);

	ATslCharacter_GetInteractObjectLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetInteractionString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATslCharacter::GetInteractionString()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18374);

	ATslCharacter_GetInteractionString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetIndoorFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetIndoorFactor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18372);

	ATslCharacter_GetIndoorFactor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetFreelookSavedRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATslCharacter::GetFreelookSavedRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18370);

	ATslCharacter_GetFreelookSavedRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetFreelookDeltaRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATslCharacter::GetFreelookDeltaRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18368);

	ATslCharacter_GetFreelookDeltaRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetDynamicCrosshairHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::GetDynamicCrosshairHidden()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18366);

	ATslCharacter_GetDynamicCrosshairHidden_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetDropPackageType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* ATslCharacter::GetDropPackageType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18364);

	ATslCharacter_GetDropPackageType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetDirectionString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATslCharacter::GetDirectionString()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18362);

	ATslCharacter_GetDirectionString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetDirectionalSpeedModifier
// (Final, Native, Public, Const)
// Parameters:
// TEnumAsByte<EMovementType>     StanceType                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetDirectionalSpeedModifier(TEnumAsByte<EMovementType> StanceType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18359);

	ATslCharacter_GetDirectionalSpeedModifier_Params params;
	params.StanceType = StanceType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetDesiredRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATslCharacter::GetDesiredRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18357);

	ATslCharacter_GetDesiredRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* ATslCharacter::GetCurrentWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18355);

	ATslCharacter_GetCurrentWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentWaterSurfaceZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetCurrentWaterSurfaceZ()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18353);

	ATslCharacter_GetCurrentWaterSurfaceZ_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentWaterSurfaceBaseZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetCurrentWaterSurfaceBaseZ()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18351);

	ATslCharacter_GetCurrentWaterSurfaceBaseZ_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentWaterDepth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetCurrentWaterDepth()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18349);

	ATslCharacter_GetCurrentWaterDepth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentSway
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATslCharacter::GetCurrentSway()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18347);

	ATslCharacter_GetCurrentSway_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentMagazineMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*  WeapMesh                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UStaticMesh*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UStaticMesh* ATslCharacter::GetCurrentMagazineMesh(class USkeletalMeshComponent* WeapMesh)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18344);

	ATslCharacter_GetCurrentMagazineMesh_Params params;
	params.WeapMesh = WeapMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentMagazineLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*  WeapMesh                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform ATslCharacter::GetCurrentMagazineLocation(class USkeletalMeshComponent* WeapMesh)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18341);

	ATslCharacter_GetCurrentMagazineLocation_Params params;
	params.WeapMesh = WeapMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentHeightFromWaterFloor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetCurrentHeightFromWaterFloor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18339);

	ATslCharacter_GetCurrentHeightFromWaterFloor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCtrlShortCutOnOff
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::GetCtrlShortCutOnOff()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18337);

	ATslCharacter_GetCtrlShortCutOnOff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetComponentCanInteract
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class UInteractionInterface> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TScriptInterface<class UInteractionInterface> ATslCharacter::GetComponentCanInteract()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18335);

	ATslCharacter_GetComponentCanInteract_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetClientTslPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerState*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerState* ATslCharacter::GetClientTslPlayerState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18333);

	ATslCharacter_GetClientTslPlayerState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCharacterNetId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATslCharacter::GetCharacterNetId()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18331);

	ATslCharacter_GetCharacterNetId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCastObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UObject* ATslCharacter::GetCastObject()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18329);

	ATslCharacter_GetCastObject_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCameraDOF
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslCharacter::GetCameraDOF()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18327);

	ATslCharacter_GetCameraDOF_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetCameraAnimOverrideAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetCameraAnimOverrideAlpha()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18325);

	ATslCharacter_GetCameraAnimOverrideAlpha_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetBulletSpawnOverride
// (Final, Native, Public, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::GetBulletSpawnOverride()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18323);

	ATslCharacter_GetBulletSpawnOverride_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetBuffComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBuffComponet*           ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UBuffComponet* ATslCharacter::GetBuffComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18321);

	ATslCharacter_GetBuffComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetBreathComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterBreathComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UCharacterBreathComponent* ATslCharacter::GetBreathComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18319);

	ATslCharacter_GetBreathComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetAnimWeaponType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimWeaponType                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EAnimWeaponType ATslCharacter::GetAnimWeaponType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18316);

	ATslCharacter_GetAnimWeaponType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetAnimStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimStance                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EAnimStance ATslCharacter::GetAnimStance()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18313);

	ATslCharacter_GetAnimStance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetAimStateTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetAimStateTimer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18311);

	ATslCharacter_GetAimStateTimer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetAimStateAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslCharacter::GetAimStateAlpha()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18309);

	ATslCharacter_GetAimStateAlpha_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetAimOffsets
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATslCharacter::GetAimOffsets()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18307);

	ATslCharacter_GetAimOffsets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetADSSocketOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslCharacter::GetADSSocketOffset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18305);

	ATslCharacter_GetADSSocketOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetActorCanInteract
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AActor* ATslCharacter::GetActorCanInteract()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18303);

	ATslCharacter_GetActorCanInteract_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetActiveTslPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerController*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerController* ATslCharacter::GetActiveTslPlayerController()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18301);

	ATslCharacter_GetActiveTslPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetActiveCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*        ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UCameraComponent* ATslCharacter::GetActiveCamera()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18299);

	ATslCharacter_GetActiveCamera_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.GetAccessorySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAccessorySlot                 Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// class UTslAccessoryComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslAccessoryComponent* ATslCharacter::GetAccessorySlot(EAccessorySlot Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18295);

	ATslCharacter_GetAccessorySlot_Params params;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.FixupCamera
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::FixupCamera()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18294);

	ATslCharacter_FixupCamera_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.FindWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  WeaponClass                    (Parm, ZeroConstructor, IsPlainOldData)
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* ATslCharacter::FindWeapon(class UClass* WeaponClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18291);

	ATslCharacter_FindWeapon_Params params;
	params.WeaponClass = WeaponClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.EnableScopeOutsideBlur
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::EnableScopeOutsideBlur()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18289);

	ATslCharacter_EnableScopeOutsideBlur_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.EnableAudioTest
// (Final, Exec, Native, Public)

void ATslCharacter::EnableAudioTest()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18288);

	ATslCharacter_EnableAudioTest_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.DisableCollision
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::DisableCollision()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18287);

	ATslCharacter_DisableCollision_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.DelayedFire
// (Final, Native, Protected)

void ATslCharacter::DelayedFire()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18286);

	ATslCharacter_DelayedFire_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientSoundPlayMulticast
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// class UAkAudioEvent*           SoundAk                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientSoundPlayMulticast(class UAkAudioEvent* SoundAk)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18284);

	ATslCharacter_ClientSoundPlayMulticast_Params params;
	params.SoundAk = SoundAk;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientSoundPlay
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class UAkAudioEvent*           SoundAk                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientSoundPlay(class UAkAudioEvent* SoundAk)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18282);

	ATslCharacter_ClientSoundPlay_Params params;
	params.SoundAk = SoundAk;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientSimulationArmorDestruction
// (Net, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// EEquipSlotID                   SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              Impact                         (Parm, IsPlainOldData)

void ATslCharacter::ClientSimulationArmorDestruction(EEquipSlotID SlotID, const struct FTransform& Impact)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18278);

	ATslCharacter_ClientSimulationArmorDestruction_Params params;
	params.SlotID = SlotID;
	params.Impact = Impact;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientSetTargeting
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// ETargetingType                 NewTargetingType               (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientSetTargeting(ETargetingType NewTargetingType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18275);

	ATslCharacter_ClientSetTargeting_Params params;
	params.NewTargetingType = NewTargetingType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientSendGroggyMessage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ATslPlayerState*         GroggyCauserPlayerState        (Parm, ZeroConstructor, IsPlainOldData)
// class ATslPlayerState*         VictimPlayerState              (Parm, ZeroConstructor, IsPlainOldData)
// class UDamageType*             GroggyCauserDamageType         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// EDamageReason                  DamageReason                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   DamageCauserName               (ConstParm, Parm, ReferenceParm)
// class UClass*                  DamageCauserClass              (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientSendGroggyMessage(class ATslPlayerState* GroggyCauserPlayerState, class ATslPlayerState* VictimPlayerState, class UDamageType* GroggyCauserDamageType, EDamageReason DamageReason, const struct FText& DamageCauserName, class UClass* DamageCauserClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18267);

	ATslCharacter_ClientSendGroggyMessage_Params params;
	params.GroggyCauserPlayerState = GroggyCauserPlayerState;
	params.VictimPlayerState = VictimPlayerState;
	params.GroggyCauserDamageType = GroggyCauserDamageType;
	params.DamageReason = DamageReason;
	params.DamageCauserName = DamageCauserName;
	params.DamageCauserClass = DamageCauserClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientRevivedCastingWidgetShow
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           bVisible                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientRevivedCastingWidgetShow(bool bVisible)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18265);

	ATslCharacter_ClientRevivedCastingWidgetShow_Params params;
	params.bVisible = bVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientProcessRevive
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                          RemainGroggyHealth             (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientProcessRevive(float RemainGroggyHealth)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18263);

	ATslCharacter_ClientProcessRevive_Params params;
	params.RemainGroggyHealth = RemainGroggyHealth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientPlayPickUpAnimation
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FVector_NetQuantize     InteractionObject              (ConstParm, Parm)

void ATslCharacter::ClientPlayPickUpAnimation(const struct FVector_NetQuantize& InteractionObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18261);

	ATslCharacter_ClientPlayPickUpAnimation_Params params;
	params.InteractionObject = InteractionObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientNotifyCrack
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FVector_NetQuantize     LocationRelative               (Parm)
// float                          BulletVelocity                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientNotifyCrack(const struct FVector_NetQuantize& LocationRelative, float BulletVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18258);

	ATslCharacter_ClientNotifyCrack_Params params;
	params.LocationRelative = LocationRelative;
	params.BulletVelocity = BulletVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientMyCharacterPlayPickUpAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FVector_NetQuantize     InteractionObject              (ConstParm, Parm)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientMyCharacterPlayPickUpAnimation(const struct FVector_NetQuantize& InteractionObject, float Duration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18255);

	ATslCharacter_ClientMyCharacterPlayPickUpAnimation_Params params;
	params.InteractionObject = InteractionObject;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientForceInitStance
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// TEnumAsByte<EStanceMode>       ToStance                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientForceInitStance(TEnumAsByte<EStanceMode> ToStance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18253);

	ATslCharacter_ClientForceInitStance_Params params;
	params.ToStance = ToStance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ClientDrawDamageInfo
// (Net, Native, Event, Public, NetClient)
// Parameters:
// float                          Damage                         (Parm, ZeroConstructor, IsPlainOldData)
// class UTslDamageType*          DamageType                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::ClientDrawDamageInfo(float Damage, class UTslDamageType* DamageType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18250);

	ATslCharacter_ClientDrawDamageInfo_Params params;
	params.Damage = Damage;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Client_PlayUnarmedAttack
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// int                            AnimationIndex                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::Client_PlayUnarmedAttack(int AnimationIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18248);

	ATslCharacter_Client_PlayUnarmedAttack_Params params;
	params.AnimationIndex = AnimationIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Client_CastFinishNotify
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)

void ATslCharacter::Client_CastFinishNotify()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18247);

	ATslCharacter_Client_CastFinishNotify_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Client_CastCancelNotify
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)

void ATslCharacter::Client_CastCancelNotify()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18246);

	ATslCharacter_Client_CastCancelNotify_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.CheckScopePP
// (Final, Native, Public)

void ATslCharacter::CheckScopePP()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18245);

	ATslCharacter_CheckScopePP_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.CheckMuzzleCollision
// (Final, Native, Public)

void ATslCharacter::CheckMuzzleCollision()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18244);

	ATslCharacter_CheckMuzzleCollision_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.CheckMuzzleBulletSpawn
// (Final, Native, Public)

void ATslCharacter::CheckMuzzleBulletSpawn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18243);

	ATslCharacter_CheckMuzzleBulletSpawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.CheckJumpAndVault
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                           bForceVelocity                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InForcedVelocity               (Parm, IsPlainOldData)

void ATslCharacter::CheckJumpAndVault(bool bForceVelocity, const struct FVector& InForcedVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18240);

	ATslCharacter_CheckJumpAndVault_Params params;
	params.bForceVelocity = bForceVelocity;
	params.InForcedVelocity = InForcedVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.CheckForCoat
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::CheckForCoat()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18239);

	ATslCharacter_CheckForCoat_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.CheckEquipmentSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FEquipPosition          InSlotData                     (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::CheckEquipmentSlot(const struct FEquipPosition& InSlotData)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18236);

	ATslCharacter_CheckEquipmentSlot_Params params;
	params.InSlotData = InSlotData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.CanSwim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::CanSwim()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18234);

	ATslCharacter_CanSwim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.BindCallbackToHUD
// (Final, Native, Public)
// Parameters:
// class ATslPlayerController*    InController                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::BindCallbackToHUD(class ATslPlayerController* InController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18232);

	ATslCharacter_BindCallbackToHUD_Params params;
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.ApplyRagdollPhysicsForce
// (Final, Native, Public)

void ATslCharacter::ApplyRagdollPhysicsForce()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18231);

	ATslCharacter_ApplyRagdollPhysicsForce_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Anim_MagazineShow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bShow                          (Parm, ZeroConstructor, IsPlainOldData)
// class USkeletalMeshComponent*  PawnMesh                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslCharacter::Anim_MagazineShow(bool bShow, class USkeletalMeshComponent* PawnMesh)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18228);

	ATslCharacter_Anim_MagazineShow_Params params;
	params.bShow = bShow;
	params.PawnMesh = PawnMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Anim_MagazineHandAttach
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bAttach                        (Parm, ZeroConstructor, IsPlainOldData)
// class USkeletalMeshComponent*  PawnMesh                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslCharacter::Anim_MagazineHandAttach(bool bAttach, class USkeletalMeshComponent* PawnMesh)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18225);

	ATslCharacter_Anim_MagazineHandAttach_Params params;
	params.bAttach = bAttach;
	params.PawnMesh = PawnMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.Anim_IsMagazineVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::Anim_IsMagazineVisible()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18223);

	ATslCharacter_Anim_IsMagazineVisible_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.AllowInteract
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslCharacter::AllowInteract(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18220);

	ATslCharacter_AllowInteract_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacter.AdminSetUpWeapon
// (Event, Public, BlueprintEvent)

void ATslCharacter::AdminSetUpWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18219);

	ATslCharacter_AdminSetUpWeapon_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.AdminInvulnerable
// (Event, Public, BlueprintEvent)

void ATslCharacter::AdminInvulnerable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18218);

	ATslCharacter_AdminInvulnerable_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.AdminFreeMoveMode
// (Event, Public, BlueprintEvent)

void ATslCharacter::AdminFreeMoveMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18217);

	ATslCharacter_AdminFreeMoveMode_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacter.AddBuffMoveSpeedFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          MoveSpeedFactor                (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacter::AddBuffMoveSpeedFactor(float MoveSpeedFactor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(18215);

	ATslCharacter_AddBuffMoveSpeedFactor_Params params;
	params.MoveSpeedFactor = MoveSpeedFactor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslUserWidget.TransferUserFocusThroughReply
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FFocusEvent             AcceptedFocusEvent             (ConstParm, Parm, OutParm, ReferenceParm)
// struct FEventReply             Reply                          (Parm, OutParm, ReferenceParm)
// class UWidget*                 FocusWidget                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           bInAllUsers                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FEventReply             ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEventReply UTslUserWidget::TransferUserFocusThroughReply(const struct FFocusEvent& AcceptedFocusEvent, class UWidget* FocusWidget, bool bInAllUsers, struct FEventReply* Reply)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19391);

	UTslUserWidget_TransferUserFocusThroughReply_Params params;
	params.AcceptedFocusEvent = AcceptedFocusEvent;
	params.FocusWidget = FocusWidget;
	params.bInAllUsers = bInAllUsers;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Reply != nullptr)
		*Reply = params.Reply;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.StopListeningForAllInputAxises
// (Final, Native, Public, BlueprintCallable)

void UTslUserWidget::StopListeningForAllInputAxises()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19390);

	UTslUserWidget_StopListeningForAllInputAxises_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslUserWidget.NavigateUserFocus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULocalPlayer*            Player                         (Parm, ZeroConstructor, IsPlainOldData)
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslUserWidget::NavigateUserFocus(class ULocalPlayer* Player, class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19386);

	UTslUserWidget_NavigateUserFocus_Params params;
	params.Player = Player;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.ListenForInputAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   AxisName                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bConsume                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FScriptDelegate         Callback                       (Parm, ZeroConstructor)

void UTslUserWidget::ListenForInputAxis(const struct FName& AxisName, float Scale, bool bConsume, const struct FScriptDelegate& Callback)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19381);

	UTslUserWidget_ListenForInputAxis_Params params;
	params.AxisName = AxisName;
	params.Scale = Scale;
	params.bConsume = bConsume;
	params.Callback = Callback;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslUserWidget.IsReplaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslUserWidget::IsReplaying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19379);

	UTslUserWidget_IsReplaying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.GetRawKeyValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslUserWidget::GetRawKeyValue(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19376);

	UTslUserWidget_GetRawKeyValue_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.GetDemoPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           IsForMatchResult               (Parm, ZeroConstructor, IsPlainOldData)
// class ATslPlayerState*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerState* UTslUserWidget::GetDemoPlayerState(bool IsForMatchResult)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19373);

	UTslUserWidget_GetDemoPlayerState_Params params;
	params.IsForMatchResult = IsForMatchResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.GetCachedViewTargetTslCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UTslUserWidget::GetCachedViewTargetTslCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19371);

	UTslUserWidget_GetCachedViewTargetTslCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.GetCachedGameState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslGameState*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslGameState* UTslUserWidget::GetCachedGameState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19369);

	UTslUserWidget_GetCachedGameState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.GetCachedCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UTslUserWidget::GetCachedCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19367);

	UTslUserWidget_GetCachedCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.ContainUserFocus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULocalPlayer*            Player                         (Parm, ZeroConstructor, IsPlainOldData)
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslUserWidget::ContainUserFocus(class ULocalPlayer* Player, class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19363);

	UTslUserWidget_ContainUserFocus_Params params;
	params.Player = Player;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.ContainOwnerUserFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslUserWidget::ContainOwnerUserFocus()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19361);

	UTslUserWidget_ContainOwnerUserFocus_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslUserWidget.ClearUserFocus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULocalPlayer*            Player                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslUserWidget::ClearUserFocus(class ULocalPlayer* Player)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19359);

	UTslUserWidget_ClearUserFocus_Params params;
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.UmgBaseWidget.IsMouseOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUmgBaseWidget::IsMouseOn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19405);

	UUmgBaseWidget_IsMouseOn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UmgBaseWidget.HandleMainPrepass
// (Native, Public)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UUmgBaseWidget::HandleMainPrepass(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19403);

	UUmgBaseWidget_HandleMainPrepass_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.UmgBaseWidget.CheckWantRequestRender
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUmgBaseWidget::CheckWantRequestRender()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19401);

	UUmgBaseWidget_CheckWantRequestRender_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ObserverTagWidget.UpdateWeaponIcon_Imp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USizeBox*                weaponBox                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UImage*                  weaponImage                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UObserverTagWidget::UpdateWeaponIcon_Imp(class USizeBox* weaponBox, class UImage* weaponImage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19448);

	UObserverTagWidget_UpdateWeaponIcon_Imp_Params params;
	params.weaponBox = weaponBox;
	params.weaponImage = weaponImage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.UpdateWeaponIcon
// (Event, Public, BlueprintEvent)

void UObserverTagWidget::UpdateWeaponIcon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19447);

	UObserverTagWidget_UpdateWeaponIcon_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.SetTeamNumber
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// int                            TeamNumber                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            teamColor                      (Parm, IsPlainOldData)

void UObserverTagWidget::SetTeamNumber(int TeamNumber, const struct FLinearColor& teamColor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19444);

	UObserverTagWidget_SetTeamNumber_Params params;
	params.TeamNumber = TeamNumber;
	params.teamColor = teamColor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.SetPlayerNameTag
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FName                   PlayerName                     (Parm, ZeroConstructor, IsPlainOldData)

void UObserverTagWidget::SetPlayerNameTag(const struct FName& PlayerName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19442);

	UObserverTagWidget_SetPlayerNameTag_Params params;
	params.PlayerName = PlayerName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.SetIndicatorColor
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FLinearColor            teamColor                      (Parm, IsPlainOldData)

void UObserverTagWidget::SetIndicatorColor(const struct FLinearColor& teamColor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19440);

	UObserverTagWidget_SetIndicatorColor_Params params;
	params.teamColor = teamColor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.SetCharacterIconPosition_UC
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D               Pos_UC                         (Parm, IsPlainOldData)
// bool                           IsHidden                       (Parm, ZeroConstructor, IsPlainOldData)

void UObserverTagWidget::SetCharacterIconPosition_UC(const struct FVector2D& Pos_UC, bool IsHidden)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19437);

	UObserverTagWidget_SetCharacterIconPosition_UC_Params params;
	params.Pos_UC = Pos_UC;
	params.IsHidden = IsHidden;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.OnUpdateWidgetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UWidget*                 CharacterNameWidget            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UWidget*                 IndicatorWidget                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector2D               Pos_UC                         (Parm, IsPlainOldData)
// bool                           IsHidden                       (Parm, ZeroConstructor, IsPlainOldData)

void UObserverTagWidget::OnUpdateWidgetTransform(class UWidget* CharacterNameWidget, class UWidget* IndicatorWidget, const struct FVector2D& Pos_UC, bool IsHidden)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19432);

	UObserverTagWidget_OnUpdateWidgetTransform_Params params;
	params.CharacterNameWidget = CharacterNameWidget;
	params.IndicatorWidget = IndicatorWidget;
	params.Pos_UC = Pos_UC;
	params.IsHidden = IsHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.IsTeamMember
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UObserverTagWidget::IsTeamMember()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19430);

	UObserverTagWidget_IsTeamMember_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ObserverTagWidget.IsLastSpectatedCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UObserverTagWidget::IsLastSpectatedCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19428);

	UObserverTagWidget_IsLastSpectatedCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ObserverTagWidget.HandleWidgetPrepass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UObserverTagWidget::HandleWidgetPrepass(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19426);

	UObserverTagWidget_HandleWidgetPrepass_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.HandleWeaponImagePrepass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UObserverTagWidget::HandleWeaponImagePrepass(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19424);

	UObserverTagWidget_HandleWeaponImagePrepass_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.HandleTeamNumberPrepass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UObserverTagWidget::HandleTeamNumberPrepass(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19422);

	UObserverTagWidget_HandleTeamNumberPrepass_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagWidget.GetTeamId
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           TslCharacter                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UObserverTagWidget::GetTeamId(class ATslCharacter* TslCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19419);

	UObserverTagWidget_GetTeamId_Params params;
	params.TslCharacter = TslCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ObserverTagWidget.GetTeamColor
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           TslCharacter                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FLinearColor UObserverTagWidget::GetTeamColor(class ATslCharacter* TslCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19416);

	UObserverTagWidget_GetTeamColor_Params params;
	params.TslCharacter = TslCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ObserverTagManagerBaseWidget.UpdateReplicateCharacter
// (Final, Native, Public, BlueprintCallable)

void UObserverTagManagerBaseWidget::UpdateReplicateCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19466);

	UObserverTagManagerBaseWidget_UpdateReplicateCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagManagerBaseWidget.RemoveReplicateCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ATslCharacter*>   Characters                     (Parm, ZeroConstructor)

void UObserverTagManagerBaseWidget::RemoveReplicateCharacter(TArray<class ATslCharacter*> Characters)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19463);

	UObserverTagManagerBaseWidget_RemoveReplicateCharacter_Params params;
	params.Characters = Characters;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ObserverTagManagerBaseWidget.AddReplicateCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ATslCharacter*>   Characters                     (Parm, ZeroConstructor)

void UObserverTagManagerBaseWidget::AddReplicateCharacter(TArray<class ATslCharacter*> Characters)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19460);

	UObserverTagManagerBaseWidget_AddReplicateCharacter_Params params;
	params.Characters = Characters;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleInterface.GetVehicleMeshComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class USkeletalMeshComponent* UTslVehicleInterface::GetVehicleMeshComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19470);

	UTslVehicleInterface_GetVehicleMeshComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleInterface.GetTslPlayerController
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerController*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerController* UTslVehicleInterface::GetTslPlayerController()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19468);

	UTslVehicleInterface_GetTslPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicle.ServerRelease
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AParachuteVehicle::ServerRelease()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19506);

	AParachuteVehicle_ServerRelease_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.PhysicsVolumeChanged
// (Final, Native, Private)
// Parameters:
// class APhysicsVolume*          NewVolume                      (Parm, ZeroConstructor, IsPlainOldData)

void AParachuteVehicle::PhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19504);

	AParachuteVehicle_PhysicsVolumeChanged_Params params;
	params.NewVolume = NewVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.OnSecondInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)

void AParachuteVehicle::OnSecondInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19502);

	AParachuteVehicle_OnSecondInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.OnRide
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void AParachuteVehicle::OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19499);

	AParachuteVehicle_OnRide_Params params;
	params.Rider = Rider;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.OnRep_SkinData
// (Final, Native, Private)

void AParachuteVehicle::OnRep_SkinData()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19498);

	AParachuteVehicle_OnRep_SkinData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.OnRep_IsReleased
// (Final, Native, Private)

void AParachuteVehicle::OnRep_IsReleased()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19497);

	AParachuteVehicle_OnRep_IsReleased_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.OnRep_IsDriven
// (Final, Native, Private)

void AParachuteVehicle::OnRep_IsDriven()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19496);

	AParachuteVehicle_OnRep_IsDriven_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.OnPostDriverLeave
// (Final, Native, Private)

void AParachuteVehicle::OnPostDriverLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19495);

	AParachuteVehicle_OnPostDriverLeave_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.OnInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)

void AParachuteVehicle::OnInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19493);

	AParachuteVehicle_OnInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.OnDriverRide
// (Final, Native, Private)

void AParachuteVehicle::OnDriverRide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19492);

	AParachuteVehicle_OnDriverRide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.OnDriverLeave
// (Final, Native, Private)

void AParachuteVehicle::OnDriverLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19491);

	AParachuteVehicle_OnDriverLeave_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.Land
// (Final, Net, Native, Event, NetMulticast, Private)

void AParachuteVehicle::Land()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19490);

	AParachuteVehicle_Land_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicle.IsStuck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AParachuteVehicle::IsStuck()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19488);

	AParachuteVehicle_IsStuck_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicle.IsReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AParachuteVehicle::IsReleased()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19486);

	AParachuteVehicle_IsReleased_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicle.IsDriven
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AParachuteVehicle::IsDriven()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19484);

	AParachuteVehicle_IsDriven_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicle.GetAltitudeFromFloor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AParachuteVehicle::GetAltitudeFromFloor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19482);

	AParachuteVehicle_GetAltitudeFromFloor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicle.CanReleaseByInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AParachuteVehicle::CanReleaseByInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19480);

	AParachuteVehicle_CanReleaseByInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicle.CanRelease
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AParachuteVehicle::CanRelease()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19478);

	AParachuteVehicle_CanRelease_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicle.AllowSecondInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AParachuteVehicle::AllowSecondInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19475);

	AParachuteVehicle_AllowSecondInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicle.AllowInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AParachuteVehicle::AllowInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19472);

	AParachuteVehicle_AllowInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ReplicationTrigger.EnableReplicationGroup
// (Final, Native, Private)

void AReplicationTrigger::EnableReplicationGroup()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19548);

	AReplicationTrigger_EnableReplicationGroup_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.SceneInteractionComponent.GetInteractiveObjectName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText USceneInteractionComponent::GetInteractiveObjectName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19570);

	USceneInteractionComponent_GetInteractiveObjectName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SceneInteractionComponent.GetInteractionVerb
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText USceneInteractionComponent::GetInteractionVerb()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19568);

	USceneInteractionComponent_GetInteractionVerb_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SceneInteractionComponent.AllowInteractBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool USceneInteractionComponent::AllowInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19565);

	USceneInteractionComponent_AllowInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.DoorInteractionComponent.OnRep_DoorState
// (Final, Native, Protected)
// Parameters:
// EDoorState                     PrevDoorState                  (Parm, ZeroConstructor, IsPlainOldData)

void UDoorInteractionComponent::OnRep_DoorState(EDoorState PrevDoorState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19582);

	UDoorInteractionComponent_OnRep_DoorState_Params params;
	params.PrevDoorState = PrevDoorState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.DoorInteractionComponent.AllowInteract
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UDoorInteractionComponent::AllowInteract(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19579);

	UDoorInteractionComponent_AllowInteract_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.DroppedItemInteractionComponent.OnRep_Item
// (Final, Native, Private)

void UDroppedItemInteractionComponent::OnRep_Item()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19595);

	UDroppedItemInteractionComponent_OnRep_Item_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.DroppedItemInteractionComponent.AllowInteractBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UDroppedItemInteractionComponent::AllowInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19592);

	UDroppedItemInteractionComponent_AllowInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.OnRep_Rider
// (Final, Native, Private)

void UVehicleSeatInteractionComponent::OnRep_Rider()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19649);

	UVehicleSeatInteractionComponent_OnRep_Rider_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VehicleSeatInteractionComponent.OnInteractDelegate
// (Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (Parm, ZeroConstructor, IsPlainOldData)

void UVehicleSeatInteractionComponent::OnInteractDelegate(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19647);

	UVehicleSeatInteractionComponent_OnInteractDelegate_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VehicleSeatInteractionComponent.IsWeaponClassAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponClass                   InClass                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UVehicleSeatInteractionComponent::IsWeaponClassAllowed(EWeaponClass InClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19643);

	UVehicleSeatInteractionComponent_IsWeaponClassAllowed_Params params;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.IsEntryAllowedByVelocity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UVehicleSeatInteractionComponent::IsEntryAllowedByVelocity()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19641);

	UVehicleSeatInteractionComponent_IsEntryAllowedByVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetVehicleSeatComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslVehicleSeatComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslVehicleSeatComponent* UVehicleSeatInteractionComponent::GetVehicleSeatComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19639);

	UVehicleSeatInteractionComponent_GetVehicleSeatComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetVehiclePawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class APawn* UVehicleSeatInteractionComponent::GetVehiclePawn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19637);

	UVehicleSeatInteractionComponent_GetVehiclePawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetVehicleInterface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class UTslVehicleInterface> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TScriptInterface<class UTslVehicleInterface> UVehicleSeatInteractionComponent::GetVehicleInterface()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19635);

	UVehicleSeatInteractionComponent_GetVehicleInterface_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetVehicleAnimType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVehicleAnimType               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EVehicleAnimType UVehicleSeatInteractionComponent::GetVehicleAnimType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19632);

	UVehicleSeatInteractionComponent_GetVehicleAnimType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetTransitionOutBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpaceBase* UVehicleSeatInteractionComponent::GetTransitionOutBlendspace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19630);

	UVehicleSeatInteractionComponent_GetTransitionOutBlendspace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetTransitionInBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpaceBase* UVehicleSeatInteractionComponent::GetTransitionInBlendspace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19628);

	UVehicleSeatInteractionComponent_GetTransitionInBlendspace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatIdleAO
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAimOffsetBlendSpace*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAimOffsetBlendSpace* UVehicleSeatInteractionComponent::GetSeatIdleAO()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19626);

	UVehicleSeatInteractionComponent_GetSeatIdleAO_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatIdleAnimation_Unarmed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimSequenceBase* UVehicleSeatInteractionComponent::GetSeatIdleAnimation_Unarmed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19624);

	UVehicleSeatInteractionComponent_GetSeatIdleAnimation_Unarmed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatIdleAnimation_Rifle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimSequenceBase* UVehicleSeatInteractionComponent::GetSeatIdleAnimation_Rifle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19622);

	UVehicleSeatInteractionComponent_GetSeatIdleAnimation_Rifle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatIdleAnimation_Melee
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimSequenceBase* UVehicleSeatInteractionComponent::GetSeatIdleAnimation_Melee()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19620);

	UVehicleSeatInteractionComponent_GetSeatIdleAnimation_Melee_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatIdleAnimation_Grenade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAnimSequenceBase* UVehicleSeatInteractionComponent::GetSeatIdleAnimation_Grenade()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19618);

	UVehicleSeatInteractionComponent_GetSeatIdleAnimation_Grenade_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatAimingFPPBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpaceBase* UVehicleSeatInteractionComponent::GetSeatAimingFPPBlendspace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19616);

	UVehicleSeatInteractionComponent_GetSeatAimingFPPBlendspace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatAimingBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpaceBase* UVehicleSeatInteractionComponent::GetSeatAimingBlendspace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19614);

	UVehicleSeatInteractionComponent_GetSeatAimingBlendspace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetRider
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UVehicleSeatInteractionComponent::GetRider()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19612);

	UVehicleSeatInteractionComponent_GetRider_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetMinPitchByYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          CurrentYaw                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UVehicleSeatInteractionComponent::GetMinPitchByYaw(float CurrentYaw)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19609);

	UVehicleSeatInteractionComponent_GetMinPitchByYaw_Params params;
	params.CurrentYaw = CurrentYaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetMaxPitchByYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          CurrentYaw                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UVehicleSeatInteractionComponent::GetMaxPitchByYaw(float CurrentYaw)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19606);

	UVehicleSeatInteractionComponent_GetMaxPitchByYaw_Params params;
	params.CurrentYaw = CurrentYaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetCanFireOnlyWhileAimed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UVehicleSeatInteractionComponent::GetCanFireOnlyWhileAimed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19604);

	UVehicleSeatInteractionComponent_GetCanFireOnlyWhileAimed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetAdditionalMessage
// (Native, Public, Const)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UVehicleSeatInteractionComponent::GetAdditionalMessage(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19601);

	UVehicleSeatInteractionComponent_GetAdditionalMessage_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.AllowInteractDelegate
// (Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UVehicleSeatInteractionComponent::AllowInteractDelegate(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19598);

	UVehicleSeatInteractionComponent_AllowInteractDelegate_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MotorbikeVehicleSeatInteraction.IsEntryAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           InCharacter                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UMotorbikeVehicleSeatInteraction::IsEntryAllowed(class ATslCharacter* InCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19683);

	UMotorbikeVehicleSeatInteraction_IsEntryAllowed_Params params;
	params.InCharacter = InCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MotorbikeVehicleSeatInteraction.HandleFlipAndKickstand
// (Final, Native, Public, BlueprintCallable)

void UMotorbikeVehicleSeatInteraction::HandleFlipAndKickstand()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19682);

	UMotorbikeVehicleSeatInteraction_HandleFlipAndKickstand_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.FreeFallMovement.ServerUpdateInput
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                          InForwardInput                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          InRightInput                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          InDesiredPitchRotation         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          InDesiredYawRotation           (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UFreeFallMovement::ServerUpdateInput(float InForwardInput, float InRightInput, float InDesiredPitchRotation, float InDesiredYawRotation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19730);

	UFreeFallMovement_ServerUpdateInput_Params params;
	params.InForwardInput = InForwardInput;
	params.InRightInput = InRightInput;
	params.InDesiredPitchRotation = InDesiredPitchRotation;
	params.InDesiredYawRotation = InDesiredYawRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.FreeFallMovement.GetRightInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UFreeFallMovement::GetRightInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19728);

	UFreeFallMovement_GetRightInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.FreeFallMovement.GetForwardInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UFreeFallMovement::GetForwardInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19726);

	UFreeFallMovement_GetForwardInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicleMovement.ServerUpdateInput
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                          InForwardInput                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          InRotationInput                (Parm, ZeroConstructor, IsPlainOldData)

void UParachuteVehicleMovement::ServerUpdateInput(float InForwardInput, float InRotationInput)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19756);

	UParachuteVehicleMovement_ServerUpdateInput_Params params;
	params.InForwardInput = InForwardInput;
	params.InRotationInput = InRotationInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicleMovement.GetRotationYawRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UParachuteVehicleMovement::GetRotationYawRate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19754);

	UParachuteVehicleMovement_GetRotationYawRate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicleMovement.GetRotationInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UParachuteVehicleMovement::GetRotationInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19752);

	UParachuteVehicleMovement_GetRotationInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicleMovement.GetForwardInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UParachuteVehicleMovement::GetForwardInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19750);

	UParachuteVehicleMovement_GetForwardInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicleMovement.GetClientRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator UParachuteVehicleMovement::GetClientRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19748);

	UParachuteVehicleMovement_GetClientRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.SkinHelperComponent.ServerTestWeaponSkinApplyByItemReference
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FString                 Reference                      (Parm, ZeroConstructor)

void USkinHelperComponent::ServerTestWeaponSkinApplyByItemReference(const struct FString& Reference)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19815);

	USkinHelperComponent_ServerTestWeaponSkinApplyByItemReference_Params params;
	params.Reference = Reference;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.SkinHelperComponent.Server_DoUpdateSkinItem
// (Final, Net, NetReliable, Native, Event, Private, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class UBaseWeaponItem*         WeaponItem                     (Parm, ZeroConstructor, IsPlainOldData)
// class USkinItem*               SkinItem                       (Parm, ZeroConstructor, IsPlainOldData)

void USkinHelperComponent::Server_DoUpdateSkinItem(class UBaseWeaponItem* WeaponItem, class USkinItem* SkinItem)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19812);

	USkinHelperComponent_Server_DoUpdateSkinItem_Params params;
	params.WeaponItem = WeaponItem;
	params.SkinItem = SkinItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.StanceComponent.ServerForceInitStance
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UStanceComponent::ServerForceInitStance()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19842);

	UStanceComponent_ServerForceInitStance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.StanceComponent.ServerChangeStance
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// TEnumAsByte<EStanceMode>       ToStance                       (Parm, ZeroConstructor, IsPlainOldData)

void UStanceComponent::ServerChangeStance(TEnumAsByte<EStanceMode> ToStance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19840);

	UStanceComponent_ServerChangeStance_Params params;
	params.ToStance = ToStance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.StanceComponent.OnRep_CurrentStance
// (Native, Public)
// Parameters:
// TEnumAsByte<EStanceMode>       OldCurrentStand                (Parm, ZeroConstructor, IsPlainOldData)

void UStanceComponent::OnRep_CurrentStance(TEnumAsByte<EStanceMode> OldCurrentStand)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19838);

	UStanceComponent_OnRep_CurrentStance_Params params;
	params.OldCurrentStand = OldCurrentStand;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.StanceComponent.ClientInitByReconnection
// (Final, Net, NetReliable, Native, Event, Private, NetClient, NetValidate)
// Parameters:
// TEnumAsByte<EStanceMode>       InitStance                     (Parm, ZeroConstructor, IsPlainOldData)

void UStanceComponent::ClientInitByReconnection(TEnumAsByte<EStanceMode> InitStance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19836);

	UStanceComponent_ClientInitByReconnection_Params params;
	params.InitStance = InitStance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerStart.GetRandomStartYawRotation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPlayerStart::GetRandomStartYawRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19852);

	ATslPlayerStart_GetRandomStartYawRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerStart.GetRandomStartLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslPlayerStart::GetRandomStartLocation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19850);

	ATslPlayerStart_GetRandomStartLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InventoryFacade.IsAutoSwappable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipSlotID                   SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AInventoryFacade::IsAutoSwappable(EEquipSlotID SlotID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19885);

	AInventoryFacade_IsAutoSwappable_Params params;
	params.SlotID = SlotID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InventoryFacade.HasItemByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ItemClass                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AInventoryFacade::HasItemByClass(class UClass* ItemClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19882);

	AInventoryFacade_HasItemByClass_Params params;
	params.ItemClass = ItemClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InventoryFacade.GiveItem_Admin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  ItemClass                      (Parm, ZeroConstructor, IsPlainOldData)

void AInventoryFacade::GiveItem_Admin(class UClass* ItemClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19880);

	AInventoryFacade_GiveItem_Admin_Params params;
	params.ItemClass = ItemClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.InventoryFacade.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* AInventoryFacade::GetOwnerCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19878);

	AInventoryFacade_GetOwnerCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InventoryFacade.GetInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInventory*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AInventory* AInventoryFacade::GetInventory()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19876);

	AInventoryFacade_GetInventory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InventoryFacade.GetEquipment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEquipment*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEquipment* AInventoryFacade::GetEquipment()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19874);

	AInventoryFacade_GetEquipment_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.WeaponIndexToEquipPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            WeaponIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FEquipPosition          ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEquipPosition AEquipment::WeaponIndexToEquipPosition(int WeaponIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19983);

	AEquipment_WeaponIndexToEquipPosition_Params params;
	params.WeaponIndex = WeaponIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.WeaponAttachmentSwap
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition          SourceWeapon                   (Parm)
// struct FEquipPosition          TargetWeapon                   (Parm)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// EWeaponAttachmentSlotID        AttachmentSlotID               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AEquipment::WeaponAttachmentSwap(const struct FEquipPosition& SourceWeapon, const struct FEquipPosition& TargetWeapon, const struct FName& ItemClassForVerify, EWeaponAttachmentSlotID AttachmentSlotID, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19976);

	AEquipment_WeaponAttachmentSwap_Params params;
	params.SourceWeapon = SourceWeapon;
	params.TargetWeapon = TargetWeapon;
	params.ItemClassForVerify = ItemClassForVerify;
	params.AttachmentSlotID = AttachmentSlotID;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Equipment.UnequipItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition          Position                       (Parm)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AEquipment::UnequipItem(const struct FEquipPosition& Position, const struct FName& ItemClassForVerify, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19972);

	AEquipment_UnequipItem_Params params;
	params.Position = Position;
	params.ItemClassForVerify = ItemClassForVerify;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Equipment.TryEquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItem*                   Item                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSwap                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEquipment::TryEquipItem(class UItem* Item, bool bSoundPlay, bool bSwap)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19967);

	AEquipment_TryEquipItem_Params params;
	params.Item = Item;
	params.bSoundPlay = bSoundPlay;
	params.bSwap = bSwap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.PrimaryWeaponSwap
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition          EquipPosition                  (Parm)
// struct FString                 Options                        (Parm, ZeroConstructor)

void AEquipment::PrimaryWeaponSwap(const struct FEquipPosition& EquipPosition, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19964);

	AEquipment_PrimaryWeaponSwap_Params params;
	params.EquipPosition = EquipPosition;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Equipment.Items_RepNotify
// (Final, Native, Protected)

void AEquipment::Items_RepNotify()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19963);

	AEquipment_Items_RepNotify_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Equipment.IsSwapablePrimaryWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEquipPosition          EquipPosition                  (Parm)
// struct FString                 Options                        (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEquipment::IsSwapablePrimaryWeapon(const struct FEquipPosition& EquipPosition, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19959);

	AEquipment_IsSwapablePrimaryWeapon_Params params;
	params.EquipPosition = EquipPosition;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.IsAttachableToWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            WeaponIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// class UAttachableItem*         AttachableItem                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bOnlyFree                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEquipment::IsAttachableToWeapon(int WeaponIndex, class UAttachableItem* AttachableItem, bool bOnlyFree)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19954);

	AEquipment_IsAttachableToWeapon_Params params;
	params.WeaponIndex = WeaponIndex;
	params.AttachableItem = AttachableItem;
	params.bOnlyFree = bOnlyFree;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* AEquipment::GetOwnerCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19952);

	AEquipment_GetOwnerCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.GetItemCountByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ItemClass                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AEquipment::GetItemCountByClass(class UClass* ItemClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19949);

	AEquipment_GetItemCountByClass_Params params;
	params.ItemClass = ItemClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.GetItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEquipPosition          Position                       (Parm)
// class UEquipableItem*          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEquipableItem* AEquipment::GetItem(const struct FEquipPosition& Position)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19946);

	AEquipment_GetItem_Params params;
	params.Position = Position;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.GetInventoryFacade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInventoryFacade*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AInventoryFacade* AEquipment::GetInventoryFacade()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19944);

	AEquipment_GetInventoryFacade_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.FindPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItem*                   Item                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FEquipPosition          ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEquipPosition AEquipment::FindPosition(class UItem* Item)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19941);

	AEquipment_FindPosition_Params params;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.FindEquipPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipSlotID                   SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bOnlyFree                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEquipPosition          ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEquipPosition AEquipment::FindEquipPosition(EEquipSlotID SlotID, bool bOnlyFree)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19936);

	AEquipment_FindEquipPosition_Params params;
	params.SlotID = SlotID;
	params.bOnlyFree = bOnlyFree;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.FindEquipableWeaponPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEquipableItem*          EquipableItem                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)
// struct FEquipPosition          ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEquipPosition AEquipment::FindEquipableWeaponPosition(class UEquipableItem* EquipableItem, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19932);

	AEquipment_FindEquipableWeaponPosition_Params params;
	params.EquipableItem = EquipableItem;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.FindAttachableWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAttachableItem*         AttachableItem                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AEquipment::FindAttachableWeaponIndex(class UAttachableItem* AttachableItem, const struct FString& Options)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19928);

	AEquipment_FindAttachableWeaponIndex_Params params;
	params.AttachableItem = AttachableItem;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.EquipPositionToWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEquipPosition          Position                       (Parm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AEquipment::EquipPositionToWeaponIndex(const struct FEquipPosition& Position)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19925);

	AEquipment_EquipPositionToWeaponIndex_Params params;
	params.Position = Position;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.EquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FEquipPosition          Position                       (Parm)
// class UEquipableItem*          Item                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bCheckViaCanEquipTo            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEquipment::EquipItem(const struct FEquipPosition& Position, class UEquipableItem* Item, bool bCheckViaCanEquipTo, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19919);

	AEquipment_EquipItem_Params params;
	params.Position = Position;
	params.Item = Item;
	params.bCheckViaCanEquipTo = bCheckViaCanEquipTo;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Equipment.DropItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition          Position                       (Parm)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsForce                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AEquipment::DropItem(const struct FEquipPosition& Position, const struct FName& ItemClassForVerify, bool bIsForce, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19914);

	AEquipment_DropItem_Params params;
	params.Position = Position;
	params.ItemClassForVerify = ItemClassForVerify;
	params.bIsForce = bIsForce;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Equipment.DropAttachedItemAll
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition          EquipPosition                  (Parm)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AEquipment::DropAttachedItemAll(const struct FEquipPosition& EquipPosition, const struct FName& ItemClassForVerify, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19910);

	AEquipment_DropAttachedItemAll_Params params;
	params.EquipPosition = EquipPosition;
	params.ItemClassForVerify = ItemClassForVerify;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Equipment.DropAttachedItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition          EquipPosition                  (Parm)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// EWeaponAttachmentSlotID        SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AEquipment::DropAttachedItem(const struct FEquipPosition& EquipPosition, const struct FName& ItemClassForVerify, EWeaponAttachmentSlotID SlotID, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19904);

	AEquipment_DropAttachedItem_Params params;
	params.EquipPosition = EquipPosition;
	params.ItemClassForVerify = ItemClassForVerify;
	params.SlotID = SlotID;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Equipment.DetachItemAll
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition          EquipPosition                  (Parm)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AEquipment::DetachItemAll(const struct FEquipPosition& EquipPosition, const struct FName& ItemClassForVerify, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19900);

	AEquipment_DetachItemAll_Params params;
	params.EquipPosition = EquipPosition;
	params.ItemClassForVerify = ItemClassForVerify;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Equipment.DetachItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition          EquipPosition                  (Parm)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// EWeaponAttachmentSlotID        SlotID                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AEquipment::DetachItem(const struct FEquipPosition& EquipPosition, const struct FName& ItemClassForVerify, EWeaponAttachmentSlotID SlotID, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19894);

	AEquipment_DetachItem_Params params;
	params.EquipPosition = EquipPosition;
	params.ItemClassForVerify = ItemClassForVerify;
	params.SlotID = SlotID;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Inventory.UseItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)

void AInventory::UseItem(int Index, const struct FName& ItemClassForVerify)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20051);

	AInventory_UseItem_Params params;
	params.Index = Index;
	params.ItemClassForVerify = ItemClassForVerify;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Inventory.OnFinishUseCast
// (Final, Native, Public)
// Parameters:
// class UObject*                 CastObject                     (Parm, ZeroConstructor, IsPlainOldData)

void AInventory::OnFinishUseCast(class UObject* CastObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20049);

	AInventory_OnFinishUseCast_Params params;
	params.CastObject = CastObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Inventory.Items_RepNotify
// (Final, Native, Protected)

void AInventory::Items_RepNotify()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20048);

	AInventory_Items_RepNotify_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Inventory.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* AInventory::GetOwnerCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20046);

	AInventory_GetOwnerCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.GetMaxSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AInventory::GetMaxSpace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20044);

	AInventory_GetMaxSpace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.GetItemCountByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ItemClass                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AInventory::GetItemCountByClass(class UClass* ItemClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20041);

	AInventory_GetItemCountByClass_Params params;
	params.ItemClass = ItemClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.GetItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AInventory::GetItemCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20039);

	AInventory_GetItemCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.GetInventoryFacade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInventoryFacade*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AInventoryFacade* AInventory::GetInventoryFacade()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20037);

	AInventory_GetInventoryFacade_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.GetCurrentSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AInventory::GetCurrentSpace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20035);

	AInventory_GetCurrentSpace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.GetAllItemsByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ItemSuperClass                 (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FInventoryItem>  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FInventoryItem> AInventory::GetAllItemsByType(class UClass* ItemSuperClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20031);

	AInventory_GetAllItemsByType_Params params;
	params.ItemSuperClass = ItemSuperClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.GetAllItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FInventoryItem>  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FInventoryItem> AInventory::GetAllItems()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20028);

	AInventory_GetAllItems_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.GetAdditionalMaxCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItem*                   Item                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AInventory::GetAdditionalMaxCount(class UItem* Item)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20025);

	AInventory_GetAdditionalMaxCount_Params params;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.FindItemIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItem*                   Item                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AInventory::FindItemIndex(class UItem* Item)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20022);

	AInventory_FindItemIndex_Params params;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.FindItemHasMinStack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  ItemClass                      (Parm, ZeroConstructor, IsPlainOldData)
// class UItem*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UItem* AInventory::FindItemHasMinStack(class UClass* ItemClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20019);

	AInventory_FindItemHasMinStack_Params params;
	params.ItemClass = ItemClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.FindItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  ItemClass                      (Parm, ZeroConstructor, IsPlainOldData)
// class UItem*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UItem* AInventory::FindItem(class UClass* ItemClass)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20016);

	AInventory_FindItem_Params params;
	params.ItemClass = ItemClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.EquipOrDropItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AInventory::EquipOrDropItem(int Index, const struct FName& ItemClassForVerify, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20012);

	AInventory_EquipOrDropItem_Params params;
	params.Index = Index;
	params.ItemClassForVerify = ItemClassForVerify;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Inventory.EquipItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AInventory::EquipItem(int Index, const struct FName& ItemClassForVerify, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20008);

	AInventory_EquipItem_Params params;
	params.Index = Index;
	params.ItemClassForVerify = ItemClassForVerify;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Inventory.DropItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AInventory::DropItem(int Index, const struct FName& ItemClassForVerify, const struct FString& Options, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20003);

	AInventory_DropItem_Params params;
	params.Index = Index;
	params.ItemClassForVerify = ItemClassForVerify;
	params.Options = Options;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Inventory.ConsumeItemByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  ItemClass                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            Count                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AInventory::ConsumeItemByClass(class UClass* ItemClass, int Count)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19999);

	AInventory_ConsumeItemByClass_Params params;
	params.ItemClass = ItemClass;
	params.Count = Count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Inventory.ClientBroadcastNoBagSpaceEvent
// (Net, Native, Event, Public, NetClient)

void AInventory::ClientBroadcastNoBagSpaceEvent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19998);

	AInventory_ClientBroadcastNoBagSpaceEvent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Inventory.AttachOrDropItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AInventory::AttachOrDropItem(int Index, const struct FName& ItemClassForVerify, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19994);

	AInventory_AttachOrDropItem_Params params;
	params.Index = Index;
	params.ItemClassForVerify = ItemClassForVerify;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Inventory.AttachItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ItemClassForVerify             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEquipPosition          EquipPosition                  (Parm)
// bool                           bSoundPlay                     (Parm, ZeroConstructor, IsPlainOldData)

void AInventory::AttachItem(int Index, const struct FName& ItemClassForVerify, const struct FEquipPosition& EquipPosition, bool bSoundPlay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(19989);

	AInventory_AttachItem_Params params;
	params.Index = Index;
	params.ItemClassForVerify = ItemClassForVerify;
	params.EquipPosition = EquipPosition;
	params.bSoundPlay = bSoundPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemExplorerProxy.PropagateUpdateItemList
// (Final, Native, Private)

void AItemExplorerProxy::PropagateUpdateItemList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20064);

	AItemExplorerProxy_PropagateUpdateItemList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemExplorerProxy.PropagateDestroyContextMenuWidget
// (Final, Native, Private)

void AItemExplorerProxy::PropagateDestroyContextMenuWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20063);

	AItemExplorerProxy_PropagateDestroyContextMenuWidget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemExplorerProxy.PropagateCreateAndShowContextMenuWidget
// (Final, Native, Private)
// Parameters:
// TScriptInterface<class USlotContainerInterface> Param                          (Parm, ZeroConstructor, IsPlainOldData)

void AItemExplorerProxy::PropagateCreateAndShowContextMenuWidget(const TScriptInterface<class USlotContainerInterface>& Param)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20061);

	AItemExplorerProxy_PropagateCreateAndShowContextMenuWidget_Params params;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemExplorerProxy.Pop
// (Final, Native, Public, BlueprintCallable)

void AItemExplorerProxy::Pop()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20060);

	AItemExplorerProxy_Pop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ItemExplorerProxy.IsBaseExplorer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AItemExplorerProxy::IsBaseExplorer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20058);

	AItemExplorerProxy_IsBaseExplorer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CarePackageItem.IsPickupedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ACarePackageItem::IsPickupedItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20068);

	ACarePackageItem_IsPickupedItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CarePackageItem.IsFalling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ACarePackageItem::IsFalling()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20066);

	ACarePackageItem_IsFalling_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.ServerSetShowMapMarker
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                           bNewShowMapMarker              (Parm, ZeroConstructor, IsPlainOldData)

void ATeam::ServerSetShowMapMarker(bool bNewShowMapMarker)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20149);

	ATeam_ServerSetShowMapMarker_Params params;
	params.bNewShowMapMarker = bNewShowMapMarker;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Team.ServerSetMapMarkerPosition
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// struct FVector2D               NewMapMarkerPosition           (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATeam::ServerSetMapMarkerPosition(const struct FVector2D& NewMapMarkerPosition)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20147);

	ATeam_ServerSetMapMarkerPosition_Params params;
	params.NewMapMarkerPosition = NewMapMarkerPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Team.OnRep_Dying
// (Final, Native, Public)
// Parameters:
// bool                           bLastDying                     (Parm, ZeroConstructor, IsPlainOldData)

void ATeam::OnRep_Dying(bool bLastDying)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20145);

	ATeam_OnRep_Dying_Params params;
	params.bLastDying = bLastDying;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.Team.IsShowMapMarker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATeam::IsShowMapMarker()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20143);

	ATeam_IsShowMapMarker_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.IsQuitter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATeam::IsQuitter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20141);

	ATeam_IsQuitter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.IsGroggying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATeam::IsGroggying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20139);

	ATeam_IsGroggying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.IsDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATeam::IsDying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20137);

	ATeam_IsDying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetTslCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ATeam::GetTslCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20135);

	ATeam_GetTslCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetRideVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeamVehicleType               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ETeamVehicleType ATeam::GetRideVehicle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20132);

	ATeam_GetRideVehicle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetPlayerUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATeam::GetPlayerUniqueId()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20130);

	ATeam_GetPlayerUniqueId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetPlayerRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATeam::GetPlayerRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20128);

	ATeam_GetPlayerRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATeam::GetPlayerName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20126);

	ATeam_GetPlayerName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetPlayerLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATeam::GetPlayerLocation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20124);

	ATeam_GetPlayerLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetMemberNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATeam::GetMemberNumber()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20122);

	ATeam_GetMemberNumber_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetMapMarkerPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D ATeam::GetMapMarkerPosition()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20120);

	ATeam_GetMapMarkerPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetHealthMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATeam::GetHealthMax()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20118);

	ATeam_GetHealthMax_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATeam::GetHealth()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20116);

	ATeam_GetHealth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetGroggyHealthMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATeam::GetGroggyHealthMax()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20114);

	ATeam_GetGroggyHealthMax_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.Team.GetGroggyHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATeam::GetGroggyHealth()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20112);

	ATeam_GetGroggyHealth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslAccessoryComponent.SetPhysicsSimulation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bSimulatePhysics               (Parm, ZeroConstructor, IsPlainOldData)

void UTslAccessoryComponent::SetPhysicsSimulation(bool bSimulatePhysics)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20176);

	UTslAccessoryComponent_SetPhysicsSimulation_Params params;
	params.bSimulatePhysics = bSimulatePhysics;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAccessoryComponent.InitSetupComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bSimulatePhysics               (Parm, ZeroConstructor, IsPlainOldData)

void UTslAccessoryComponent::InitSetupComponent(bool bSimulatePhysics)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20174);

	UTslAccessoryComponent_InitSetupComponent_Params params;
	params.bSimulatePhysics = bSimulatePhysics;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAIController.ShootEnemy
// (Final, Native, Public, BlueprintCallable)

void ATslAIController::ShootEnemy()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20197);

	ATslAIController_ShootEnemy_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAIController.FindClosestEnemyWithLOS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*           ExcludeEnemy                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslAIController::FindClosestEnemyWithLOS(class ATslCharacter* ExcludeEnemy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20194);

	ATslAIController_FindClosestEnemyWithLOS_Params params;
	params.ExcludeEnemy = ExcludeEnemy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslAIController.FindClosestEnemy
// (Final, Native, Public, BlueprintCallable)

void ATslAIController::FindClosestEnemy()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20193);

	ATslAIController_FindClosestEnemy_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.AircraftCarePackage.IsPlayInEditor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AAircraftCarePackage::IsPlayInEditor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20208);

	AAircraftCarePackage_IsPlayInEditor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TransportAircraftVehicle.OnRide
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATransportAircraftVehicle::OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20238);

	ATransportAircraftVehicle_OnRide_Params params;
	params.Rider = Rider;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TransportAircraftVehicle.OnRep_IsVisible
// (Final, Native, Private)

void ATransportAircraftVehicle::OnRep_IsVisible()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20237);

	ATransportAircraftVehicle_OnRep_IsVisible_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TransportAircraftVehicle.OnLocalPlayerRide
// (Event, Public, BlueprintEvent)

void ATransportAircraftVehicle::OnLocalPlayerRide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20236);

	ATransportAircraftVehicle_OnLocalPlayerRide_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TransportAircraftVehicle.OnLocalPlayerLeave
// (Event, Public, BlueprintEvent)

void ATransportAircraftVehicle::OnLocalPlayerLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20235);

	ATransportAircraftVehicle_OnLocalPlayerLeave_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TransportAircraftVehicle.OnLeave
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATransportAircraftVehicle::OnLeave(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20232);

	ATransportAircraftVehicle_OnLeave_Params params;
	params.Rider = Rider;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TransportAircraftVehicle.OnInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)

void ATransportAircraftVehicle::OnInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20230);

	ATransportAircraftVehicle_OnInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TransportAircraftVehicle.IsInEjectionArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATransportAircraftVehicle::IsInEjectionArea()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20228);

	ATransportAircraftVehicle_IsInEjectionArea_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TransportAircraftVehicle.GetTotalRiderCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATransportAircraftVehicle::GetTotalRiderCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20226);

	ATransportAircraftVehicle_GetTotalRiderCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TransportAircraftVehicle.GetRiderCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATransportAircraftVehicle::GetRiderCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20224);

	ATransportAircraftVehicle_GetRiderCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TransportAircraftVehicle.EnterAtEjectionArea
// (Final, Native, Public)

void ATransportAircraftVehicle::EnterAtEjectionArea()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20223);

	ATransportAircraftVehicle_EnterAtEjectionArea_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TransportAircraftVehicle.EjectAll
// (Final, Native, Public)

void ATransportAircraftVehicle::EjectAll()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20222);

	ATransportAircraftVehicle_EjectAll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TransportAircraftVehicle.AllowInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Character                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATransportAircraftVehicle::AllowInteractBy(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20219);

	ATransportAircraftVehicle_AllowInteractBy_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.UpdateWheelSound
// (Native, Public, BlueprintCallable)

void ATslWheeledVehicle::UpdateWheelSound()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20329);

	ATslWheeledVehicle_UpdateWheelSound_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.UpdateWheelCaching
// (Native, Public, BlueprintCallable)

void ATslWheeledVehicle::UpdateWheelCaching()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20328);

	ATslWheeledVehicle_UpdateWheelCaching_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.UpdateBasicInfoCaching
// (Native, Public, BlueprintCallable)

void ATslWheeledVehicle::UpdateBasicInfoCaching()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20327);

	ATslWheeledVehicle_UpdateBasicInfoCaching_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.UnBindCallbackToHUD
// (Final, Native, Protected)
// Parameters:
// class ATslPlayerController*    InController                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslWheeledVehicle::UnBindCallbackToHUD(class ATslPlayerController* InController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20325);

	ATslWheeledVehicle_UnBindCallbackToHUD_Params params;
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.SetAirControlPitchInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InInput                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslWheeledVehicle::SetAirControlPitchInput(float InInput)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20323);

	ATslWheeledVehicle_SetAirControlPitchInput_Params params;
	params.InInput = InInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.ServerSetBoosting
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           bNewBoosting                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslWheeledVehicle::ServerSetBoosting(bool bNewBoosting)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20321);

	ATslWheeledVehicle_ServerSetBoosting_Params params;
	params.bNewBoosting = bNewBoosting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnVehicleEjected
// (Native, Public)

void ATslWheeledVehicle::OnVehicleEjected()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20320);

	ATslWheeledVehicle_OnVehicleEjected_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnStopHandbrakePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::OnStopHandbrakePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20318);

	ATslWheeledVehicle_OnStopHandbrakePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.OnStopHandbrake
// (Final, Native, Public)

void ATslWheeledVehicle::OnStopHandbrake()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20317);

	ATslWheeledVehicle_OnStopHandbrake_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnStopBoostingPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::OnStopBoostingPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20315);

	ATslWheeledVehicle_OnStopBoostingPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.OnStopBoosting
// (Final, Native, Public)

void ATslWheeledVehicle::OnStopBoosting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20314);

	ATslWheeledVehicle_OnStopBoosting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnStartHandbrakePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::OnStartHandbrakePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20312);

	ATslWheeledVehicle_OnStartHandbrakePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.OnStartHandbrake
// (Final, Native, Public)

void ATslWheeledVehicle::OnStartHandbrake()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20311);

	ATslWheeledVehicle_OnStartHandbrake_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnStartBoostingPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::OnStartBoostingPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20309);

	ATslWheeledVehicle_OnStartBoostingPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.OnStartBoosting
// (Final, Native, Public)

void ATslWheeledVehicle::OnStartBoosting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20308);

	ATslWheeledVehicle_OnStartBoosting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnRide
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslWheeledVehicle::OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20305);

	ATslWheeledVehicle_OnRide_Params params;
	params.Rider = Rider;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnPostDriverRide
// (Native, Public)

void ATslWheeledVehicle::OnPostDriverRide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20304);

	ATslWheeledVehicle_OnPostDriverRide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnPostDriverLeave
// (Native, Public)

void ATslWheeledVehicle::OnPostDriverLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20303);

	ATslWheeledVehicle_OnPostDriverLeave_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnLeave
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslWheeledVehicle::OnLeave(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20300);

	ATslWheeledVehicle_OnLeave_Params params;
	params.Rider = Rider;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnCharacterHit
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*           HitCharacter                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          HitDamage                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslWheeledVehicle::OnCharacterHit(class ATslCharacter* HitCharacter, float HitDamage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20297);

	ATslWheeledVehicle_OnCharacterHit_Params params;
	params.HitCharacter = HitCharacter;
	params.HitDamage = HitDamage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnBreak
// (Final, Native, Private)

void ATslWheeledVehicle::OnBreak()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20296);

	ATslWheeledVehicle_OnBreak_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.OnBlockingWidgetOpened
// (Final, Native, Protected)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslWheeledVehicle::OnBlockingWidgetOpened(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20294);

	ATslWheeledVehicle_OnBlockingWidgetOpened_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.NotifyHandbrake
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                           bPressed                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslWheeledVehicle::NotifyHandbrake(bool bPressed)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20292);

	ATslWheeledVehicle_NotifyHandbrake_Params params;
	params.bPressed = bPressed;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.MulticastCharacterHitEffects
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:
// class ATslCharacter*           CharacterHit                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          HitDamage                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslWheeledVehicle::MulticastCharacterHitEffects(class ATslCharacter* CharacterHit, float HitDamage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20289);

	ATslWheeledVehicle_MulticastCharacterHitEffects_Params params;
	params.CharacterHit = CharacterHit;
	params.HitDamage = HitDamage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.IsSunken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::IsSunken()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20287);

	ATslWheeledVehicle_IsSunken_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsStablizeOverrideActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::IsStablizeOverrideActive()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20285);

	ATslWheeledVehicle_IsStablizeOverrideActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsStabilizeOverrideEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::IsStabilizeOverrideEnabled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20283);

	ATslWheeledVehicle_IsStabilizeOverrideEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsInWaterVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::IsInWaterVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20281);

	ATslWheeledVehicle_IsInWaterVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsEnabledOptimizeTick
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::IsEnabledOptimizeTick()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20279);

	ATslWheeledVehicle_IsEnabledOptimizeTick_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsBoosting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWheeledVehicle::IsBoosting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20277);

	ATslWheeledVehicle_IsBoosting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.GetTslVehicleMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslWheeledVehicleMovement* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslWheeledVehicleMovement* ATslWheeledVehicle::GetTslVehicleMovement()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20275);

	ATslWheeledVehicle_GetTslVehicleMovement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.GetSteeringInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWheeledVehicle::GetSteeringInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20273);

	ATslWheeledVehicle_GetSteeringInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.GetCurrentWaterSurfaceZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWheeledVehicle::GetCurrentWaterSurfaceZ()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20271);

	ATslWheeledVehicle_GetCurrentWaterSurfaceZ_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.GetBuffComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBuffComponet*           ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UBuffComponet* ATslWheeledVehicle::GetBuffComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20269);

	ATslWheeledVehicle_GetBuffComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.GetAirControlPitchInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWheeledVehicle::GetAirControlPitchInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20267);

	ATslWheeledVehicle_GetAirControlPitchInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.BindCallbackToHUD
// (Final, Native, Protected)
// Parameters:
// class ATslPlayerController*    InController                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslWheeledVehicle::BindCallbackToHUD(class ATslPlayerController* InController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20265);

	ATslWheeledVehicle_BindCallbackToHUD_Params params;
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.ActivationTriggerEndOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                  Other                          (Parm, ZeroConstructor, IsPlainOldData)
// class UPrimitiveComponent*     OtherComp                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// int                            OtherBodyIndex                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslWheeledVehicle::ActivationTriggerEndOverlap(class AActor* Other, class UPrimitiveComponent* OtherComp, int OtherBodyIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20261);

	ATslWheeledVehicle_ActivationTriggerEndOverlap_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicle.ActivationTriggerBeginOverlap
// (Final, Native, Protected, HasOutParms)
// Parameters:
// class AActor*                  Other                          (Parm, ZeroConstructor, IsPlainOldData)
// class UPrimitiveComponent*     OtherComp                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// int                            OtherBodyIndex                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFromSweep                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FHitResult              OverlapInfo                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void ATslWheeledVehicle::ActivationTriggerBeginOverlap(class AActor* Other, class UPrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20255);

	ATslWheeledVehicle_ActivationTriggerBeginOverlap_Params params;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;
	params.bFromSweep = bFromSweep;
	params.OverlapInfo = OverlapInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicle.UnBindCallbackToHUD
// (Final, Native, Protected)
// Parameters:
// class ATslPlayerController*    InController                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslFloatingVehicle::UnBindCallbackToHUD(class ATslPlayerController* InController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20436);

	ATslFloatingVehicle_UnBindCallbackToHUD_Params params;
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicle.OnStopBoostingPad
// (Final, Native, Private)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslFloatingVehicle::OnStopBoostingPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20434);

	ATslFloatingVehicle_OnStopBoostingPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.OnStopBoosting
// (Final, Native, Private)

void ATslFloatingVehicle::OnStopBoosting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20433);

	ATslFloatingVehicle_OnStopBoosting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicle.OnStartBoostingPad
// (Final, Native, Private)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslFloatingVehicle::OnStartBoostingPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20431);

	ATslFloatingVehicle_OnStartBoostingPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.OnStartBoosting
// (Final, Native, Private)

void ATslFloatingVehicle::OnStartBoosting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20430);

	ATslFloatingVehicle_OnStartBoosting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicle.OnRide
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslFloatingVehicle::OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20427);

	ATslFloatingVehicle_OnRide_Params params;
	params.Rider = Rider;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicle.OnPostDriverRide
// (Native, Protected)

void ATslFloatingVehicle::OnPostDriverRide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20426);

	ATslFloatingVehicle_OnPostDriverRide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicle.OnPostDriverLeave
// (Native, Protected)

void ATslFloatingVehicle::OnPostDriverLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20425);

	ATslFloatingVehicle_OnPostDriverLeave_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicle.OnLeave
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslFloatingVehicle::OnLeave(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20422);

	ATslFloatingVehicle_OnLeave_Params params;
	params.Rider = Rider;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicle.OnBlockingWidgetOpened
// (Final, Native, Protected)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslFloatingVehicle::OnBlockingWidgetOpened(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20420);

	ATslFloatingVehicle_OnBlockingWidgetOpened_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicle.IsBoosting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslFloatingVehicle::IsBoosting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20418);

	ATslFloatingVehicle_IsBoosting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.GetVehicleEngineImmersionDepth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslFloatingVehicle::GetVehicleEngineImmersionDepth()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20416);

	ATslFloatingVehicle_GetVehicleEngineImmersionDepth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.GetVehicleAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslFloatingVehicle::GetVehicleAcceleration()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20414);

	ATslFloatingVehicle_GetVehicleAcceleration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.GetSteerYawAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslFloatingVehicle::GetSteerYawAngle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20412);

	ATslFloatingVehicle_GetSteerYawAngle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.GetMaxSteerYawAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslFloatingVehicle::GetMaxSteerYawAngle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20410);

	ATslFloatingVehicle_GetMaxSteerYawAngle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.BindCallbackToHUD
// (Final, Native, Protected)
// Parameters:
// class ATslPlayerController*    InController                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslFloatingVehicle::BindCallbackToHUD(class ATslPlayerController* InController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20408);

	ATslFloatingVehicle_BindCallbackToHUD_Params params;
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicleMovement.SetSimulateVehicle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bSimulate                      (Parm, ZeroConstructor, IsPlainOldData)

void UTslWheeledVehicleMovement::SetSimulateVehicle(bool bSimulate)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20633);

	UTslWheeledVehicleMovement_SetSimulateVehicle_Params params;
	params.bSimulate = bSimulate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicleMovement.ServerUpdateAdditionalState
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int                            TargetGear                     (Parm, ZeroConstructor, IsPlainOldData)

void UTslWheeledVehicleMovement::ServerUpdateAdditionalState(int TargetGear)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20631);

	UTslWheeledVehicleMovement_ServerUpdateAdditionalState_Params params;
	params.TargetGear = TargetGear;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicleMovement.Server_SetMovementParameters
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// float                          InThrottle                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          InSteer                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          InBreak                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          InHandbrake                    (Parm, ZeroConstructor, IsPlainOldData)
// int                            Gear                           (Parm, ZeroConstructor, IsPlainOldData)

void UTslWheeledVehicleMovement::Server_SetMovementParameters(float InThrottle, float InSteer, float InBreak, float InHandbrake, int Gear)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20625);

	UTslWheeledVehicleMovement_Server_SetMovementParameters_Params params;
	params.InThrottle = InThrottle;
	params.InSteer = InSteer;
	params.InBreak = InBreak;
	params.InHandbrake = InHandbrake;
	params.Gear = Gear;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicleMovement.ProcessCustomTransmission
// (Final, Native, Protected)
// Parameters:
// float                          InVelocity                     (Parm, ZeroConstructor, IsPlainOldData)

void UTslWheeledVehicleMovement::ProcessCustomTransmission(float InVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20623);

	UTslWheeledVehicleMovement_ProcessCustomTransmission_Params params;
	params.InVelocity = InVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicleMovement.OnDriverRide
// (Final, Native, Public)

void UTslWheeledVehicleMovement::OnDriverRide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20622);

	UTslWheeledVehicleMovement_OnDriverRide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicleMovement.OnDriverLeave
// (Final, Native, Public)

void UTslWheeledVehicleMovement::OnDriverLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20621);

	UTslWheeledVehicleMovement_OnDriverLeave_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicleMovement.OnBreak
// (Final, Native, Public)

void UTslWheeledVehicleMovement::OnBreak()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20620);

	UTslWheeledVehicleMovement_OnBreak_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWheeledVehicleMovement.IsSimulatingVehicle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslWheeledVehicleMovement::IsSimulatingVehicle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20618);

	UTslWheeledVehicleMovement_IsSimulatingVehicle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelWaterDepth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslWheeledVehicleMovement::GetWheelWaterDepth(int Index)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20615);

	UTslWheeledVehicleMovement_GetWheelWaterDepth_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelSuspensionMaxRaise
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslWheeledVehicleMovement::GetWheelSuspensionMaxRaise(int Index)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20612);

	UTslWheeledVehicleMovement_GetWheelSuspensionMaxRaise_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelSuspensionMaxDrop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslWheeledVehicleMovement::GetWheelSuspensionMaxDrop(int Index)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20609);

	UTslWheeledVehicleMovement_GetWheelSuspensionMaxDrop_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelRotationSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslWheeledVehicleMovement::GetWheelRotationSpeed(int Index)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20606);

	UTslWheeledVehicleMovement_GetWheelRotationSpeed_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelHealthPercentages
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<float>                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<float> UTslWheeledVehicleMovement::GetWheelHealthPercentages()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20603);

	UTslWheeledVehicleMovement_GetWheelHealthPercentages_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelContactType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinVelocity                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinSkid                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinSpin                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          SuspOffsetForContact           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<EWheelContactType> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<EWheelContactType> UTslWheeledVehicleMovement::GetWheelContactType(int Index, float MinVelocity, float MinSkid, float MinSpin, float SuspOffsetForContact)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20596);

	UTslWheeledVehicleMovement_GetWheelContactType_Params params;
	params.Index = Index;
	params.MinVelocity = MinVelocity;
	params.MinSkid = MinSkid;
	params.MinSpin = MinSpin;
	params.SuspOffsetForContact = SuspOffsetForContact;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelContactSurfaceMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// class UPhysicalMaterial*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UPhysicalMaterial* UTslWheeledVehicleMovement::GetWheelContactSurfaceMaterial(int Index)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20593);

	UTslWheeledVehicleMovement_GetWheelContactSurfaceMaterial_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelContactData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinVelocity                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinSkid                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinSpin                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          SuspOffsetForContact           (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinBrake                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinRotationSpeed               (Parm, ZeroConstructor, IsPlainOldData)
// struct FWheelContactData       ReturnValue                    (Parm, OutParm, ReturnParm)

struct FWheelContactData UTslWheeledVehicleMovement::GetWheelContactData(int Index, float MinVelocity, float MinSkid, float MinSpin, float SuspOffsetForContact, float MinBrake, float MinRotationSpeed)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20584);

	UTslWheeledVehicleMovement_GetWheelContactData_Params params;
	params.Index = Index;
	params.MinVelocity = MinVelocity;
	params.MinSkid = MinSkid;
	params.MinSpin = MinSpin;
	params.SuspOffsetForContact = SuspOffsetForContact;
	params.MinBrake = MinBrake;
	params.MinRotationSpeed = MinRotationSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetThrottleInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslWheeledVehicleMovement::GetThrottleInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20582);

	UTslWheeledVehicleMovement_GetThrottleInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetSteeringInputClamped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslWheeledVehicleMovement::GetSteeringInputClamped()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20580);

	UTslWheeledVehicleMovement_GetSteeringInputClamped_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetSteeringInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslWheeledVehicleMovement::GetSteeringInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20578);

	UTslWheeledVehicleMovement_GetSteeringInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetHandbrakeInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslWheeledVehicleMovement::GetHandbrakeInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20576);

	UTslWheeledVehicleMovement_GetHandbrakeInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetBrakeInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslWheeledVehicleMovement::GetBrakeInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20574);

	UTslWheeledVehicleMovement_GetBrakeInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.ClientPunctureTire
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// int                            WheelIndex                     (Parm, ZeroConstructor, IsPlainOldData)

void UTslWheeledVehicleMovement::ClientPunctureTire(int WheelIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20572);

	UTslWheeledVehicleMovement_ClientPunctureTire_Params params;
	params.WheelIndex = WheelIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicleMovement.ServerUpdateInput
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                          InForwardInput                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          InRotationInput                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bInIsBoosting                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslFloatingVehicleMovement::ServerUpdateInput(float InForwardInput, float InRotationInput, bool bInIsBoosting)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20656);

	UTslFloatingVehicleMovement_ServerUpdateInput_Params params;
	params.InForwardInput = InForwardInput;
	params.InRotationInput = InRotationInput;
	params.bInIsBoosting = bInIsBoosting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicleMovement.OnDriverLeave
// (Final, Native, Private)

void UTslFloatingVehicleMovement::OnDriverLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20655);

	UTslFloatingVehicleMovement_OnDriverLeave_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFloatingVehicleMovement.IsBoosting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFloatingVehicleMovement::IsBoosting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20653);

	UTslFloatingVehicleMovement_IsBoosting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.GetRotationYawAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslFloatingVehicleMovement::GetRotationYawAngle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20651);

	UTslFloatingVehicleMovement_GetRotationYawAngle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.GetMaxRotationYawAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslFloatingVehicleMovement::GetMaxRotationYawAngle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20649);

	UTslFloatingVehicleMovement_GetMaxRotationYawAngle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.GetMaxAcceleration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslFloatingVehicleMovement::GetMaxAcceleration()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20647);

	UTslFloatingVehicleMovement_GetMaxAcceleration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.GetCalculatedAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UTslFloatingVehicleMovement::GetCalculatedAcceleration()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20645);

	UTslFloatingVehicleMovement_GetCalculatedAcceleration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.GetAcceleration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslFloatingVehicleMovement::GetAcceleration()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20643);

	UTslFloatingVehicleMovement_GetAcceleration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.TraceSphereForVaulting
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Start                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FHitResult              OutHit                         (Parm, OutParm, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslCharacterMovement::TraceSphereForVaulting(const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<EDrawDebugTrace> DrawDebugType, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FHitResult* OutHit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20992);

	UTslCharacterMovement_TraceSphereForVaulting_Params params;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.DrawDebugType = DrawDebugType;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.TraceLineForVaulting
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Start                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FHitResult              OutHit                         (Parm, OutParm, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslCharacterMovement::TraceLineForVaulting(const struct FVector& Start, const struct FVector& End, TEnumAsByte<EDrawDebugTrace> DrawDebugType, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FHitResult* OutHit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20983);

	UTslCharacterMovement_TraceLineForVaulting_Params params;
	params.Start = Start;
	params.End = End;
	params.DrawDebugType = DrawDebugType;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.TraceCapsuleForVaulting
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Start                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FHitResult              OutHit                         (Parm, OutParm, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslCharacterMovement::TraceCapsuleForVaulting(const struct FVector& Start, const struct FVector& End, TEnumAsByte<EDrawDebugTrace> DrawDebugType, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FHitResult* OutHit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20974);

	UTslCharacterMovement_TraceCapsuleForVaulting_Params params;
	params.Start = Start;
	params.End = End;
	params.DrawDebugType = DrawDebugType;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.StartVaultingTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVaultingTask           InVaultTask                    (Parm)

void UTslCharacterMovement::StartVaultingTask(const struct FVaultingTask& InVaultTask)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20972);

	UTslCharacterMovement_StartVaultingTask_Params params;
	params.InVaultTask = InVaultTask;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacterMovement.PredictCapsulePathForVaulting
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult              OutHit                         (Parm, OutParm, IsPlainOldData)
// TArray<struct FVector>         OutPathPositions               (Parm, OutParm, ZeroConstructor)
// struct FVector                 OutLastTraceDestination        (Parm, OutParm, IsPlainOldData)
// struct FVector                 StartPos                       (Parm, IsPlainOldData)
// struct FVector                 LaunchVelocity                 (Parm, IsPlainOldData)
// TEnumAsByte<EDrawDebugTrace>   DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawDebugTime                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          CapsuleRadiusOverride          (Parm, ZeroConstructor, IsPlainOldData)
// float                          CapsuleHalfHeightOverride      (Parm, ZeroConstructor, IsPlainOldData)
// float                          SimFrequency                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxSimTime                     (Parm, ZeroConstructor, IsPlainOldData)

void UTslCharacterMovement::PredictCapsulePathForVaulting(const struct FVector& StartPos, const struct FVector& LaunchVelocity, TEnumAsByte<EDrawDebugTrace> DrawDebugType, float DrawDebugTime, float CapsuleRadiusOverride, float CapsuleHalfHeightOverride, float SimFrequency, float MaxSimTime, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20959);

	UTslCharacterMovement_PredictCapsulePathForVaulting_Params params;
	params.StartPos = StartPos;
	params.LaunchVelocity = LaunchVelocity;
	params.DrawDebugType = DrawDebugType;
	params.DrawDebugTime = DrawDebugTime;
	params.CapsuleRadiusOverride = CapsuleRadiusOverride;
	params.CapsuleHalfHeightOverride = CapsuleHalfHeightOverride;
	params.SimFrequency = SimFrequency;
	params.MaxSimTime = MaxSimTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;
	if (OutPathPositions != nullptr)
		*OutPathPositions = params.OutPathPositions;
	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = params.OutLastTraceDestination;
}


// Function TslGame.TslCharacterMovement.LocalHandleVault_CP
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                 VaultStart                     (Parm, IsPlainOldData)
// struct FVector                 VaultApex                      (Parm, IsPlainOldData)
// struct FVector                 VaultApexAdditive              (Parm, IsPlainOldData)
// struct FVector                 VaultEnd                       (Parm, IsPlainOldData)
// bool                           bIsClimb                       (Parm, ZeroConstructor, IsPlainOldData)
// EVaultAnimType                 VaultAnimType                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEndToFall                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Direction                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          PlayerVelocity                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          DistanceFromObject             (Parm, ZeroConstructor, IsPlainOldData)

void UTslCharacterMovement::LocalHandleVault_CP(const struct FVector& VaultStart, const struct FVector& VaultApex, const struct FVector& VaultApexAdditive, const struct FVector& VaultEnd, bool bIsClimb, EVaultAnimType VaultAnimType, bool bEndToFall, float Direction, float PlayerVelocity, float DistanceFromObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20947);

	UTslCharacterMovement_LocalHandleVault_CP_Params params;
	params.VaultStart = VaultStart;
	params.VaultApex = VaultApex;
	params.VaultApexAdditive = VaultApexAdditive;
	params.VaultEnd = VaultEnd;
	params.bIsClimb = bIsClimb;
	params.VaultAnimType = VaultAnimType;
	params.bEndToFall = bEndToFall;
	params.Direction = Direction;
	params.PlayerVelocity = PlayerVelocity;
	params.DistanceFromObject = DistanceFromObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacterMovement.IsVaulting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslCharacterMovement::IsVaulting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20945);

	UTslCharacterMovement_IsVaulting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.HandleVaultPreEvaluation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                           bForceVelocity                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InForcedVelocity               (Parm, IsPlainOldData)

void UTslCharacterMovement::HandleVaultPreEvaluation(bool bForceVelocity, const struct FVector& InForcedVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20942);

	UTslCharacterMovement_HandleVaultPreEvaluation_Params params;
	params.bForceVelocity = bForceVelocity;
	params.InForcedVelocity = InForcedVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacterMovement.HandleVaulting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVaultingHandleInput    Input                          (Parm)
// struct FVaultingHandleResult   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FVaultingHandleResult UTslCharacterMovement::HandleVaulting(const struct FVaultingHandleInput& Input)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20939);

	UTslCharacterMovement_HandleVaulting_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.GetVTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslCharacterMovement::GetVTimer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20937);

	UTslCharacterMovement_GetVTimer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.GetVaultingDataFromAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVaultAnimType                 InVaultType                    (Parm, ZeroConstructor, IsPlainOldData)
// class UVaultingData*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UVaultingData* UTslCharacterMovement::GetVaultingDataFromAnim(EVaultAnimType InVaultType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20933);

	UTslCharacterMovement_GetVaultingDataFromAnim_Params params;
	params.InVaultType = InVaultType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.GetMaxVaultDistanceBySpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslCharacterMovement::GetMaxVaultDistanceBySpeed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20931);

	UTslCharacterMovement_GetMaxVaultDistanceBySpeed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.GetGlobalVaultingSpeedMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslCharacterMovement::GetGlobalVaultingSpeedMultiplier()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20929);

	UTslCharacterMovement_GetGlobalVaultingSpeedMultiplier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.GetCurrentVaultType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVaultAnimType                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EVaultAnimType UTslCharacterMovement::GetCurrentVaultType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20926);

	UTslCharacterMovement_GetCurrentVaultType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.EvaluateVaultAnimType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            FirstRow                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            ApexAdditiveStepCounter        (Parm, ZeroConstructor, IsPlainOldData)
// float                          AverageCellCount               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bForceVault                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bForceClimb                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          CharVelocity                   (Parm, ZeroConstructor, IsPlainOldData)
// EVaultAnimType                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EVaultAnimType UTslCharacterMovement::EvaluateVaultAnimType(int FirstRow, int ApexAdditiveStepCounter, float AverageCellCount, bool bForceVault, bool bForceClimb, float CharVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20917);

	UTslCharacterMovement_EvaluateVaultAnimType_Params params;
	params.FirstRow = FirstRow;
	params.ApexAdditiveStepCounter = ApexAdditiveStepCounter;
	params.AverageCellCount = AverageCellCount;
	params.bForceVault = bForceVault;
	params.bForceClimb = bForceClimb;
	params.CharVelocity = CharVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterMovement.EndCurrentTaskToFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslCharacterMovement::EndCurrentTaskToFall()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(20915);

	UTslCharacterMovement_EndCurrentTaskToFall_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslAnimInstance.SetWeaponStatesEvaluationCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)

void UTslAnimInstance::SetWeaponStatesEvaluationCooldown(float Time)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21471);

	UTslAnimInstance_SetWeaponStatesEvaluationCooldown_Params params;
	params.Time = Time;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.SetLandPredictionVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 newLandVector                  (Parm, IsPlainOldData)

void UTslAnimInstance::SetLandPredictionVector(const struct FVector& newLandVector)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21469);

	UTslAnimInstance_SetLandPredictionVector_Params params;
	params.newLandVector = newLandVector;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.SetJumpStartLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (Parm, IsPlainOldData)
// float                          DefaultFallHeight              (Parm, ZeroConstructor, IsPlainOldData)

void UTslAnimInstance::SetJumpStartLocation(const struct FVector& NewLocation, float DefaultFallHeight)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21466);

	UTslAnimInstance_SetJumpStartLocation_Params params;
	params.NewLocation = NewLocation;
	params.DefaultFallHeight = DefaultFallHeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.ResetRecoilRoll
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::ResetRecoilRoll()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21465);

	UTslAnimInstance_ResetRecoilRoll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.ResetIdle
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::ResetIdle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21464);

	UTslAnimInstance_ResetIdle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.RandomizeIdleIndex_CP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ExludeLastIndex                (Parm, ZeroConstructor, IsPlainOldData)

void UTslAnimInstance::RandomizeIdleIndex_CP(bool ExludeLastIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21462);

	UTslAnimInstance_RandomizeIdleIndex_CP_Params params;
	params.ExludeLastIndex = ExludeLastIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.ProcessCodePaths
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::ProcessCodePaths()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21461);

	UTslAnimInstance_ProcessCodePaths_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.PreEvaluatePawnState
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::PreEvaluatePawnState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21460);

	UTslAnimInstance_PreEvaluatePawnState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.OnHitReaction
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// EAnimWeaponType                WeaponType                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Direction                      (Parm, IsPlainOldData)

void UTslAnimInstance::OnHitReaction(EAnimWeaponType WeaponType, const struct FName& BoneName, const struct FVector& Direction)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21455);

	UTslAnimInstance_OnHitReaction_Params params;
	params.WeaponType = WeaponType;
	params.BoneName = BoneName;
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.HandleSpeedAndDirection_CP
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::HandleSpeedAndDirection_CP()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21454);

	UTslAnimInstance_HandleSpeedAndDirection_CP_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.HandleItemOffsets_CP
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::HandleItemOffsets_CP()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21453);

	UTslAnimInstance_HandleItemOffsets_CP_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.HandleCardinalDirection90
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InDirection                    (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UTslAnimInstance::HandleCardinalDirection90(float InDirection)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21450);

	UTslAnimInstance_HandleCardinalDirection90_Params params;
	params.InDirection = InDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslAnimInstance.HandleAnimCurves
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::HandleAnimCurves()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21449);

	UTslAnimInstance_HandleAnimCurves_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.HandleADSSocketOffset
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::HandleADSSocketOffset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21448);

	UTslAnimInstance_HandleADSSocketOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.GetVehicleAO
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Yaw                            (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Pitch                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UTslAnimInstance::GetVehicleAO(float* Yaw, float* Pitch)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21445);

	UTslAnimInstance_GetVehicleAO_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Yaw != nullptr)
		*Yaw = params.Yaw;
	if (Pitch != nullptr)
		*Pitch = params.Pitch;
}


// Function TslGame.TslAnimInstance.GetBlendSpaceRelaxed_TS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<EAnimStanceType>   AnimStance                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsFPP                         (Parm, ZeroConstructor, IsPlainOldData)
// class UAnimDB*                 InAnimDB                       (Parm, ZeroConstructor, IsPlainOldData)
// class UBlendSpace*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpace* UTslAnimInstance::GetBlendSpaceRelaxed_TS(TEnumAsByte<EAnimStanceType> AnimStance, bool bIsFPP, class UAnimDB* InAnimDB)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21440);

	UTslAnimInstance_GetBlendSpaceRelaxed_TS_Params params;
	params.AnimStance = AnimStance;
	params.bIsFPP = bIsFPP;
	params.InAnimDB = InAnimDB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslAnimInstance.GetBlendSpace_TS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<EAnimStanceType>   AnimStance                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsFPP                         (Parm, ZeroConstructor, IsPlainOldData)
// class UAnimDB*                 InAnimDB                       (Parm, ZeroConstructor, IsPlainOldData)
// class UBlendSpace*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UBlendSpace* UTslAnimInstance::GetBlendSpace_TS(TEnumAsByte<EAnimStanceType> AnimStance, bool bIsFPP, class UAnimDB* InAnimDB)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21435);

	UTslAnimInstance_GetBlendSpace_TS_Params params;
	params.AnimStance = AnimStance;
	params.bIsFPP = bIsFPP;
	params.InAnimDB = InAnimDB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslAnimInstance.GetAnimSpeed_TS
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<EAnimStanceType>   AnimStance                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Direction                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InSpeed                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          PlayRate                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          SprintAlpha                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class UAnimDB*                 InAnimDB                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsSprinting                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslAnimInstance::GetAnimSpeed_TS(TEnumAsByte<EAnimStanceType> AnimStance, float Direction, float InSpeed, class UAnimDB* InAnimDB, bool bIsSprinting, float* PlayRate, float* SprintAlpha)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21426);

	UTslAnimInstance_GetAnimSpeed_TS_Params params;
	params.AnimStance = AnimStance;
	params.Direction = Direction;
	params.InSpeed = InSpeed;
	params.InAnimDB = InAnimDB;
	params.bIsSprinting = bIsSprinting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PlayRate != nullptr)
		*PlayRate = params.PlayRate;
	if (SprintAlpha != nullptr)
		*SprintAlpha = params.SprintAlpha;

	return params.ReturnValue;
}


// Function TslGame.TslAnimInstance.GetAbsActorToBaseRotation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           bInUseMin                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          InAngle                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslAnimInstance::GetAbsActorToBaseRotation(bool bInUseMin, float InAngle)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21422);

	UTslAnimInstance_GetAbsActorToBaseRotation_Params params;
	params.bInUseMin = bInUseMin;
	params.InAngle = InAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslAnimInstance.FindPositionFromDistanceCurve
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// class UAnimSequenceBase*       InAnimSequence                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslAnimInstance::FindPositionFromDistanceCurve(float Distance, class UAnimSequenceBase* InAnimSequence)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21418);

	UTslAnimInstance_FindPositionFromDistanceCurve_Params params;
	params.Distance = Distance;
	params.InAnimSequence = InAnimSequence;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslAnimInstance.EvaluateWeaponStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateWeaponStates()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21417);

	UTslAnimInstance_EvaluateWeaponStates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateWeaponStability
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateWeaponStability()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21416);

	UTslAnimInstance_EvaluateWeaponStability_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateWeaponInertia
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateWeaponInertia()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21415);

	UTslAnimInstance_EvaluateWeaponInertia_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateWeaponCollision
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateWeaponCollision()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21414);

	UTslAnimInstance_EvaluateWeaponCollision_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateVehicle
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateVehicle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21413);

	UTslAnimInstance_EvaluateVehicle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateVaulting
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateVaulting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21412);

	UTslAnimInstance_EvaluateVaulting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateSwimming
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateSwimming()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21411);

	UTslAnimInstance_EvaluateSwimming_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateRotations
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateRotations()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21410);

	UTslAnimInstance_EvaluateRotations_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateRecoilRoll
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateRecoilRoll()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21409);

	UTslAnimInstance_EvaluateRecoilRoll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluatePawnStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluatePawnStates()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21408);

	UTslAnimInstance_EvaluatePawnStates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateMeleeAttack
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateMeleeAttack()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21407);

	UTslAnimInstance_EvaluateMeleeAttack_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateLocalPawnStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateLocalPawnStates()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21406);

	UTslAnimInstance_EvaluateLocalPawnStates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateLeaning
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateLeaning()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21405);

	UTslAnimInstance_EvaluateLeaning_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateJumping
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateJumping()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21404);

	UTslAnimInstance_EvaluateJumping_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateJumpCamera
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateJumpCamera()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21403);

	UTslAnimInstance_EvaluateJumpCamera_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateItemOffsets
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateItemOffsets()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21402);

	UTslAnimInstance_EvaluateItemOffsets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateIdle
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateIdle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21401);

	UTslAnimInstance_EvaluateIdle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateFreelook
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateFreelook()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21400);

	UTslAnimInstance_EvaluateFreelook_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateFreefallAndParachute
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateFreefallAndParachute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21399);

	UTslAnimInstance_EvaluateFreefallAndParachute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateFallingAndLanding
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateFallingAndLanding()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21398);

	UTslAnimInstance_EvaluateFallingAndLanding_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateCoatExternalForce
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateCoatExternalForce()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21397);

	UTslAnimInstance_EvaluateCoatExternalForce_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateCharacterStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateCharacterStates()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21396);

	UTslAnimInstance_EvaluateCharacterStates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateCasting
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateCasting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21395);

	UTslAnimInstance_EvaluateCasting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateAnimDynamics
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateAnimDynamics()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21394);

	UTslAnimInstance_EvaluateAnimDynamics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateAimStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateAimStates()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21393);

	UTslAnimInstance_EvaluateAimStates_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.EvaluateAimOffsets
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateAimOffsets()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21392);

	UTslAnimInstance_EvaluateAimOffsets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAnimInstance.CacheCharacterReference
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*           InCharacter                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslAnimInstance::CacheCharacterReference(class ATslCharacter* InCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21390);

	UTslAnimInstance_CacheCharacterReference_Params params;
	params.InCharacter = InCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.TestSendSystemMessage
// (Final, Exec, Native, Public)
// Parameters:
// struct FText                   Message                        (Parm)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslHUD::TestSendSystemMessage(const struct FText& Message, float Duration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21880);

	ATslHUD_TestSendSystemMessage_Params params;
	params.Message = Message;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.TestSendImportantMessage
// (Final, Exec, Native, Public)
// Parameters:
// struct FText                   Message                        (Parm)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslHUD::TestSendImportantMessage(const struct FText& Message, float Duration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21877);

	ATslHUD_TestSendImportantMessage_Params params;
	params.Message = Message;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.TestKillMessage
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 KillerName                     (Parm, ZeroConstructor)
// struct FString                 VictimName                     (Parm, ZeroConstructor)
// bool                           bKillerIsOwner                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bVictimIsOwner                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslHUD::TestKillMessage(const struct FString& KillerName, const struct FString& VictimName, bool bKillerIsOwner, bool bVictimIsOwner)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21872);

	ATslHUD_TestKillMessage_Params params;
	params.KillerName = KillerName;
	params.VictimName = VictimName;
	params.bKillerIsOwner = bKillerIsOwner;
	params.bVictimIsOwner = bVictimIsOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.TestGameEvent_MatchEnded
// (Final, Exec, Native, Public)

void ATslHUD::TestGameEvent_MatchEnded()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21871);

	ATslHUD_TestGameEvent_MatchEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.TestGameEvent_KillOtherPlayer
// (Final, Exec, Native, Public)
// Parameters:
// bool                           bGroggy                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslHUD::TestGameEvent_KillOtherPlayer(bool bGroggy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21869);

	ATslHUD_TestGameEvent_KillOtherPlayer_Params params;
	params.bGroggy = bGroggy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.TestGameEvent_Die
// (Final, Exec, Native, Public)
// Parameters:
// bool                           bGroggy                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslHUD::TestGameEvent_Die(bool bGroggy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21867);

	ATslHUD_TestGameEvent_Die_Params params;
	params.bGroggy = bGroggy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.SpawnActorInSceneCaptureWorld
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UClass*                  ActorClass                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              SpawnTransform                 (ConstParm, Parm, IsPlainOldData)
// struct FScriptDelegate         DelegateToCall                 (Parm, ZeroConstructor)

void ATslHUD::SpawnActorInSceneCaptureWorld(class UClass* ActorClass, const struct FTransform& SpawnTransform, const struct FScriptDelegate& DelegateToCall)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21863);

	ATslHUD_SpawnActorInSceneCaptureWorld_Params params;
	params.ActorClass = ActorClass;
	params.SpawnTransform = SpawnTransform;
	params.DelegateToCall = DelegateToCall;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.SetHighlightProvider
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 Provider                       (Parm, ZeroConstructor)

void ATslHUD::SetHighlightProvider(const struct FString& Provider)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21861);

	ATslHUD_SetHighlightProvider_Params params;
	params.Provider = Provider;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.RecordReplayHighlightSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          timeLength                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslHUD::RecordReplayHighlightSession(float timeLength)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21859);

	ATslHUD_RecordReplayHighlightSession_Params params;
	params.timeLength = timeLength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.NotifyDropSlotOnOtherContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class USlotContainerInterface> Container                      (Parm, ZeroConstructor, IsPlainOldData)
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// TScriptInterface<class USlotContainerInterface> OtherContainer                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslHUD::NotifyDropSlotOnOtherContainer(const TScriptInterface<class USlotContainerInterface>& Container, const TScriptInterface<class USlotInterface>& Slot, const TScriptInterface<class USlotContainerInterface>& OtherContainer)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21855);

	ATslHUD_NotifyDropSlotOnOtherContainer_Params params;
	params.Container = Container;
	params.Slot = Slot;
	params.OtherContainer = OtherContainer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.IsGameEnded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslHUD::IsGameEnded()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21853);

	ATslHUD_IsGameEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslHUD.InitCaptureWorld
// (Final, Native, Public, BlueprintCallable)

void ATslHUD::InitCaptureWorld()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21852);

	ATslHUD_InitCaptureWorld_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.GoToLobby
// (Final, Native, Public, BlueprintCallable)

void ATslHUD::GoToLobby()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21851);

	ATslHUD_GoToLobby_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHUD.GetPossessPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class APawn* ATslHUD::GetPossessPawn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21849);

	ATslHUD_GetPossessPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslHUD.GetPossessCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ATslHUD::GetPossessCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21847);

	ATslHUD_GetPossessCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslHUD.GetHealAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslHUD::GetHealAmount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21845);

	ATslHUD_GetHealAmount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.SetCharacterStudioRenderTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*  rt                             (Parm, ZeroConstructor, IsPlainOldData)

void UTslSettings::SetCharacterStudioRenderTarget(class UTextureRenderTarget2D* rt)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21953);

	UTslSettings_SetCharacterStudioRenderTarget_Params params;
	params.rt = rt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSettings.IsWarMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslSettings::IsWarMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21951);

	UTslSettings_IsWarMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.IsUsingGappLobby
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslSettings::IsUsingGappLobby()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21949);

	UTslSettings_IsUsingGappLobby_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.IsForKoreanRating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslSettings::IsForKoreanRating()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21947);

	UTslSettings_IsForKoreanRating_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.IsForKakaoTest
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslSettings::IsForKakaoTest()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21945);

	UTslSettings_IsForKakaoTest_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.IsForKakao
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslSettings::IsForKakao()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21943);

	UTslSettings_IsForKakao_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.IsForChineseLicensing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslSettings::IsForChineseLicensing()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21941);

	UTslSettings_IsForChineseLicensing_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.IsESports
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslSettings::IsESports()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21939);

	UTslSettings_IsESports_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.GetTslSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTslSettings*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTslSettings* UTslSettings::GetTslSettings()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21937);

	UTslSettings_GetTslSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.GetNotifyMaxDistanceByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslSettings::GetNotifyMaxDistanceByName(const struct FName& InName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21934);

	UTslSettings_GetNotifyMaxDistanceByName_Params params;
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.GetGappLobbyUrl
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslSettings::GetGappLobbyUrl()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21932);

	UTslSettings_GetGappLobbyUrl_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSettings.GetCharacterStudioRenderTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTextureRenderTarget2D*  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTextureRenderTarget2D* UTslSettings::GetCharacterStudioRenderTarget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(21930);

	UTslSettings_GetCharacterStudioRenderTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.UseLobbyWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::UseLobbyWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4445);

	UTslGameInstance_UseLobbyWidget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.UpdateReplayShouldKeepBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 RegionOrLocal                  (Parm, ZeroConstructor)
// struct FString                 SessionName                    (Parm, ZeroConstructor)
// bool                           bShouldKeep                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::UpdateReplayShouldKeepBP(const struct FString& RegionOrLocal, const struct FString& SessionName, bool bShouldKeep)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4440);

	UTslGameInstance_UpdateReplayShouldKeepBP_Params params;
	params.RegionOrLocal = RegionOrLocal;
	params.SessionName = SessionName;
	params.bShouldKeep = bShouldKeep;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.UpdateReplayAllDeadOrWinBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 RegionOrLocal                  (Parm, ZeroConstructor)
// struct FString                 SessionName                    (Parm, ZeroConstructor)
// bool                           bAllDeadOrWin                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::UpdateReplayAllDeadOrWinBP(const struct FString& RegionOrLocal, const struct FString& SessionName, bool bAllDeadOrWin)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4435);

	UTslGameInstance_UpdateReplayAllDeadOrWinBP_Params params;
	params.RegionOrLocal = RegionOrLocal;
	params.SessionName = SessionName;
	params.bAllDeadOrWin = bAllDeadOrWin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.UnPause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::UnPause()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4433);

	UTslGameInstance_UnPause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.StopStat
// (Final, Native, Private)
// Parameters:
// TEnumAsByte<EServerStatType>   StatType                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::StopStat(TEnumAsByte<EServerStatType> StatType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4431);

	UTslGameInstance_StopStat_Params params;
	params.StatType = StatType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.StopIfReplaying
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::StopIfReplaying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4430);

	UTslGameInstance_StopIfReplaying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.StartStat
// (Final, Native, Private)
// Parameters:
// TEnumAsByte<EServerStatType>   StatType                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::StartStat(TEnumAsByte<EServerStatType> StatType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4426);

	UTslGameInstance_StartStat_Params params;
	params.StatType = StatType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.ShowYesNoMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 strTitle                       (Parm, ZeroConstructor)
// struct FString                 strMsg                         (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::ShowYesNoMessage(const struct FString& strTitle, const struct FString& strMsg)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4422);

	UTslGameInstance_ShowYesNoMessage_Params params;
	params.strTitle = strTitle;
	params.strMsg = strMsg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.ShowSystemMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 strTitle                       (Parm, ZeroConstructor)
// struct FString                 strMsg                         (Parm, ZeroConstructor)

void UTslGameInstance::ShowSystemMessage(const struct FString& strTitle, const struct FString& strMsg)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4419);

	UTslGameInstance_ShowSystemMessage_Params params;
	params.strTitle = strTitle;
	params.strMsg = strMsg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.ShowOkCancelMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 strTitle                       (Parm, ZeroConstructor)
// struct FString                 strMsg                         (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::ShowOkCancelMessage(const struct FString& strTitle, const struct FString& strMsg)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4415);

	UTslGameInstance_ShowOkCancelMessage_Params params;
	params.strTitle = strTitle;
	params.strMsg = strMsg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.ShowLoadingScreen
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::ShowLoadingScreen()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4414);

	UTslGameInstance_ShowLoadingScreen_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.SetStartedFromReplayListMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bSet                           (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::SetStartedFromReplayListMap(bool bSet)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4412);

	UTslGameInstance_SetStartedFromReplayListMap_Params params;
	params.bSet = bSet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.SetReplayTimeSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          TimeSpeed                      (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::SetReplayTimeSpeed(float TimeSpeed)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4410);

	UTslGameInstance_SetReplayTimeSpeed_Params params;
	params.TimeSpeed = TimeSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.SetReplayBusy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bBusy                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::SetReplayBusy(bool bBusy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4408);

	UTslGameInstance_SetReplayBusy_Params params;
	params.bBusy = bBusy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.SetMaxReplaysForNullStreamer
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::SetMaxReplaysForNullStreamer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4407);

	UTslGameInstance_SetMaxReplaysForNullStreamer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.ResetReplayStreamer
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::ResetReplayStreamer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4406);

	UTslGameInstance_ResetReplayStreamer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.RequestReplayAKillEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 EventID                        (Parm, ZeroConstructor)

void UTslGameInstance::RequestReplayAKillEvent(const struct FString& EventID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4404);

	UTslGameInstance_RequestReplayAKillEvent_Params params;
	params.EventID = EventID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.RequestReplayAGroggyEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 EventID                        (Parm, ZeroConstructor)

void UTslGameInstance::RequestReplayAGroggyEvent(const struct FString& EventID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4402);

	UTslGameInstance_RequestReplayAGroggyEvent_Params params;
	params.EventID = EventID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction TslGame.TslGameInstance.ReplayProblemDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UTslGameInstance::ReplayProblemDelegate__DelegateSignature()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4401);

	UTslGameInstance_ReplayProblemDelegate__DelegateSignature_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.ReplayJumpInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            second                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::ReplayJumpInt(int second)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4399);

	UTslGameInstance_ReplayJumpInt_Params params;
	params.second = second;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.ReplayJump
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          TimelinePercentage             (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::ReplayJump(float TimelinePercentage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4397);

	UTslGameInstance_ReplayJump_Params params;
	params.TimelinePercentage = TimelinePercentage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.RemoveAllKillEvents
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::RemoveAllKillEvents()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4396);

	UTslGameInstance_RemoveAllKillEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.RemoveAllGroggyEvents
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::RemoveAllGroggyEvents()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4395);

	UTslGameInstance_RemoveAllGroggyEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction TslGame.TslGameInstance.RecordStartedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UTslGameInstance::RecordStartedDelegate__DelegateSignature()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4394);

	UTslGameInstance_RecordStartedDelegate__DelegateSignature_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.QuitApplication
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bShowMessage                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::QuitApplication(bool bShowMessage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4392);

	UTslGameInstance_QuitApplication_Params params;
	params.bShowMessage = bShowMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.PlayReplayCommand
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 RegionOrLocal                  (Parm, ZeroConstructor)
// struct FString                 SessionName                    (Parm, ZeroConstructor)

void UTslGameInstance::PlayReplayCommand(const struct FString& RegionOrLocal, const struct FString& SessionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4389);

	UTslGameInstance_PlayReplayCommand_Params params;
	params.RegionOrLocal = RegionOrLocal;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.PlayReplayBPByRegionOrLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 Region                         (Parm, ZeroConstructor)
// struct FString                 SessionName                    (Parm, ZeroConstructor)

void UTslGameInstance::PlayReplayBPByRegionOrLocal(const struct FString& Region, const struct FString& SessionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4386);

	UTslGameInstance_PlayReplayBPByRegionOrLocal_Params params;
	params.Region = Region;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.PlayReplayBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 SessionName                    (Parm, ZeroConstructor)

void UTslGameInstance::PlayReplayBP(const struct FString& SessionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4384);

	UTslGameInstance_PlayReplayBP_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.Pause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::Pause()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4382);

	UTslGameInstance_Pause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.OnPressedPopupConfirmInvite
// (Final, Native, Private)
// Parameters:
// EPopupButtonID                 ButtonID                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::OnPressedPopupConfirmInvite(EPopupButtonID ButtonID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4379);

	UTslGameInstance_OnPressedPopupConfirmInvite_Params params;
	params.ButtonID = ButtonID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.OnPressedPopupCommon
// (Final, Native, Private)
// Parameters:
// EPopupButtonID                 ButtonID                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::OnPressedPopupCommon(EPopupButtonID ButtonID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4376);

	UTslGameInstance_OnPressedPopupCommon_Params params;
	params.ButtonID = ButtonID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.KeepMaxReplaysAndDeleteOldestReplaysForNullStreamer
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::KeepMaxReplaysAndDeleteOldestReplaysForNullStreamer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4375);

	UTslGameInstance_KeepMaxReplaysAndDeleteOldestReplaysForNullStreamer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.KeepAndDeleteOldestReplaysForNullStreamer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            nReplaysToKeep                 (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::KeepAndDeleteOldestReplaysForNullStreamer(int nReplaysToKeep)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4373);

	UTslGameInstance_KeepAndDeleteOldestReplaysForNullStreamer_Params params;
	params.nReplaysToKeep = nReplaysToKeep;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction TslGame.TslGameInstance.KeepAndDeleteOldestReplaysDoneDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int                            nRemains                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::KeepAndDeleteOldestReplaysDoneDelegate__DelegateSignature(int nRemains)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4371);

	UTslGameInstance_KeepAndDeleteOldestReplaysDoneDelegate__DelegateSignature_Params params;
	params.nRemains = nRemains;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.IsReplaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::IsReplaying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4369);

	UTslGameInstance_IsReplaying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.IsReplayError
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::IsReplayError()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4367);

	UTslGameInstance_IsReplayError_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.IsRecording
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::IsRecording()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4365);

	UTslGameInstance_IsRecording_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.IsPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::IsPaused()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4363);

	UTslGameInstance_IsPaused_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.IsLive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::IsLive()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4361);

	UTslGameInstance_IsLive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.IsKillcamPlayback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::IsKillcamPlayback()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4359);

	UTslGameInstance_IsKillcamPlayback_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// DelegateFunction TslGame.TslGameInstance.GotoTimelineDoneDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UTslGameInstance::GotoTimelineDoneDelegate__DelegateSignature()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4358);

	UTslGameInstance_GotoTimelineDoneDelegate__DelegateSignature_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.GotoReplayList
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::GotoReplayList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4357);

	UTslGameInstance_GotoReplayList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.GetUnderFpsCount
// (Final, Native, Public, Const)
// Parameters:
// int                            Fps                            (Parm, ZeroConstructor, IsPlainOldData)
// int                            DuringSeconds                  (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslGameInstance::GetUnderFpsCount(int Fps, int DuringSeconds)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4353);

	UTslGameInstance_GetUnderFpsCount_Params params;
	params.Fps = Fps;
	params.DuringSeconds = DuringSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetStartParameterStringValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 Key                            (Parm, ZeroConstructor)
// struct FString                 NotFoundValue                  (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslGameInstance::GetStartParameterStringValue(const struct FString& Key, const struct FString& NotFoundValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4349);

	UTslGameInstance_GetStartParameterStringValue_Params params;
	params.Key = Key;
	params.NotFoundValue = NotFoundValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetStartParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTslStartParameter      ReturnValue                    (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm)

struct FTslStartParameter UTslGameInstance::GetStartParameter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4337);

	UTslGameInstance_GetStartParameter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetStartedFromReplayListMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::GetStartedFromReplayListMap()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4335);

	UTslGameInstance_GetStartedFromReplayListMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetReplayTotalTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameInstance::GetReplayTotalTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4333);

	UTslGameInstance_GetReplayTotalTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// DelegateFunction TslGame.TslGameInstance.GetReplaySummaryDoneDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FTslReplaySummary       aTslReplaySummary              (Parm)

void UTslGameInstance::GetReplaySummaryDoneDelegate__DelegateSignature(const struct FTslReplaySummary& aTslReplaySummary)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4331);

	UTslGameInstance_GetReplaySummaryDoneDelegate__DelegateSignature_Params params;
	params.aTslReplaySummary = aTslReplaySummary;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.GetReplaySummary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 RegionOrLocal                  (ConstParm, Parm, ZeroConstructor)
// struct FString                 SessionName                    (ConstParm, Parm, ZeroConstructor)

void UTslGameInstance::GetReplaySummary(const struct FString& RegionOrLocal, const struct FString& SessionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4328);

	UTslGameInstance_GetReplaySummary_Params params;
	params.RegionOrLocal = RegionOrLocal;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.GetReplayListLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            PageIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            PageSize                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::GetReplayListLocal(int PageIndex, int PageSize)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4325);

	UTslGameInstance_GetReplayListLocal_Params params;
	params.PageIndex = PageIndex;
	params.PageSize = PageSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction TslGame.TslGameInstance.GetReplayListDoneDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UTslGameInstance::GetReplayListDoneDelegate__DelegateSignature()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4324);

	UTslGameInstance_GetReplayListDoneDelegate__DelegateSignature_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.GetReplayListByRegionOrLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 RegionOrLocal                  (Parm, ZeroConstructor)
// int                            PageIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            PageSize                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::GetReplayListByRegionOrLocal(const struct FString& RegionOrLocal, int PageIndex, int PageSize)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4320);

	UTslGameInstance_GetReplayListByRegionOrLocal_Params params;
	params.RegionOrLocal = RegionOrLocal;
	params.PageIndex = PageIndex;
	params.PageSize = PageSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.GetReplayList
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::GetReplayList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4319);

	UTslGameInstance_GetReplayList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction TslGame.TslGameInstance.GetReplayKill__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UTslGameInstance::GetReplayKill__DelegateSignature()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4318);

	UTslGameInstance_GetReplayKill__DelegateSignature_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.GetReplayCurrentTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameInstance::GetReplayCurrentTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4316);

	UTslGameInstance_GetReplayCurrentTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetReplayBusy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::GetReplayBusy()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4314);

	UTslGameInstance_GetReplayBusy_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetRecordUserFromReplaySummary
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FTslReplaySummary       inReplaySummary                (ConstParm, Parm, OutParm, ReferenceParm)
// struct FTslPlayerStateSummary  ReturnValue                    (Parm, OutParm, ReturnParm)

struct FTslPlayerStateSummary UTslGameInstance::GetRecordUserFromReplaySummary(const struct FTslReplaySummary& inReplaySummary)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4311);

	UTslGameInstance_GetRecordUserFromReplaySummary_Params params;
	params.inReplaySummary = inReplaySummary;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetRecorderTeamMembersFromReplaySummary
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FTslReplaySummary       inReplaySummary                (ConstParm, Parm, OutParm, ReferenceParm)
// TArray<struct FTslPlayerStateSummary> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslPlayerStateSummary> UTslGameInstance::GetRecorderTeamMembersFromReplaySummary(const struct FTslReplaySummary& inReplaySummary)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4307);

	UTslGameInstance_GetRecorderTeamMembersFromReplaySummary_Params params;
	params.inReplaySummary = inReplaySummary;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetNumTotalReplays
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslGameInstance::GetNumTotalReplays()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4305);

	UTslGameInstance_GetNumTotalReplays_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetNumReplaysForNullStreamer
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::GetNumReplaysForNullStreamer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4304);

	UTslGameInstance_GetNumReplaysForNullStreamer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.GetGameEventObserver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameEventObserver*      ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UGameEventObserver* UTslGameInstance::GetGameEventObserver()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4302);

	UTslGameInstance_GetGameEventObserver_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetDemoDiskFreeSpace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameInstance::GetDemoDiskFreeSpace()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4300);

	UTslGameInstance_GetDemoDiskFreeSpace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.GetCurrentGameState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UTslGameInstance::GetCurrentGameState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4298);

	UTslGameInstance_GetCurrentGameState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.FindRecorderCharacterForPlayback
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<class ATslCharacter*>   ReplicatedCharacterList        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bIsClip                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ClipTargetUserId               (Parm, ZeroConstructor)
// struct FString                 ClipTargetUserNickName         (Parm, ZeroConstructor)
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UTslGameInstance::FindRecorderCharacterForPlayback(TArray<class ATslCharacter*> ReplicatedCharacterList, bool bIsClip, const struct FString& ClipTargetUserId, const struct FString& ClipTargetUserNickName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4291);

	UTslGameInstance_FindRecorderCharacterForPlayback_Params params;
	params.ReplicatedCharacterList = ReplicatedCharacterList;
	params.bIsClip = bIsClip;
	params.ClipTargetUserId = ClipTargetUserId;
	params.ClipTargetUserNickName = ClipTargetUserNickName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.EnumerateReplayKillEvents
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::EnumerateReplayKillEvents()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4290);

	UTslGameInstance_EnumerateReplayKillEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.EnumerateReplayGroggyEvents
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::EnumerateReplayGroggyEvents()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4289);

	UTslGameInstance_EnumerateReplayGroggyEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction TslGame.TslGameInstance.DownloadZippedReplayProgressDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FString                 strFileName                    (Parm, ZeroConstructor)
// int                            nReceived                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            nTotal                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::DownloadZippedReplayProgressDelegate__DelegateSignature(const struct FString& strFileName, int nReceived, int nTotal)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4285);

	UTslGameInstance_DownloadZippedReplayProgressDelegate__DelegateSignature_Params params;
	params.strFileName = strFileName;
	params.nReceived = nReceived;
	params.nTotal = nTotal;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction TslGame.TslGameInstance.DownloadZippedReplayCompleteDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FString                 strFullPath                    (Parm, ZeroConstructor)
// struct FString                 strDirToExtract                (Parm, ZeroConstructor)

void UTslGameInstance::DownloadZippedReplayCompleteDelegate__DelegateSignature(const struct FString& strFullPath, const struct FString& strDirToExtract)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4282);

	UTslGameInstance_DownloadZippedReplayCompleteDelegate__DelegateSignature_Params params;
	params.strFullPath = strFullPath;
	params.strDirToExtract = strDirToExtract;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameInstance.DownloadZippedReplayBPByRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 Region                         (Parm, ZeroConstructor)
// struct FString                 SessionName                    (Parm, ZeroConstructor)
// int                            nTotalSize                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::DownloadZippedReplayBPByRegion(const struct FString& Region, const struct FString& SessionName, int nTotalSize)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4277);

	UTslGameInstance_DownloadZippedReplayBPByRegion_Params params;
	params.Region = Region;
	params.SessionName = SessionName;
	params.nTotalSize = nTotalSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.DeleteZippedReplayBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 ArchiveName                    (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::DeleteZippedReplayBP(const struct FString& ArchiveName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4274);

	UTslGameInstance_DeleteZippedReplayBP_Params params;
	params.ArchiveName = ArchiveName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.DeleteReplayBPByRegionOrLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 RegionOrLocal                  (Parm, ZeroConstructor)
// struct FString                 SessionName                    (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::DeleteReplayBPByRegionOrLocal(const struct FString& RegionOrLocal, const struct FString& SessionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4270);

	UTslGameInstance_DeleteReplayBPByRegionOrLocal_Params params;
	params.RegionOrLocal = RegionOrLocal;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.CancelDownloadingZippedReplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 SessionName                    (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameInstance::CancelDownloadingZippedReplay(const struct FString& SessionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4267);

	UTslGameInstance_CancelDownloadingZippedReplay_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameInstance.AddPlayerStateToReplaySummary
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FTslReplaySummary       inReplaySummary                (Parm, OutParm)
// class ATslPlayerState*         pPlayerState                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameInstance::AddPlayerStateToReplaySummary(class ATslPlayerState* pPlayerState, struct FTslReplaySummary* inReplaySummary)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(4241);

	UTslGameInstance_AddPlayerStateToReplaySummary_Params params;
	params.pPlayerState = pPlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (inReplaySummary != nullptr)
		*inReplaySummary = params.inReplaySummary;
}


// Function TslGame.LobbyHUD.TickFadeInOutEffect
// (Final, Native, Private)
// Parameters:
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TickFadeInOutEffect(float DeltaTime)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22249);

	ALobbyHUD_TickFadeInOutEffect_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TickCameraTransition
// (Final, Native, Private)
// Parameters:
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TickCameraTransition(float DeltaTime)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22247);

	ALobbyHUD_TickCameraTransition_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TestLobbyCharacterReady
// (Final, Exec, Native, Private)
// Parameters:
// uint32_t                       SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bReady                         (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TestLobbyCharacterReady(uint32_t SlotIndex, bool bReady)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22244);

	ALobbyHUD_TestLobbyCharacterReady_Params params;
	params.SlotIndex = SlotIndex;
	params.bReady = bReady;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TestLobbyCharacterHost
// (Final, Exec, Native, Private)
// Parameters:
// uint32_t                       SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TestLobbyCharacterHost(uint32_t SlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22242);

	ALobbyHUD_TestLobbyCharacterHost_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TestLobbyCharacterAddAngle
// (Final, Exec, Native, Private)
// Parameters:
// int                            SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InYawInDegree                  (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TestLobbyCharacterAddAngle(int SlotIndex, float InYawInDegree)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22239);

	ALobbyHUD_TestLobbyCharacterAddAngle_Params params;
	params.SlotIndex = SlotIndex;
	params.InYawInDegree = InYawInDegree;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TestLobbyCamera_TeleportTo
// (Final, Exec, Native, Private)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TestLobbyCamera_TeleportTo(int Index)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22237);

	ALobbyHUD_TestLobbyCamera_TeleportTo_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TestLobbyCamera_StartTransitionTo
// (Final, Exec, Native, Private)
// Parameters:
// int                            ToIndex                        (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TestLobbyCamera_StartTransitionTo(int ToIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22235);

	ALobbyHUD_TestLobbyCamera_StartTransitionTo_Params params;
	params.ToIndex = ToIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TestLobbyCamera_StartTransitionFromTo
// (Final, Exec, Native, Private)
// Parameters:
// int                            FromIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            ToIndex                        (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TestLobbyCamera_StartTransitionFromTo(int FromIndex, int ToIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22232);

	ALobbyHUD_TestLobbyCamera_StartTransitionFromTo_Params params;
	params.FromIndex = FromIndex;
	params.ToIndex = ToIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TestLobbyCamera_SpawnCharacters
// (Final, Exec, Native, Private)
// Parameters:
// int                            Num                            (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TestLobbyCamera_SpawnCharacters(int Num)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22230);

	ALobbyHUD_TestLobbyCamera_SpawnCharacters_Params params;
	params.Num = Num;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TestLobbyCamera_Init
// (Final, Exec, Native, Private)

void ALobbyHUD::TestLobbyCamera_Init()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22229);

	ALobbyHUD_TestLobbyCamera_Init_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.Test_UpdateLobbyCharacter
// (Final, Exec, Native, Public)
// Parameters:
// uint32_t                       SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::Test_UpdateLobbyCharacter(uint32_t SlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22227);

	ALobbyHUD_Test_UpdateLobbyCharacter_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.Test_RemoveLobbyItem
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 ItemId                         (Parm, ZeroConstructor)

void ALobbyHUD::Test_RemoveLobbyItem(const struct FString& ItemId)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22225);

	ALobbyHUD_Test_RemoveLobbyItem_Params params;
	params.ItemId = ItemId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.Test_RemoveAllLobbyItem
// (Final, Exec, Native, Public)

void ALobbyHUD::Test_RemoveAllLobbyItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22224);

	ALobbyHUD_Test_RemoveAllLobbyItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.Test_PrintWeaponItem
// (Final, Exec, Native, Public)
// Parameters:
// uint32_t                       SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::Test_PrintWeaponItem(uint32_t SlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22222);

	ALobbyHUD_Test_PrintWeaponItem_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.Test_PrintSkinItem
// (Final, Exec, Native, Public)
// Parameters:
// uint32_t                       SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::Test_PrintSkinItem(uint32_t SlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22220);

	ALobbyHUD_Test_PrintSkinItem_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.Test_AddLobbyItem
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 ItemId                         (Parm, ZeroConstructor)

void ALobbyHUD::Test_AddLobbyItem(const struct FString& ItemId)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22218);

	ALobbyHUD_Test_AddLobbyItem_Params params;
	params.ItemId = ItemId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.TeleportCameraTo
// (Final, Native, Public)
// Parameters:
// ELobbyCameraStates             InCameraState                  (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::TeleportCameraTo(ELobbyCameraStates InCameraState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22215);

	ALobbyHUD_TeleportCameraTo_Params params;
	params.InCameraState = InCameraState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.StopFadeInOutEffect
// (Final, Native, Private)

void ALobbyHUD::StopFadeInOutEffect()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22214);

	ALobbyHUD_StopFadeInOutEffect_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.StopCameraTransition
// (Final, Native, Private)

void ALobbyHUD::StopCameraTransition()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22213);

	ALobbyHUD_StopCameraTransition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.StartFadeInOutEffect
// (Final, Native, Private)

void ALobbyHUD::StartFadeInOutEffect()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22212);

	ALobbyHUD_StartFadeInOutEffect_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.StartCameraTransitionTo
// (Final, Native, Public)
// Parameters:
// ELobbyCameraStates             InToCameraState                (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::StartCameraTransitionTo(ELobbyCameraStates InToCameraState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22209);

	ALobbyHUD_StartCameraTransitionTo_Params params;
	params.InToCameraState = InToCameraState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.StartCameraTransitionFromTo
// (Final, Native, Public)
// Parameters:
// ELobbyCameraStates             InFromCameraState              (Parm, ZeroConstructor, IsPlainOldData)
// ELobbyCameraStates             InToCameraState                (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::StartCameraTransitionFromTo(ELobbyCameraStates InFromCameraState, ELobbyCameraStates InToCameraState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22204);

	ALobbyHUD_StartCameraTransitionFromTo_Params params;
	params.InFromCameraState = InFromCameraState;
	params.InToCameraState = InToCameraState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.SetWidgetForBinding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            ViewIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// class UCoherentUIGTWidget*     Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ALobbyHUD::SetWidgetForBinding(int ViewIndex, class UCoherentUIGTWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22201);

	ALobbyHUD_SetWidgetForBinding_Params params;
	params.ViewIndex = ViewIndex;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.SetLobbyCharacterHiddenInGame
// (Final, Native, Private)
// Parameters:
// uint32_t                       SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNewHidden                     (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::SetLobbyCharacterHiddenInGame(uint32_t SlotIndex, bool bNewHidden)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22198);

	ALobbyHUD_SetLobbyCharacterHiddenInGame_Params params;
	params.SlotIndex = SlotIndex;
	params.bNewHidden = bNewHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.RequestSystemMenu
// (Final, Native, Public)

void ALobbyHUD::RequestSystemMenu()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22197);

	ALobbyHUD_RequestSystemMenu_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.OnReplaySummary
// (Final, Native, Private)
// Parameters:
// struct FTslReplaySummary       ReplaySummary                  (Parm)

void ALobbyHUD::OnReplaySummary(const struct FTslReplaySummary& ReplaySummary)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22195);

	ALobbyHUD_OnReplaySummary_Params params;
	params.ReplaySummary = ReplaySummary;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.OnReplayList
// (Final, Native, Private)

void ALobbyHUD::OnReplayList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22194);

	ALobbyHUD_OnReplayList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.OnDeleteOldReplays
// (Final, Native, Private)
// Parameters:
// int                            RemainedReplayNum              (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::OnDeleteOldReplays(int RemainedReplayNum)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22192);

	ALobbyHUD_OnDeleteOldReplays_Params params;
	params.RemainedReplayNum = RemainedReplayNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.NotifyLobbySceneChanged
// (Final, Native, Private)
// Parameters:
// bool                           bIsCustomizationScene          (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::NotifyLobbySceneChanged(bool bIsCustomizationScene)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22190);

	ALobbyHUD_NotifyLobbySceneChanged_Params params;
	params.bIsCustomizationScene = bIsCustomizationScene;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.NotifyLobbyCharacterCreated
// (Final, Native, Private)
// Parameters:
// int                            InSlotIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::NotifyLobbyCharacterCreated(int InSlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22188);

	ALobbyHUD_NotifyLobbyCharacterCreated_Params params;
	params.InSlotIndex = InSlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.LeaveCustomizationMenu
// (Final, Native, Private)
// Parameters:
// ELobbyCameraStates             InFromCameraState              (Parm, ZeroConstructor, IsPlainOldData)
// ELobbyCameraStates             InToCameraState                (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::LeaveCustomizationMenu(ELobbyCameraStates InFromCameraState, ELobbyCameraStates InToCameraState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22183);

	ALobbyHUD_LeaveCustomizationMenu_Params params;
	params.InFromCameraState = InFromCameraState;
	params.InToCameraState = InToCameraState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.IsCameraHasBlurEffect
// (Final, Native, Private, Const)
// Parameters:
// ELobbyCameraStates             InLobbyCameraState             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ALobbyHUD::IsCameraHasBlurEffect(ELobbyCameraStates InLobbyCameraState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22179);

	ALobbyHUD_IsCameraHasBlurEffect_Params params;
	params.InLobbyCameraState = InLobbyCameraState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyHUD.InitLobbyTransition
// (Final, Native, Public)

void ALobbyHUD::InitLobbyTransition()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22178);

	ALobbyHUD_InitLobbyTransition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.InitFadeInOutEffect
// (Final, Native, Private)

void ALobbyHUD::InitFadeInOutEffect()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22177);

	ALobbyHUD_InitFadeInOutEffect_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.InitCameraTransition
// (Final, Native, Private)

void ALobbyHUD::InitCameraTransition()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22176);

	ALobbyHUD_InitCameraTransition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.GetStartUrl
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ALobbyHUD::GetStartUrl()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22174);

	ALobbyHUD_GetStartUrl_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyHUD.GetLobbyCharacterNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ALobbyHUD::GetLobbyCharacterNum()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22172);

	ALobbyHUD_GetLobbyCharacterNum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyHUD.GetLobbyCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// class ALobbyCharacter*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ALobbyCharacter* ALobbyHUD::GetLobbyCharacter(int SlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22169);

	ALobbyHUD_GetLobbyCharacter_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyHUD.GetLobbyCameraState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELobbyCameraStates             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ELobbyCameraStates ALobbyHUD::GetLobbyCameraState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22166);

	ALobbyHUD_GetLobbyCameraState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyHUD.GetLobbyCamera
// (Final, Native, Private)
// Parameters:
// ELobbyCameraStates             InLobbyCameraState             (Parm, ZeroConstructor, IsPlainOldData)
// class ACameraActor*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ACameraActor* ALobbyHUD::GetLobbyCamera(ELobbyCameraStates InLobbyCameraState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22162);

	ALobbyHUD_GetLobbyCamera_Params params;
	params.InLobbyCameraState = InLobbyCameraState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyHUD.GetCurveDuration
// (Final, Native, Private, Const)
// Parameters:
// class UCurveFloat*             InCurve                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ALobbyHUD::GetCurveDuration(class UCurveFloat* InCurve)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22159);

	ALobbyHUD_GetCurveDuration_Params params;
	params.InCurve = InCurve;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyHUD.EnterCustomizationMenu
// (Final, Native, Private)
// Parameters:
// ELobbyCameraStates             InFromCameraState              (Parm, ZeroConstructor, IsPlainOldData)
// ELobbyCameraStates             InToCameraState                (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::EnterCustomizationMenu(ELobbyCameraStates InFromCameraState, ELobbyCameraStates InToCameraState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22154);

	ALobbyHUD_EnterCustomizationMenu_Params params;
	params.InFromCameraState = InFromCameraState;
	params.InToCameraState = InToCameraState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.DecideBlurChangingState
// (Final, Native, Private, Const)
// Parameters:
// ELobbyCameraStates             InFromState                    (Parm, ZeroConstructor, IsPlainOldData)
// ELobbyCameraStates             InToState                      (Parm, ZeroConstructor, IsPlainOldData)
// ELobbyBlurChangingStates       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ELobbyBlurChangingStates ALobbyHUD::DecideBlurChangingState(ELobbyCameraStates InFromState, ELobbyCameraStates InToState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22147);

	ALobbyHUD_DecideBlurChangingState_Params params;
	params.InFromState = InFromState;
	params.InToState = InToState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LobbyHUD.ClearAllWidget
// (Final, Native, Public, BlueprintCallable)

void ALobbyHUD::ClearAllWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22146);

	ALobbyHUD_ClearAllWidget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.CacheSubLevelNames
// (Final, Native, Private)

void ALobbyHUD::CacheSubLevelNames()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22145);

	ALobbyHUD_CacheSubLevelNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.CachePostProcessEffectFromLevel
// (Final, Native, Private)

void ALobbyHUD::CachePostProcessEffectFromLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22144);

	ALobbyHUD_CachePostProcessEffectFromLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.CacheMainCameraFromLevel
// (Final, Native, Private)

void ALobbyHUD::CacheMainCameraFromLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22143);

	ALobbyHUD_CacheMainCameraFromLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.CacheLobbyCharacterTransforms
// (Final, Native, Private)

void ALobbyHUD::CacheLobbyCharacterTransforms()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22142);

	ALobbyHUD_CacheLobbyCharacterTransforms_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.CacheLobbyCamarasFromLevel
// (Final, Native, Private)

void ALobbyHUD::CacheLobbyCamarasFromLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22141);

	ALobbyHUD_CacheLobbyCamarasFromLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LobbyHUD.AddLobbyCharacterAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngleInDegree                  (Parm, ZeroConstructor, IsPlainOldData)

void ALobbyHUD::AddLobbyCharacterAngle(int SlotIndex, float AngleInDegree)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22138);

	ALobbyHUD_AddLobbyCharacterAngle_Params params;
	params.SlotIndex = SlotIndex;
	params.AngleInDegree = AngleInDegree;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWelcomeBaseHUD.OnPressedPopupCommon
// (Final, Native, Public)
// Parameters:
// EPopupButtonID                 ButtonID                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslWelcomeBaseHUD::OnPressedPopupCommon(EPopupButtonID ButtonID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22288);

	ATslWelcomeBaseHUD_OnPressedPopupCommon_Params params;
	params.ButtonID = ButtonID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEntryPlayerController.LoadReplay
// (Final, Exec, Native, Private)
// Parameters:
// struct FString                 SessionName                    (Parm, ZeroConstructor)

void ATslEntryPlayerController::LoadReplay(const struct FString& SessionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22295);

	ATslEntryPlayerController_LoadReplay_Params params;
	params.SessionName = SessionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEntryPlayerController.HandleLobbySystemMenu
// (Final, Native, Private)

void ATslEntryPlayerController::HandleLobbySystemMenu()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22294);

	ATslEntryPlayerController_HandleLobbySystemMenu_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.PerfBotPlayerController.ServerMoveToLocation
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                 Location                       (Parm, IsPlainOldData)

void APerfBotPlayerController::ServerMoveToLocation(const struct FVector& Location)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22299);

	APerfBotPlayerController_ServerMoveToLocation_Params params;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.PerfBotPlayerController.ClientQuit
// (Net, NetReliable, Native, Event, Public, NetClient)

void APerfBotPlayerController::ClientQuit()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22298);

	APerfBotPlayerController_ClientQuit_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.CharacterBreathBuff.GetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ACharacterBreathBuff::GetCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22313);

	ACharacterBreathBuff_GetCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.CharacterBreathBuff.GetBreathComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterBreathComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UCharacterBreathComponent* ACharacterBreathBuff::GetBreathComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22311);

	ACharacterBreathBuff_GetBreathComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCharacterProxy.UpdateEquippedWeapons
// (Final, Native, Public)

void ATslCharacterProxy::UpdateEquippedWeapons()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22392);

	ATslCharacterProxy_UpdateEquippedWeapons_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacterProxy.UpdateCharacterAppearance
// (Final, Native, Public)

void ATslCharacterProxy::UpdateCharacterAppearance()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22391);

	ATslCharacterProxy_UpdateCharacterAppearance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacterProxy.UpdateArmedWeapons
// (Final, Native, Public)

void ATslCharacterProxy::UpdateArmedWeapons()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22390);

	ATslCharacterProxy_UpdateArmedWeapons_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacterProxy.SetAccessorySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*  AccessoryComponent             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// EAccessorySlot                 Slot                           (Parm, ZeroConstructor, IsPlainOldData)

void ATslCharacterProxy::SetAccessorySlot(class UTslAccessoryComponent* AccessoryComponent, EAccessorySlot Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22386);

	ATslCharacterProxy_SetAccessorySlot_Params params;
	params.AccessoryComponent = AccessoryComponent;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCharacterProxy.GetAccessorySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAccessorySlot                 Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// class UTslAccessoryComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslAccessoryComponent* ATslCharacterProxy::GetAccessorySlot(EAccessorySlot Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22382);

	ATslCharacterProxy_GetAccessorySlot_Params params;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCheatManager.ToggleVisibilityOfDestructibleComponents
// (Final, Exec, Native, Public)

void UTslCheatManager::ToggleVisibilityOfDestructibleComponents()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22605);

	UTslCheatManager_ToggleVisibilityOfDestructibleComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ToggleParticleManager
// (Final, Exec, Native, Public)

void UTslCheatManager::ToggleParticleManager()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22604);

	UTslCheatManager_ToggleParticleManager_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ToggleMatchTimer
// (Final, Exec, Native, Public)

void UTslCheatManager::ToggleMatchTimer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22603);

	UTslCheatManager_ToggleMatchTimer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ToggleII
// (Final, Exec, Native, Public)
// Parameters:
// float                          Interval                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::ToggleII(float Interval)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22601);

	UTslCheatManager_ToggleII_Params params;
	params.Interval = Interval;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ToggleFreeMode
// (Final, Exec, Native, Public)

void UTslCheatManager::ToggleFreeMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22600);

	UTslCheatManager_ToggleFreeMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ToggleCollisionOfDestructibleComponents
// (Final, Exec, Native, Public)

void UTslCheatManager::ToggleCollisionOfDestructibleComponents()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22599);

	UTslCheatManager_ToggleCollisionOfDestructibleComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.TestVoiceAccessToken
// (Final, Exec, Native, Public)

void UTslCheatManager::TestVoiceAccessToken()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22598);

	UTslCheatManager_TestVoiceAccessToken_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.TestTriggerAchievement
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 ID                             (Parm, ZeroConstructor)
// int                            Num                            (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::TestTriggerAchievement(const struct FString& ID, int Num)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22595);

	UTslCheatManager_TestTriggerAchievement_Params params;
	params.ID = ID;
	params.Num = Num;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.TestResetAchievementAll
// (Final, Exec, Native, Public)

void UTslCheatManager::TestResetAchievementAll()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22594);

	UTslCheatManager_TestResetAchievementAll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.TestResetAchievement
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 ID                             (Parm, ZeroConstructor)

void UTslCheatManager::TestResetAchievement(const struct FString& ID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22592);

	UTslCheatManager_TestResetAchievement_Params params;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.SpawnBot
// (Final, Exec, Native, Public)

void UTslCheatManager::SpawnBot()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22591);

	UTslCheatManager_SpawnBot_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ShowLoadingScreen
// (Final, Exec, Native, Public)
// Parameters:
// bool                           OnOff                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::ShowLoadingScreen(bool OnOff)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22589);

	UTslCheatManager_ShowLoadingScreen_Params params;
	params.OnOff = OnOff;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.SetVehicleRepRotCorrection
// (Final, Exec, Native, Public)
// Parameters:
// float                          AngularDeltaThreshold          (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngularInterpAlpha             (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngularRecipFixTime            (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::SetVehicleRepRotCorrection(float AngularDeltaThreshold, float AngularInterpAlpha, float AngularRecipFixTime)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22585);

	UTslCheatManager_SetVehicleRepRotCorrection_Params params;
	params.AngularDeltaThreshold = AngularDeltaThreshold;
	params.AngularInterpAlpha = AngularInterpAlpha;
	params.AngularRecipFixTime = AngularRecipFixTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.SetVehicleRepPosCorrection
// (Final, Exec, Native, Public)
// Parameters:
// float                          LinearDeltaThresholdSq         (Parm, ZeroConstructor, IsPlainOldData)
// float                          LinearInterpAlpha              (Parm, ZeroConstructor, IsPlainOldData)
// float                          LinearRecipFixTime             (Parm, ZeroConstructor, IsPlainOldData)
// float                          BodySpeedThresholdSq           (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::SetVehicleRepPosCorrection(float LinearDeltaThresholdSq, float LinearInterpAlpha, float LinearRecipFixTime, float BodySpeedThresholdSq)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22580);

	UTslCheatManager_SetVehicleRepPosCorrection_Params params;
	params.LinearDeltaThresholdSq = LinearDeltaThresholdSq;
	params.LinearInterpAlpha = LinearInterpAlpha;
	params.LinearRecipFixTime = LinearRecipFixTime;
	params.BodySpeedThresholdSq = BodySpeedThresholdSq;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.SetSpectatorYawAndPitch
// (Final, Exec, Native, Public)
// Parameters:
// float                          Yaw                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Pitch                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          RevertSmoothSpeed              (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::SetSpectatorYawAndPitch(float Yaw, float Pitch, float RevertSmoothSpeed)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22576);

	UTslCheatManager_SetSpectatorYawAndPitch_Params params;
	params.Yaw = Yaw;
	params.Pitch = Pitch;
	params.RevertSmoothSpeed = RevertSmoothSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.SetClientConnectionTimeout
// (Final, Exec, Native, Public)
// Parameters:
// float                          TimeoutSeconds                 (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::SetClientConnectionTimeout(float TimeoutSeconds)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22574);

	UTslCheatManager_SetClientConnectionTimeout_Params params;
	params.TimeoutSeconds = TimeoutSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.SetBPFactor
// (Final, Exec, Native, Public)
// Parameters:
// float                          factor                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::SetBPFactor(float factor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22572);

	UTslCheatManager_SetBPFactor_Params params;
	params.factor = factor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ReturnLookAt
// (Final, Exec, Native, Public)

void UTslCheatManager::ReturnLookAt()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22571);

	UTslCheatManager_ReturnLookAt_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.OnInteract
// (Final, Native, Public)

void UTslCheatManager::OnInteract()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22570);

	UTslCheatManager_OnInteract_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.OnFullMapSequenceStop
// (Final, Native, Private)

void UTslCheatManager::OnFullMapSequenceStop()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22569);

	UTslCheatManager_OnFullMapSequenceStop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.MoveVehicleOnClient
// (Final, Exec, Native, Public)
// Parameters:
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::MoveVehicleOnClient(float X, float Y, float Z)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22565);

	UTslCheatManager_MoveVehicleOnClient_Params params;
	params.X = X;
	params.Y = Y;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.MapStatAnalyzer
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 Argument                       (Parm, ZeroConstructor)

void UTslCheatManager::MapStatAnalyzer(const struct FString& Argument)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22563);

	UTslCheatManager_MapStatAnalyzer_Params params;
	params.Argument = Argument;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.LookAt
// (Final, Exec, Native, Public)
// Parameters:
// float                          Pitch                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Yaw                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Roll                           (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::LookAt(float Pitch, float Yaw, float Roll)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22559);

	UTslCheatManager_LookAt_Params params;
	params.Pitch = Pitch;
	params.Yaw = Yaw;
	params.Roll = Roll;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ListCharacters
// (Final, Exec, Native, Public)

void UTslCheatManager::ListCharacters()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22558);

	UTslCheatManager_ListCharacters_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.InsertCrashMeCommand
// (Final, Native, Public)

void UTslCheatManager::InsertCrashMeCommand()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22557);

	UTslCheatManager_InsertCrashMeCommand_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ForceSetBaseNull
// (Final, Exec, Native, Public)

void UTslCheatManager::ForceSetBaseNull()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22556);

	UTslCheatManager_ForceSetBaseNull_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ForceMatchStart
// (Final, Exec, Native, Public)

void UTslCheatManager::ForceMatchStart()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22555);

	UTslCheatManager_ForceMatchStart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.DumpVoiceDevices
// (Final, Exec, Native, Public)

void UTslCheatManager::DumpVoiceDevices()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22554);

	UTslCheatManager_DumpVoiceDevices_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.DumpReplicatedItems
// (Final, Exec, Native, Public)

void UTslCheatManager::DumpReplicatedItems()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22553);

	UTslCheatManager_DumpReplicatedItems_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.DumpParticleManager
// (Final, Exec, Native, Public)
// Parameters:
// int                            Detail                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::DumpParticleManager(int Detail)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22551);

	UTslCheatManager_DumpParticleManager_Params params;
	params.Detail = Detail;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.DumpDestructibleComponents
// (Final, Exec, Native, Public)

void UTslCheatManager::DumpDestructibleComponents()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22550);

	UTslCheatManager_DumpDestructibleComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.DrawVehicleCenterOfMass
// (Final, Exec, Native, Public)

void UTslCheatManager::DrawVehicleCenterOfMass()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22549);

	UTslCheatManager_DrawVehicleCenterOfMass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.DelayCrash
// (Final, Exec, Native, Public)
// Parameters:
// float                          DelaySeconds                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::DelayCrash(float DelaySeconds)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22547);

	UTslCheatManager_DelayCrash_Params params;
	params.DelaySeconds = DelaySeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.CtrlShortCutOnOff
// (Final, Exec, Native, Public)
// Parameters:
// bool                           OnOff                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::CtrlShortCutOnOff(bool OnOff)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22545);

	UTslCheatManager_CtrlShortCutOnOff_Params params;
	params.OnOff = OnOff;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.CopyDebugInfoRotation
// (Final, Exec, Native, Public)

void UTslCheatManager::CopyDebugInfoRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22544);

	UTslCheatManager_CopyDebugInfoRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.CopyDebugInfoLocation
// (Final, Exec, Native, Public)

void UTslCheatManager::CopyDebugInfoLocation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22543);

	UTslCheatManager_CopyDebugInfoLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.CopyDebugInfo
// (Final, Exec, Native, Public)

void UTslCheatManager::CopyDebugInfo()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22542);

	UTslCheatManager_CopyDebugInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.Cheat
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 Msg                            (Parm, ZeroConstructor)

void UTslCheatManager::Cheat(const struct FString& Msg)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22540);

	UTslCheatManager_Cheat_Params params;
	params.Msg = Msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ChangeTeam
// (Final, Exec, Native, Public)
// Parameters:
// int                            NewTeamNumber                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslCheatManager::ChangeTeam(int NewTeamNumber)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22538);

	UTslCheatManager_ChangeTeam_Params params;
	params.NewTeamNumber = NewTeamNumber;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.BugItNoScreenshot
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 Description                    (Parm, ZeroConstructor)

void UTslCheatManager::BugItNoScreenshot(const struct FString& Description)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22536);

	UTslCheatManager_BugItNoScreenshot_Params params;
	params.Description = Description;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCheatManager.ActivatePakOrderingMode
// (Final, Exec, Native, Public)

void UTslCheatManager::ActivatePakOrderingMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22535);

	UTslCheatManager_ActivatePakOrderingMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslCoherentWidget.GoBack
// (Final, Native, Public, BlueprintCallable)

void UTslCoherentWidget::GoBack()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22657);

	UTslCoherentWidget_GoBack_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslDestructibleComponent.ClientReceiveComponentDamage
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                          DamageAmount                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FDamageEvent            DamageEvent                    (ConstParm, Parm, ReferenceParm)
// class AController*             EventInstigator                (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslDestructibleComponent::ClientReceiveComponentDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22845);

	UTslDestructibleComponent_ClientReceiveComponentDamage_Params params;
	params.DamageAmount = DamageAmount;
	params.DamageEvent = DamageEvent;
	params.EventInstigator = EventInstigator;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslDestructibleContainer.OnRep_Flag
// (Final, Native, Private)

void ATslDestructibleContainer::OnRep_Flag()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22850);

	ATslDestructibleContainer_OnRep_Flag_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslDoor.OnRep_DoorOpened
// (Final, Native, Protected)

void ATslDoor::OnRep_DoorOpened()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22860);

	ATslDoor_OnRep_DoorOpened_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslDoor.OnRep_DoorBreakingState
// (Final, Native, Protected)

void ATslDoor::OnRep_DoorBreakingState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22859);

	ATslDoor_OnRep_DoorBreakingState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslDoor.OnInteractBy
// (Native, Protected)
// Parameters:
// class ATslCharacter*           OtherCharacter                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslDoor::OnInteractBy(class ATslCharacter* OtherCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22857);

	ATslDoor_OnInteractBy_Params params;
	params.OtherCharacter = OtherCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslDoor.ClientTakeDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// float                          Damage                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize     HitLocation                    (ConstParm, Parm, ReferenceParm)
// float                          DamageRadius                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          Impulse                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslDoor::ClientTakeDamage(float Damage, const struct FVector_NetQuantize& HitLocation, float DamageRadius, float Impulse)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(22852);

	ATslDoor_ClientTakeDamage_Params params;
	params.Damage = Damage;
	params.HitLocation = HitLocation;
	params.DamageRadius = DamageRadius;
	params.Impulse = Impulse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEquippedWeaponsProxy.UpdateEquippedWeapons
// (Final, Native, Private)

void UTslEquippedWeaponsProxy::UpdateEquippedWeapons()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23246);

	UTslEquippedWeaponsProxy_UpdateEquippedWeapons_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEquippedWeaponsProxy.UpdateArmedWeapons
// (Final, Native, Private)

void UTslEquippedWeaponsProxy::UpdateArmedWeapons()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23245);

	UTslEquippedWeaponsProxy_UpdateArmedWeapons_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEquippedWeaponsProxy.UpdateAccessoryAttachmentSlot
// (Final, Native, Private)
// Parameters:
// EAccessorySlot                 Slot                           (Parm, ZeroConstructor, IsPlainOldData)

void UTslEquippedWeaponsProxy::UpdateAccessoryAttachmentSlot(EAccessorySlot Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23242);

	UTslEquippedWeaponsProxy_UpdateAccessoryAttachmentSlot_Params params;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslExplosionEffect.OnParticleCollide
// (Final, Native, Private, HasDefaults)
// Parameters:
// struct FName                   EventName                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          EmitterTime                    (Parm, ZeroConstructor, IsPlainOldData)
// int                            ParticleTime                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, IsPlainOldData)
// struct FVector                 Velocity                       (Parm, IsPlainOldData)
// struct FVector                 Direction                      (Parm, IsPlainOldData)
// struct FVector                 Normal                         (Parm, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslExplosionEffect::OnParticleCollide(const struct FName& EventName, float EmitterTime, int ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, const struct FName& BoneName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23252);

	ATslExplosionEffect_OnParticleCollide_Params params;
	params.EventName = EventName;
	params.EmitterTime = EmitterTime;
	params.ParticleTime = ParticleTime;
	params.Location = Location;
	params.Velocity = Velocity;
	params.Direction = Direction;
	params.Normal = Normal;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslExplosionReactionInterface.OnExplode
// (Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                          DamageAmout                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// TArray<struct FHitResult>      ComponentHits                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class AController*             EventInstigator                (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslExplosionReactionInterface::OnExplode(float DamageAmout, const struct FVector& Origin, TArray<struct FHitResult> ComponentHits, class AController* EventInstigator, class AActor* DamageCauser)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23268);

	UTslExplosionReactionInterface_OnExplode_Params params;
	params.DamageAmout = DamageAmout;
	params.Origin = Origin;
	params.ComponentHits = ComponentHits;
	params.EventInstigator = EventInstigator;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFence.GetSplineComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USplineComponent*        ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class USplineComponent* ATslFence::GetSplineComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23275);

	ATslFence_GetSplineComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslReactionComponent.OnRep_PendingDestroy
// (Final, Native, Protected)
// Parameters:
// bool                           PrevPendingDestroy             (Parm, ZeroConstructor, IsPlainOldData)

void UTslReactionComponent::OnRep_PendingDestroy(bool PrevPendingDestroy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23322);

	UTslReactionComponent_OnRep_PendingDestroy_Params params;
	params.PrevPendingDestroy = PrevPendingDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslReactionComponent.Client_ReactByVehicle
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FVector                 Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 ImpulseDir                     (ConstParm, Parm, IsPlainOldData)
// struct FVector                 Velocity                       (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void UTslReactionComponent::Client_ReactByVehicle(const struct FVector& Impact, const struct FVector& ImpulseDir, const struct FVector& Velocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23318);

	UTslReactionComponent_Client_ReactByVehicle_Params params;
	params.Impact = Impact;
	params.ImpulseDir = ImpulseDir;
	params.Velocity = Velocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslReactionComponent.Client_ReactByRadialDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// float                          DamageAmount                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 ImpulseDir                     (ConstParm, Parm, IsPlainOldData)
// float                          OuterRadius                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslReactionComponent::Client_ReactByRadialDamage(float DamageAmount, const struct FVector& Origin, const struct FVector& Impact, const struct FVector& ImpulseDir, float OuterRadius)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23312);

	UTslReactionComponent_Client_ReactByRadialDamage_Params params;
	params.DamageAmount = DamageAmount;
	params.Origin = Origin;
	params.Impact = Impact;
	params.ImpulseDir = ImpulseDir;
	params.OuterRadius = OuterRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslReactionComponent.Client_ReactByPointDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// float                          DamageAmount                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 ImpulseDir                     (ConstParm, Parm, IsPlainOldData)

void UTslReactionComponent::Client_ReactByPointDamage(float DamageAmount, const struct FVector& Impact, const struct FVector& ImpulseDir)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23308);

	UTslReactionComponent_Client_ReactByPointDamage_Params params;
	params.DamageAmount = DamageAmount;
	params.Impact = Impact;
	params.ImpulseDir = ImpulseDir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslFocusableWidgetInterface.Up
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::Up()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23381);

	UTslFocusableWidgetInterface_Up_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.SetFocus
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           NewFocus                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::SetFocus(bool NewFocus)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23378);

	UTslFocusableWidgetInterface_SetFocus_Params params;
	params.NewFocus = NewFocus;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.Right
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::Right()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23376);

	UTslFocusableWidgetInterface_Right_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.Left
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::Left()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23374);

	UTslFocusableWidgetInterface_Left_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.IsFocusable
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::IsFocusable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23372);

	UTslFocusableWidgetInterface_IsFocusable_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.IsFocus
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::IsFocus()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23370);

	UTslFocusableWidgetInterface_IsFocus_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputY
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::InputY()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23368);

	UTslFocusableWidgetInterface_InputY_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputX
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::InputX()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23366);

	UTslFocusableWidgetInterface_InputX_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputRT
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::InputRT()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23364);

	UTslFocusableWidgetInterface_InputRT_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputRB
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::InputRB()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23362);

	UTslFocusableWidgetInterface_InputRB_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputLT
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::InputLT()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23360);

	UTslFocusableWidgetInterface_InputLT_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputLB
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::InputLB()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23358);

	UTslFocusableWidgetInterface_InputLB_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputB
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::InputB()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23356);

	UTslFocusableWidgetInterface_InputB_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputA
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::InputA()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23354);

	UTslFocusableWidgetInterface_InputA_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetUpWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*             ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UUserWidget* UTslFocusableWidgetInterface::GetUpWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23352);

	UTslFocusableWidgetInterface_GetUpWidget_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetRightWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*             ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UUserWidget* UTslFocusableWidgetInterface::GetRightWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23350);

	UTslFocusableWidgetInterface_GetRightWidget_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetLeftWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*             ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UUserWidget* UTslFocusableWidgetInterface::GetLeftWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23348);

	UTslFocusableWidgetInterface_GetLeftWidget_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetFocusingChildWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*             ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UUserWidget* UTslFocusableWidgetInterface::GetFocusingChildWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23346);

	UTslFocusableWidgetInterface_GetFocusingChildWidget_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetDownWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*             ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UUserWidget* UTslFocusableWidgetInterface::GetDownWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23344);

	UTslFocusableWidgetInterface_GetDownWidget_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.Down
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslFocusableWidgetInterface::Down()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23342);

	UTslFocusableWidgetInterface_Down_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.SendSystemMessageToAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESystemMessageType             MessageType                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Message                        (Parm)
// float                          MessageDuration                (Parm, ZeroConstructor, IsPlainOldData)

void ATslGameMode::SendSystemMessageToAll(ESystemMessageType MessageType, const struct FText& Message, float MessageDuration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23469);

	ATslGameMode_SendSystemMessageToAll_Params params;
	params.MessageType = MessageType;
	params.Message = Message;
	params.MessageDuration = MessageDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameMode.OnUpdateGamePhase
// (Final, Native, Private)
// Parameters:
// int                            PhaseIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsRelease                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslGameMode::OnUpdateGamePhase(int PhaseIndex, bool bIsRelease)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23466);

	ATslGameMode_OnUpdateGamePhase_Params params;
	params.PhaseIndex = PhaseIndex;
	params.bIsRelease = bIsRelease;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameMode.NotifyRestrictingPlayAreaToAll
// (Final, Native, Public, BlueprintCallable)

void ATslGameMode::NotifyRestrictingPlayAreaToAll()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23465);

	ATslGameMode_NotifyRestrictingPlayAreaToAll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameMode.NotifyNextGasInToAll
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 PoisonGasWarningPosition       (Parm, IsPlainOldData)
// float                          PoisonGasWarningRadius         (Parm, ZeroConstructor, IsPlainOldData)

void ATslGameMode::NotifyNextGasInToAll(const struct FVector& PoisonGasWarningPosition, float PoisonGasWarningRadius)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23462);

	ATslGameMode_NotifyNextGasInToAll_Params params;
	params.PoisonGasWarningPosition = PoisonGasWarningPosition;
	params.PoisonGasWarningRadius = PoisonGasWarningRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameMode.IsPreventFinishMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslGameMode::IsPreventFinishMatch()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23460);

	ATslGameMode_IsPreventFinishMatch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.IsPlayInEditor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslGameMode::IsPlayInEditor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23458);

	ATslGameMode_IsPlayInEditor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.GetVivoxManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVivoxManager*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UVivoxManager* ATslGameMode::GetVivoxManager()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23456);

	ATslGameMode_GetVivoxManager_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.GetThingSpawnProcessor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UThingSpawnProcessor*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UThingSpawnProcessor* ATslGameMode::GetThingSpawnProcessor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23454);

	ATslGameMode_GetThingSpawnProcessor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.GetLobbyLink
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULobbyLink*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ULobbyLink* ATslGameMode::GetLobbyLink()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23452);

	ATslGameMode_GetLobbyLink_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.GetItemSpawnProcessor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemSpawnProcessor*     ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UItemSpawnProcessor* ATslGameMode::GetItemSpawnProcessor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23450);

	ATslGameMode_GetItemSpawnProcessor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.GetInProgressElapsedTimeSec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslGameMode::GetInProgressElapsedTimeSec()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23448);

	ATslGameMode_GetInProgressElapsedTimeSec_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.GetAllPawns
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<class APawn*>           OutPawns                       (Parm, OutParm, ZeroConstructor)

void ATslGameMode::GetAllPawns(TArray<class APawn*>* OutPawns)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23445);

	ATslGameMode_GetAllPawns_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPawns != nullptr)
		*OutPawns = params.OutPawns;
}


// Function TslGame.TslGameMode.FinishMatch
// (Final, Exec, Native, Public, BlueprintCallable)

void ATslGameMode::FinishMatch()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23444);

	ATslGameMode_FinishMatch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameMode.FindCharacterByPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*            State                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ATslGameMode::FindCharacterByPlayerState(class APlayerState* State)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23441);

	ATslGameMode_FindCharacterByPlayerState_Params params;
	params.State = State;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.CanDealDamage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerState*         DamageInstigator               (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class ATslPlayerState*         DamagedPlayer                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslGameMode::CanDealDamage(class ATslPlayerState* DamageInstigator, class ATslPlayerState* DamagedPlayer)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23437);

	ATslGameMode_CanDealDamage_Params params;
	params.DamageInstigator = DamageInstigator;
	params.DamagedPlayer = DamagedPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameMode.BroadcastGameModeEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   EventName                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Parameter                      (Parm, ZeroConstructor)

void ATslGameMode::BroadcastGameModeEvent(const struct FName& EventName, const struct FString& Parameter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23434);

	ATslGameMode_BroadcastGameModeEvent_Params params;
	params.EventName = EventName;
	params.Parameter = Parameter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameMode.BenchmarkFinished
// (Final, Native, Protected)

void ATslGameMode::BenchmarkFinished()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23433);

	ATslGameMode_BenchmarkFinished_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.WheelAxisNameToWheelActionName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey            Key                            (Parm)
// float                          InAxisScale                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UTslGameOption::WheelAxisNameToWheelActionName(const struct FTslInputKey& Key, float InAxisScale)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24210);

	UTslGameOption_WheelAxisNameToWheelActionName_Params params;
	params.Key = Key;
	params.InAxisScale = InAxisScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.SetWorldMapZoomLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            NewZoomLevel                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetWorldMapZoomLevel(int NewZoomLevel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24208);

	UTslGameOption_SetWorldMapZoomLevel_Params params;
	params.NewZoomLevel = NewZoomLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetVSyncEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetVSyncEnabled(bool bEnable)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24206);

	UTslGameOption_SetVSyncEnabled_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetVoiceOutputVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Volume                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetVoiceOutputVolume(int Volume)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24204);

	UTslGameOption_SetVoiceOutputVolume_Params params;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetVoiceOutputMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bIsMute                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetVoiceOutputMute(bool bIsMute)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24202);

	UTslGameOption_SetVoiceOutputMute_Params params;
	params.bIsMute = bIsMute;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetVoiceInputVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Volume                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetVoiceInputVolume(int Volume)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24200);

	UTslGameOption_SetVoiceInputVolume_Params params;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetVoiceInputMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bIsMute                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetVoiceInputMute(bool bIsMute)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24198);

	UTslGameOption_SetVoiceInputMute_Params params;
	params.bIsMute = bIsMute;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetUseTeamVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bUse                           (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetUseTeamVoice(bool bUse)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24196);

	UTslGameOption_SetUseTeamVoice_Params params;
	params.bUse = bUse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetUsePushToTalk
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bUse                           (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetUsePushToTalk(bool bUse)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24194);

	UTslGameOption_SetUsePushToTalk_Params params;
	params.bUse = bUse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetUseGlobalVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bUse                           (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetUseGlobalVoice(bool bUse)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24192);

	UTslGameOption_SetUseGlobalVoice_Params params;
	params.bUse = bUse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetUseCharacterCapture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bUseCharacterCapture           (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetUseCharacterCapture(bool bUseCharacterCapture)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24190);

	UTslGameOption_SetUseCharacterCapture_Params params;
	params.bUseCharacterCapture = bUseCharacterCapture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetUISoundVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          Volume                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetUISoundVolume(float Volume)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24188);

	UTslGameOption_SetUISoundVolume_Params params;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetUISoundMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bIsMute                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetUISoundMute(bool bIsMute)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24186);

	UTslGameOption_SetUISoundMute_Params params;
	params.bIsMute = bIsMute;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetTslInputMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EInputModeSettingActions       eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// ETslInputModes                 eTslInputMode                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetTslInputMode(EInputModeSettingActions eAction, ETslInputModes eTslInputMode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24181);

	UTslGameOption_SetTslInputMode_Params params;
	params.eAction = eAction;
	params.eTslInputMode = eTslInputMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetTpsWeaponIconShowType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUiShowType                    NewShowType                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetTpsWeaponIconShowType(EUiShowType NewShowType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24178);

	UTslGameOption_SetTpsWeaponIconShowType_Params params;
	params.NewShowType = NewShowType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetSelectMinimapTypeIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetSelectMinimapTypeIndex(int Index)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24176);

	UTslGameOption_SetSelectMinimapTypeIndex_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetScreenScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetScreenScale(float Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24174);

	UTslGameOption_SetScreenScale_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetScreenResoultion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FScreenResolution       ScreenResolution               (Parm)

void UTslGameOption::SetScreenResoultion(const struct FScreenResolution& ScreenResolution)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24172);

	UTslGameOption_SetScreenResoultion_Params params;
	params.ScreenResolution = ScreenResolution;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetQualityLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EQualityType                   Quality                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            QualityLevel                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetQualityLevel(EQualityType Quality, int QualityLevel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24168);

	UTslGameOption_SetQualityLevel_Params params;
	params.Quality = Quality;
	params.QualityLevel = QualityLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetOverallScalabilityLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetOverallScalabilityLevel(int Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24166);

	UTslGameOption_SetOverallScalabilityLevel_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetMouseSensitivity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FName                   InMouseSensitiveName           (Parm, ZeroConstructor, IsPlainOldData)
// float                          InMouseSensitivity             (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetMouseSensitivity(const struct FName& InMouseSensitiveName, float InMouseSensitivity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24163);

	UTslGameOption_SetMouseSensitivity_Params params;
	params.InMouseSensitiveName = InMouseSensitiveName;
	params.InMouseSensitivity = InMouseSensitivity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetMotionBlur
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bEnabled                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetMotionBlur(bool bEnabled)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24161);

	UTslGameOption_SetMotionBlur_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetMinimapColorType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMinimapColorType              InType                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetMinimapColorType(EMinimapColorType InType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24158);

	UTslGameOption_SetMinimapColorType_Params params;
	params.InType = InType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetMasterSoundVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          Volume                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetMasterSoundVolume(float Volume)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24156);

	UTslGameOption_SetMasterSoundVolume_Params params;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetMasterSoundMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bIsMute                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetMasterSoundMute(bool bIsMute)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24154);

	UTslGameOption_SetMasterSoundMute_Params params;
	params.bIsMute = bIsMute;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetInvertMouse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bInvert                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetInvertMouse(bool bInvert)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24152);

	UTslGameOption_SetInvertMouse_Params params;
	params.bInvert = bInvert;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetInvertGamePadY
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bInvert                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetInvertGamePadY(bool bInvert)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24150);

	UTslGameOption_SetInvertGamePadY_Params params;
	params.bInvert = bInvert;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetInvertGamePadX
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bInvert                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetInvertGamePadX(bool bInvert)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24148);

	UTslGameOption_SetInvertGamePadX_Params params;
	params.bInvert = bInvert;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetInputKey_Internal
// (Final, Native, Static, Public, HasOutParms)
// Parameters:
// TArray<struct FTslInputKey>    OutKeyList                     (Parm, OutParm, ZeroConstructor)
// struct FTslInputKey            NewKey                         (ConstParm, Parm, OutParm, ReferenceParm)
// EKeyBindingSlot                InKeyBindingSlot               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bGamepad                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetInputKey_Internal(const struct FTslInputKey& NewKey, EKeyBindingSlot InKeyBindingSlot, bool bGamepad, TArray<struct FTslInputKey>* OutKeyList)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24141);

	UTslGameOption_SetInputKey_Internal_Params params;
	params.NewKey = NewKey;
	params.InKeyBindingSlot = InKeyBindingSlot;
	params.bGamepad = bGamepad;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutKeyList != nullptr)
		*OutKeyList = params.OutKeyList;
}


// Function TslGame.TslGameOption.SetIconKillfeedEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetIconKillfeedEnabled(bool bEnable)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24139);

	UTslGameOption_SetIconKillfeedEnabled_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetGamma
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          Gamma                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetGamma(float Gamma)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24137);

	UTslGameOption_SetGamma_Params params;
	params.Gamma = Gamma;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetGamePadSensitivity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FName                   InGamePadSensitiveName         (Parm, ZeroConstructor, IsPlainOldData)
// float                          InGamePadSensitivity           (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetGamePadSensitivity(const struct FName& InGamePadSensitiveName, float InGamePadSensitivity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24134);

	UTslGameOption_SetGamePadSensitivity_Params params;
	params.InGamePadSensitiveName = InGamePadSensitiveName;
	params.InGamePadSensitivity = InGamePadSensitivity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetGamepadPresetType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGamepadPresets                InGamepadPreset                (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetGamepadPresetType(EGamepadPresets InGamepadPreset)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24131);

	UTslGameOption_SetGamepadPresetType_Params params;
	params.InGamepadPreset = InGamepadPreset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetGamePadDeadZone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          InGamePadDeadZone              (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetGamePadDeadZone(float InGamePadDeadZone)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24129);

	UTslGameOption_SetGamePadDeadZone_Params params;
	params.InGamePadDeadZone = InGamePadDeadZone;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetFullScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<EWindowMode>       InFullscreenMode               (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetFullScreen(TEnumAsByte<EWindowMode> InFullscreenMode)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24127);

	UTslGameOption_SetFullScreen_Params params;
	params.InFullscreenMode = InFullscreenMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetFpsWeaponSlotShow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bNewShow                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetFpsWeaponSlotShow(bool bNewShow)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24125);

	UTslGameOption_SetFpsWeaponSlotShow_Params params;
	params.bNewShow = bNewShow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetFpsCameraFov
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          NewFovValue                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetFpsCameraFov(float NewFovValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24123);

	UTslGameOption_SetFpsCameraFov_Params params;
	params.NewFovValue = NewFovValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetFppWeaponIconShowType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUiShowType                    NewShowType                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetFppWeaponIconShowType(EUiShowType NewShowType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24120);

	UTslGameOption_SetFppWeaponIconShowType_Params params;
	params.NewShowType = NewShowType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetFppEquipableItemIconShowType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUiShowType                    NewShowType                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetFppEquipableItemIconShowType(EUiShowType NewShowType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24117);

	UTslGameOption_SetFppEquipableItemIconShowType_Params params;
	params.NewShowType = NewShowType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetForceFeedbackEffectEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bEnabled                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetForceFeedbackEffectEnabled(bool bEnabled)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24115);

	UTslGameOption_SetForceFeedbackEffectEnabled_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetEquipableIteIconShow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bNewShow                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetEquipableIteIconShow(bool bNewShow)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24113);

	UTslGameOption_SetEquipableIteIconShow_Params params;
	params.bNewShow = bNewShow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetEnablePreloadingMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bEnabled                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetEnablePreloadingMap(bool bEnabled)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24111);

	UTslGameOption_SetEnablePreloadingMap_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetEnableFunctionality
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameplayFunctionalities       eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bValue                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetEnableFunctionality(EGameplayFunctionalities eAction, bool bValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24107);

	UTslGameOption_SetEnableFunctionality_Params params;
	params.eAction = eAction;
	params.bValue = bValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetEnableClientReplay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameplayClientReplay          eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bValue                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetEnableClientReplay(EGameplayClientReplay eAction, bool bValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24103);

	UTslGameOption_SetEnableClientReplay_Params params;
	params.eAction = eAction;
	params.bValue = bValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetEffectSoundVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          Volume                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetEffectSoundVolume(float Volume)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24101);

	UTslGameOption_SetEffectSoundVolume_Params params;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetEffectSoundMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bIsMute                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetEffectSoundMute(bool bIsMute)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24099);

	UTslGameOption_SetEffectSoundMute_Params params;
	params.bIsMute = bIsMute;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetCurrentProvider
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 ProviderName                   (Parm, ZeroConstructor)

void UTslGameOption::SetCurrentProvider(const struct FString& ProviderName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24097);

	UTslGameOption_SetCurrentProvider_Params params;
	params.ProviderName = ProviderName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetCurrentCultureName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 InCultureName                  (Parm, ZeroConstructor)

void UTslGameOption::SetCurrentCultureName(const struct FString& InCultureName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24095);

	UTslGameOption_SetCurrentCultureName_Params params;
	params.InCultureName = InCultureName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetCurrentCrosshairColorString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 CrosshairColorStr              (Parm, ZeroConstructor)

void UTslGameOption::SetCurrentCrosshairColorString(const struct FString& CrosshairColorStr)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24093);

	UTslGameOption_SetCurrentCrosshairColorString_Params params;
	params.CrosshairColorStr = CrosshairColorStr;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetCurrentColorBlindKeyByInt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            ColorBlindKey                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetCurrentColorBlindKeyByInt(int ColorBlindKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24091);

	UTslGameOption_SetCurrentColorBlindKeyByInt_Params params;
	params.ColorBlindKey = ColorBlindKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetCurrentColorBlindKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EColorBlindType                ColorBlindKey                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetCurrentColorBlindKey(EColorBlindType ColorBlindKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24088);

	UTslGameOption_SetCurrentColorBlindKey_Params params;
	params.ColorBlindKey = ColorBlindKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetBGMSoundVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          Volume                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetBGMSoundVolume(float Volume)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24086);

	UTslGameOption_SetBGMSoundVolume_Params params;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetBGMSoundMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bIsMute                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetBGMSoundMute(bool bIsMute)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24084);

	UTslGameOption_SetBGMSoundMute_Params params;
	params.bIsMute = bIsMute;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetAxisKeysToDefault
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   AxisName                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetAxisKeysToDefault(const struct FName& AxisName, float Scale)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24081);

	UTslGameOption_SetAxisKeysToDefault_Params params;
	params.AxisName = AxisName;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetAxisKeys
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   AxisName                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FTslInputKey>    NewKeys                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UTslGameOption::SetAxisKeys(const struct FName& AxisName, float Scale, TArray<struct FTslInputKey> NewKeys)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24076);

	UTslGameOption_SetAxisKeys_Params params;
	params.AxisName = AxisName;
	params.Scale = Scale;
	params.NewKeys = NewKeys;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetAxisKey
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   AxisName                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FTslInputKey            NewKey                         (ConstParm, Parm, OutParm, ReferenceParm)
// EKeyBindingSlot                InKeyBindingSlot               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bGamepad                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetAxisKey(const struct FName& AxisName, float Scale, const struct FTslInputKey& NewKey, EKeyBindingSlot InKeyBindingSlot, bool bGamepad)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24069);

	UTslGameOption_SetAxisKey_Params params;
	params.AxisName = AxisName;
	params.Scale = Scale;
	params.NewKey = NewKey;
	params.InKeyBindingSlot = InKeyBindingSlot;
	params.bGamepad = bGamepad;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetActionKeysToDefault
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   ActionName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UTslGameOption::SetActionKeysToDefault(const struct FName& ActionName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24067);

	UTslGameOption_SetActionKeysToDefault_Params params;
	params.ActionName = ActionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetActionKeys
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   ActionName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TArray<struct FTslInputKey>    NewKeys                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UTslGameOption::SetActionKeys(const struct FName& ActionName, TArray<struct FTslInputKey> NewKeys)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24063);

	UTslGameOption_SetActionKeys_Params params;
	params.ActionName = ActionName;
	params.NewKeys = NewKeys;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.SetActionKey
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   ActionName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FTslInputKey            NewKey                         (ConstParm, Parm, OutParm, ReferenceParm)
// EKeyBindingSlot                InKeyBindingSlot               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bGamepad                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::SetActionKey(const struct FName& ActionName, const struct FTslInputKey& NewKey, EKeyBindingSlot InKeyBindingSlot, bool bGamepad)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24057);

	UTslGameOption_SetActionKey_Params params;
	params.ActionName = ActionName;
	params.NewKey = NewKey;
	params.InKeyBindingSlot = InKeyBindingSlot;
	params.bGamepad = bGamepad;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.NotDuplicateCategoryNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   CatecoryName                   (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FName>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FName> UTslGameOption::NotDuplicateCategoryNames(const struct FName& CatecoryName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24053);

	UTslGameOption_NotDuplicateCategoryNames_Params params;
	params.CatecoryName = CatecoryName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsVSyncEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsVSyncEnabled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24051);

	UTslGameOption_IsVSyncEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsVoiceOutputMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsVoiceOutputMute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24049);

	UTslGameOption_IsVoiceOutputMute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsVoiceInputMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsVoiceInputMute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24047);

	UTslGameOption_IsVoiceInputMute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsUISoundMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsUISoundMute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24045);

	UTslGameOption_IsUISoundMute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsScorpio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsScorpio()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24043);

	UTslGameOption_IsScorpio_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsMouseWheelInput
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey            InInputedKey                   (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsMouseWheelInput(const struct FTslInputKey& InInputedKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24040);

	UTslGameOption_IsMouseWheelInput_Params params;
	params.InInputedKey = InInputedKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsModifierKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey            Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsModifierKey(const struct FTslInputKey& Key)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24037);

	UTslGameOption_IsModifierKey_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsMasterSoundMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsMasterSoundMute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24035);

	UTslGameOption_IsMasterSoundMute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsKeyValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey            Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsKeyValid(const struct FTslInputKey& Key)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24032);

	UTslGameOption_IsKeyValid_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsKeyUsed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey            Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsKeyUsed(const struct FTslInputKey& Key)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24029);

	UTslGameOption_IsKeyUsed_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsInvertMouse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsInvertMouse()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24027);

	UTslGameOption_IsInvertMouse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsInvertGamePadY
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsInvertGamePadY()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24025);

	UTslGameOption_IsInvertGamePadY_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsInvertGamePadX
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsInvertGamePadX()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24023);

	UTslGameOption_IsInvertGamePadX_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsIconKillfeedEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsIconKillfeedEnabled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24021);

	UTslGameOption_IsIconKillfeedEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsGamepadKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey            Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsGamepadKey(const struct FTslInputKey& Key)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24018);

	UTslGameOption_IsGamepadKey_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsFunctionalityEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameplayFunctionalities       eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsFunctionalityEnabled(EGameplayFunctionalities eAction)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24014);

	UTslGameOption_IsFunctionalityEnabled_Params params;
	params.eAction = eAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsForceFeedbackEffectEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsForceFeedbackEffectEnabled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24012);

	UTslGameOption_IsForceFeedbackEffectEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsEnabledPreloadingMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsEnabledPreloadingMap()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24010);

	UTslGameOption_IsEnabledPreloadingMap_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsEnabledMotionBlur
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsEnabledMotionBlur()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24008);

	UTslGameOption_IsEnabledMotionBlur_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsEffectSoundMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsEffectSoundMute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24006);

	UTslGameOption_IsEffectSoundMute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsDoubleTapSupported
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputModeSettingActions       eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsDoubleTapSupported(EInputModeSettingActions eAction)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24002);

	UTslGameOption_IsDoubleTapSupported_Params params;
	params.eAction = eAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsDefaultFunctionalityEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameplayFunctionalities       eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsDefaultFunctionalityEnabled(EGameplayFunctionalities eAction)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23998);

	UTslGameOption_IsDefaultFunctionalityEnabled_Params params;
	params.eAction = eAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsDefaultClientReplayEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameplayClientReplay          eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsDefaultClientReplayEnabled(EGameplayClientReplay eAction)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23994);

	UTslGameOption_IsDefaultClientReplayEnabled_Params params;
	params.eAction = eAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsClientReplayEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameplayClientReplay          eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsClientReplayEnabled(EGameplayClientReplay eAction)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23990);

	UTslGameOption_IsClientReplayEnabled_Params params;
	params.eAction = eAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.IsBGMSoundMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::IsBGMSoundMute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23988);

	UTslGameOption_IsBGMSoundMute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetWorldMapZoomSpeedLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslGameOption::GetWorldMapZoomSpeedLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23986);

	UTslGameOption_GetWorldMapZoomSpeedLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetVoiceOutputVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslGameOption::GetVoiceOutputVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23984);

	UTslGameOption_GetVoiceOutputVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetVoiceInputVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslGameOption::GetVoiceInputVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23982);

	UTslGameOption_GetVoiceInputVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetUseTeamVoice
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::GetUseTeamVoice()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23980);

	UTslGameOption_GetUseTeamVoice_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetUsePushToTalk
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::GetUsePushToTalk()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23978);

	UTslGameOption_GetUsePushToTalk_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetUseGlobalVoice
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::GetUseGlobalVoice()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23976);

	UTslGameOption_GetUseGlobalVoice_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetUseCharacterCapture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::GetUseCharacterCapture()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23974);

	UTslGameOption_GetUseCharacterCapture_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetUISoundVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetUISoundVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23972);

	UTslGameOption_GetUISoundVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetTslInputMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputModeSettingActions       eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// ETslInputModes                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ETslInputModes UTslGameOption::GetTslInputMode(EInputModeSettingActions eAction)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23967);

	UTslGameOption_GetTslInputMode_Params params;
	params.eAction = eAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetTpsWeaponIconShowType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUiShowType                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EUiShowType UTslGameOption::GetTpsWeaponIconShowType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23964);

	UTslGameOption_GetTpsWeaponIconShowType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetSupportedScreenResolutions
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FScreenResolution> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FScreenResolution> UTslGameOption::GetSupportedScreenResolutions()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23961);

	UTslGameOption_GetSupportedScreenResolutions_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetSupportedQualityLevels
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FSurportQualityLevel> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FSurportQualityLevel> UTslGameOption::GetSupportedQualityLevels()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23958);

	UTslGameOption_GetSupportedQualityLevels_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetSupportedKillcam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::GetSupportedKillcam()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23956);

	UTslGameOption_GetSupportedKillcam_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetSupportedFpsCameraFovRangeMin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetSupportedFpsCameraFovRangeMin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23954);

	UTslGameOption_GetSupportedFpsCameraFovRangeMin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetSupportedFpsCameraFovRangeMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetSupportedFpsCameraFovRangeMax()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23952);

	UTslGameOption_GetSupportedFpsCameraFovRangeMax_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetSupportedClientReplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::GetSupportedClientReplay()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23950);

	UTslGameOption_GetSupportedClientReplay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetSelectMiniMapTypeIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslGameOption::GetSelectMiniMapTypeIndex()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23948);

	UTslGameOption_GetSelectMiniMapTypeIndex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetScreenScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetScreenScale()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23946);

	UTslGameOption_GetScreenScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetScreenResolution
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScreenResolution       ReturnValue                    (Parm, OutParm, ReturnParm)

struct FScreenResolution UTslGameOption::GetScreenResolution()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23944);

	UTslGameOption_GetScreenResolution_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetReplayOptionEditable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslGameOption::GetReplayOptionEditable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23942);

	UTslGameOption_GetReplayOptionEditable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetQualityLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EQualityType                   Quality                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslGameOption::GetQualityLevel(EQualityType Quality)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23938);

	UTslGameOption_GetQualityLevel_Params params;
	params.Quality = Quality;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetOverallScalabilityLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslGameOption::GetOverallScalabilityLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23936);

	UTslGameOption_GetOverallScalabilityLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetNativeName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 InCultureName                  (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslGameOption::GetNativeName(const struct FString& InCultureName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23933);

	UTslGameOption_GetNativeName_Params params;
	params.InCultureName = InCultureName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetNativeLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 InCultureName                  (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslGameOption::GetNativeLanguage(const struct FString& InCultureName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23930);

	UTslGameOption_GetNativeLanguage_Params params;
	params.InCultureName = InCultureName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetMouseSensitivity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   InMouseSensitiveName           (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetMouseSensitivity(const struct FName& InMouseSensitiveName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23927);

	UTslGameOption_GetMouseSensitivity_Params params;
	params.InMouseSensitiveName = InMouseSensitiveName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetMiniMapTypes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FUiType>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FUiType> UTslGameOption::GetMiniMapTypes()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23924);

	UTslGameOption_GetMiniMapTypes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetMinimapColorType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMinimapColorType              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EMinimapColorType UTslGameOption::GetMinimapColorType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23921);

	UTslGameOption_GetMinimapColorType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetMasterSoundVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetMasterSoundVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23919);

	UTslGameOption_GetMasterSoundVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetKeyName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey            Key                            (Parm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UTslGameOption::GetKeyName(const struct FTslInputKey& Key)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23916);

	UTslGameOption_GetKeyName_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetKeyInputModeNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FKeyInputModeName> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FKeyInputModeName> UTslGameOption::GetKeyInputModeNames()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23913);

	UTslGameOption_GetKeyInputModeNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetGamma
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetGamma()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23911);

	UTslGameOption_GetGamma_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetGamePadSensitivity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   InGamePadSensitiveName         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetGamePadSensitivity(const struct FName& InGamePadSensitiveName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23908);

	UTslGameOption_GetGamePadSensitivity_Params params;
	params.InGamePadSensitiveName = InGamePadSensitiveName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetGamepadPresetType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGamepadPresets                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EGamepadPresets UTslGameOption::GetGamepadPresetType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23905);

	UTslGameOption_GetGamepadPresetType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetGamepadKeyPresetDatas
// (Final, Native, Static, Public)
// Parameters:
// TArray<struct FTslGamepadKeyPreset> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslGamepadKeyPreset> UTslGameOption::GetGamepadKeyPresetDatas()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23902);

	UTslGameOption_GetGamepadKeyPresetDatas_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetGamePadDeadZone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetGamePadDeadZone()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23900);

	UTslGameOption_GetGamePadDeadZone_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetFullscreenMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TEnumAsByte<EWindowMode>       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<EWindowMode> UTslGameOption::GetFullscreenMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23898);

	UTslGameOption_GetFullscreenMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetFpsCameraFov
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetFpsCameraFov()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23896);

	UTslGameOption_GetFpsCameraFov_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetFppWeaponIconShowType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUiShowType                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EUiShowType UTslGameOption::GetFppWeaponIconShowType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23893);

	UTslGameOption_GetFppWeaponIconShowType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetFppEquipableItemIconShowType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUiShowType                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EUiShowType UTslGameOption::GetFppEquipableItemIconShowType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23890);

	UTslGameOption_GetFppEquipableItemIconShowType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetEffectSoundVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetEffectSoundVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23888);

	UTslGameOption_GetEffectSoundVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetDefaultInputModeSetting
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputModeSettingActions       eAction                        (Parm, ZeroConstructor, IsPlainOldData)
// ETslInputModes                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ETslInputModes UTslGameOption::GetDefaultInputModeSetting(EInputModeSettingActions eAction)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23883);

	UTslGameOption_GetDefaultInputModeSetting_Params params;
	params.eAction = eAction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetDefaultGamepadPreset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGamepadPresets                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EGamepadPresets UTslGameOption::GetDefaultGamepadPreset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23880);

	UTslGameOption_GetDefaultGamepadPreset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetDefaultCultureName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslGameOption::GetDefaultCultureName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23878);

	UTslGameOption_GetDefaultCultureName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetCurrentProvider
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslGameOption::GetCurrentProvider()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23876);

	UTslGameOption_GetCurrentProvider_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetCurrentCultureName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslGameOption::GetCurrentCultureName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23874);

	UTslGameOption_GetCurrentCultureName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetCurrentCrosshairColorStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UTslGameOption::GetCurrentCrosshairColorStr()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23872);

	UTslGameOption_GetCurrentCrosshairColorStr_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetCurrentColorBlindKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EColorBlindType                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EColorBlindType UTslGameOption::GetCurrentColorBlindKey()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23869);

	UTslGameOption_GetCurrentColorBlindKey_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetCrosshairColors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FPresetColor>    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FPresetColor> UTslGameOption::GetCrosshairColors()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23866);

	UTslGameOption_GetCrosshairColors_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetConvertedMouseSensitivity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   InMouseSensitiveName           (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetConvertedMouseSensitivity(const struct FName& InMouseSensitiveName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23863);

	UTslGameOption_GetConvertedMouseSensitivity_Params params;
	params.InMouseSensitiveName = InMouseSensitiveName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetConvertedGamePadSensitivity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   InGamePadSensitiveName         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetConvertedGamePadSensitivity(const struct FName& InGamePadSensitiveName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23860);

	UTslGameOption_GetConvertedGamePadSensitivity_Params params;
	params.InGamePadSensitiveName = InGamePadSensitiveName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetColorBlindTypes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FColorBlindType> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FColorBlindType> UTslGameOption::GetColorBlindTypes()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23857);

	UTslGameOption_GetColorBlindTypes_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetBGMSoundVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::GetBGMSoundVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23855);

	UTslGameOption_GetBGMSoundVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetAxisKeys
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   AxisName                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDefault                       (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FTslInputKey>    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslInputKey> UTslGameOption::GetAxisKeys(const struct FName& AxisName, float Scale, bool bDefault)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23849);

	UTslGameOption_GetAxisKeys_Params params;
	params.AxisName = AxisName;
	params.Scale = Scale;
	params.bDefault = bDefault;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetAxisKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   AxisName                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bGamepad                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDefault                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bWantAnyKey                    (Parm, ZeroConstructor, IsPlainOldData)
// EKeyBindingSlot                eKeySlot                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FTslInputKey            ReturnValue                    (Parm, OutParm, ReturnParm)

struct FTslInputKey UTslGameOption::GetAxisKey(const struct FName& AxisName, float Scale, bool bGamepad, bool bDefault, bool bWantAnyKey, EKeyBindingSlot eKeySlot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23840);

	UTslGameOption_GetAxisKey_Params params;
	params.AxisName = AxisName;
	params.Scale = Scale;
	params.bGamepad = bGamepad;
	params.bDefault = bDefault;
	params.bWantAnyKey = bWantAnyKey;
	params.eKeySlot = eKeySlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetAvailableProviderNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FString> UTslGameOption::GetAvailableProviderNames()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23837);

	UTslGameOption_GetAvailableProviderNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetAvailableProviderDisplayNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FText>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FText> UTslGameOption::GetAvailableProviderDisplayNames()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23834);

	UTslGameOption_GetAvailableProviderDisplayNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetAutoQualityLevels
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            WorkScale                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          CPUMultiplier                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          GPUMultiplier                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FQualityLevelInfo> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FQualityLevelInfo> UTslGameOption::GetAutoQualityLevels(int WorkScale, float CPUMultiplier, float GPUMultiplier)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23828);

	UTslGameOption_GetAutoQualityLevels_Params params;
	params.WorkScale = WorkScale;
	params.CPUMultiplier = CPUMultiplier;
	params.GPUMultiplier = GPUMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetActionKeys
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   ActionName                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDefault                       (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FTslInputKey>    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslInputKey> UTslGameOption::GetActionKeys(const struct FName& ActionName, bool bDefault)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23823);

	UTslGameOption_GetActionKeys_Params params;
	params.ActionName = ActionName;
	params.bDefault = bDefault;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.GetActionKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   ActionName                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bGamepad                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDefault                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bWantAnyKey                    (Parm, ZeroConstructor, IsPlainOldData)
// EKeyBindingSlot                eKeySlot                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FTslInputKey            ReturnValue                    (Parm, OutParm, ReturnParm)

struct FTslInputKey UTslGameOption::GetActionKey(const struct FName& ActionName, bool bGamepad, bool bDefault, bool bWantAnyKey, EKeyBindingSlot eKeySlot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23815);

	UTslGameOption_GetActionKey_Params params;
	params.ActionName = ActionName;
	params.bGamepad = bGamepad;
	params.bDefault = bDefault;
	params.bWantAnyKey = bWantAnyKey;
	params.eKeySlot = eKeySlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.DefaultGamePadInnerDeadZone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslGameOption::DefaultGamePadInnerDeadZone()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23813);

	UTslGameOption_DefaultGamePadInnerDeadZone_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.CustomizableMouseSensitiveNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FCustomizableMouseSensitiveName> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FCustomizableMouseSensitiveName> UTslGameOption::CustomizableMouseSensitiveNames()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23810);

	UTslGameOption_CustomizableMouseSensitiveNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.CustomizableGamePadSensitiveNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FCustomizableGamePadSensitiveName> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FCustomizableGamePadSensitiveName> UTslGameOption::CustomizableGamePadSensitiveNames()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23807);

	UTslGameOption_CustomizableGamePadSensitiveNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.CustomizableCategoryData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FTslGame_FCustomizableCategoryData> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslGame_FCustomizableCategoryData> UTslGameOption::CustomizableCategoryData()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23804);

	UTslGameOption_CustomizableCategoryData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.CustomizableAxisName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FTslGame_FCustomizableAxisName> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslGame_FCustomizableAxisName> UTslGameOption::CustomizableAxisName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23801);

	UTslGameOption_CustomizableAxisName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.CustomizableActionNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FCustomizableActionName> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FCustomizableActionName> UTslGameOption::CustomizableActionNames()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23798);

	UTslGameOption_CustomizableActionNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.CultureNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FString> UTslGameOption::CultureNames()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23795);

	UTslGameOption_CultureNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.ClearAllGamepadKeyBinding
// (Final, Native, Static, Public)

void UTslGameOption::ClearAllGamepadKeyBinding()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23794);

	UTslGameOption_ClearAllGamepadKeyBinding_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.CastTslInputModeFromName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   InputModeName                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// ETslInputModes                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ETslInputModes UTslGameOption::CastTslInputModeFromName(const struct FName& InputModeName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23790);

	UTslGameOption_CastTslInputModeFromName_Params params;
	params.InputModeName = InputModeName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameOption.ApplyMouseSensitivity
// (Final, Native, Static, Public, BlueprintCallable)

void UTslGameOption::ApplyMouseSensitivity()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23789);

	UTslGameOption_ApplyMouseSensitivity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.ApplyGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bCheckForCommandLineOverrides  (Parm, ZeroConstructor, IsPlainOldData)

void UTslGameOption::ApplyGameUserSettings(bool bCheckForCommandLineOverrides)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23787);

	UTslGameOption_ApplyGameUserSettings_Params params;
	params.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.ApplyGamePadSensitivity
// (Final, Native, Static, Public, BlueprintCallable)

void UTslGameOption::ApplyGamePadSensitivity()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23786);

	UTslGameOption_ApplyGamePadSensitivity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.ApplyGamepadKeyPresetDatas
// (Final, Native, Static, Public)

void UTslGameOption::ApplyGamepadKeyPresetDatas()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23785);

	UTslGameOption_ApplyGamepadKeyPresetDatas_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.ApplyGamePadDeadZone
// (Final, Native, Static, Public, BlueprintCallable)

void UTslGameOption::ApplyGamePadDeadZone()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23784);

	UTslGameOption_ApplyGamePadDeadZone_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameOption.ApplyAutoQualitySetting
// (Final, Native, Static, Public, BlueprintCallable)

void UTslGameOption::ApplyAutoQualitySetting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(23783);

	UTslGameOption_ApplyAutoQualitySetting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.UpdateWorldTimeSecondsDelta
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                          DeltaSeconds                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslGameState::UpdateWorldTimeSecondsDelta(float DeltaSeconds)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24284);

	ATslGameState_UpdateWorldTimeSecondsDelta_Params params;
	params.DeltaSeconds = DeltaSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.UpdateMatchResultUI
// (Final, Native, Public)
// Parameters:
// class UTslUserWidget*          Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslGameState::UpdateMatchResultUI(class UTslUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24282);

	ATslGameState_UpdateMatchResultUI_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.ShowPlayerStateList
// (Final, Exec, Native, Public, Const)

void ATslGameState::ShowPlayerStateList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24281);

	ATslGameState_ShowPlayerStateList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.SendCustomTeamIdAndTeamIndex
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// TArray<int>                    TeamIds                        (ConstParm, Parm, ZeroConstructor, ReferenceParm)
// TArray<int>                    Indices                        (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void ATslGameState::SendCustomTeamIdAndTeamIndex(TArray<int> TeamIds, TArray<int> Indices)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24276);

	ATslGameState_SendCustomTeamIdAndTeamIndex_Params params;
	params.TeamIds = TeamIds;
	params.Indices = Indices;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnStartGasRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           InbIsGasRelease                (Parm, ZeroConstructor, IsPlainOldData)

void ATslGameState::OnStartGasRelease(bool InbIsGasRelease)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24274);

	ATslGameState_OnStartGasRelease_Params params;
	params.InbIsGasRelease = InbIsGasRelease;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_TimeUpTick
// (Final, Native, Public)

void ATslGameState::OnRep_TimeUpTick()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24273);

	ATslGameState_OnRep_TimeUpTick_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_TeamScores
// (Final, Native, Public)

void ATslGameState::OnRep_TeamScores()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24272);

	ATslGameState_OnRep_TeamScores_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_RemainingTime
// (Final, Native, Public)

void ATslGameState::OnRep_RemainingTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24271);

	ATslGameState_OnRep_RemainingTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_NumJoinPlayers
// (Final, Native, Public)

void ATslGameState::OnRep_NumJoinPlayers()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24270);

	ATslGameState_OnRep_NumJoinPlayers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_NumAlivePlayers
// (Final, Native, Public)

void ATslGameState::OnRep_NumAlivePlayers()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24269);

	ATslGameState_OnRep_NumAlivePlayers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_NextRespawnTimeTick
// (Final, Native, Public)

void ATslGameState::OnRep_NextRespawnTimeTick()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24268);

	ATslGameState_OnRep_NextRespawnTimeTick_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_MatchShortGuid
// (Final, Native, Public)

void ATslGameState::OnRep_MatchShortGuid()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24267);

	ATslGameState_OnRep_MatchShortGuid_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_MatchId
// (Final, Native, Public)

void ATslGameState::OnRep_MatchId()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24266);

	ATslGameState_OnRep_MatchId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_GoalScore
// (Final, Native, Public)

void ATslGameState::OnRep_GoalScore()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24265);

	ATslGameState_OnRep_GoalScore_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_GasRelease
// (Final, Native, Public)
// Parameters:
// bool                           bLastIsGasRelease              (Parm, ZeroConstructor, IsPlainOldData)

void ATslGameState::OnRep_GasRelease(bool bLastIsGasRelease)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24263);

	ATslGameState_OnRep_GasRelease_Params params;
	params.bLastIsGasRelease = bLastIsGasRelease;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.OnRep_bIsWarMode
// (Final, Native, Public)

void ATslGameState::OnRep_bIsWarMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24262);

	ATslGameState_OnRep_bIsWarMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGameState.IsTimeUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslGameState::IsTimeUp()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24260);

	ATslGameState_IsTimeUp_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameState.IsMatchInProgressBP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslGameState::IsMatchInProgressBP()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24258);

	ATslGameState_IsMatchInProgressBP_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGameState.GetLevelAttribute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALevelAttribute*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ALevelAttribute* ATslGameState::GetLevelAttribute()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24256);

	ATslGameState_GetLevelAttribute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslGlassWindowComponent.OnRep_ReplicatedOnClient
// (Final, Native, Protected)
// Parameters:
// bool                           bLastReplicatedOnClient        (Parm, ZeroConstructor, IsPlainOldData)

void UTslGlassWindowComponent::OnRep_ReplicatedOnClient(bool bLastReplicatedOnClient)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24351);

	UTslGlassWindowComponent_OnRep_ReplicatedOnClient_Params params;
	params.bLastReplicatedOnClient = bLastReplicatedOnClient;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGlassWindowComponent.OnRep_Destroyed
// (Final, Native, Protected)
// Parameters:
// bool                           bLastDestroyed                 (Parm, ZeroConstructor, IsPlainOldData)

void UTslGlassWindowComponent::OnRep_Destroyed(bool bLastDestroyed)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24349);

	UTslGlassWindowComponent_OnRep_Destroyed_Params params;
	params.bLastDestroyed = bLastDestroyed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGlassWindowComponent.ClientNotifyHit
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// bool                           bBlockingHit                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize     Location                       (ConstParm, Parm, ReferenceParm)
// struct FVector_NetQuantizeNormal ImpactNormal                   (ConstParm, Parm, ReferenceParm)

void UTslGlassWindowComponent::ClientNotifyHit(bool bBlockingHit, const struct FVector_NetQuantize& Location, const struct FVector_NetQuantizeNormal& ImpactNormal)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24345);

	UTslGlassWindowComponent_ClientNotifyHit_Params params;
	params.bBlockingHit = bBlockingHit;
	params.Location = Location;
	params.ImpactNormal = ImpactNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGunAnimInstance.HandleFiremodeMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*            FireModeMontage                (Parm, ZeroConstructor, IsPlainOldData)

void UTslGunAnimInstance::HandleFiremodeMontage(class UAnimMontage* FireModeMontage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24360);

	UTslGunAnimInstance_HandleFiremodeMontage_Params params;
	params.FireModeMontage = FireModeMontage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHealthGaugeData.GetGaugeColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          HealthPercent                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FLinearColor UTslHealthGaugeData::GetGaugeColor(float HealthPercent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24377);

	UTslHealthGaugeData_GetGaugeColor_Params params;
	params.HealthPercent = HealthPercent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslHornComponent.TickHorn
// (Final, Native, Protected)
// Parameters:
// float                          DeltaSeconds                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslHornComponent::TickHorn(float DeltaSeconds)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24402);

	UTslHornComponent_TickHorn_Params params;
	params.DeltaSeconds = DeltaSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHornComponent.ServerSetHorn
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FHornPlayInfo           InHornPlayInfo                 (Parm, IsPlainOldData)

void UTslHornComponent::ServerSetHorn(const struct FHornPlayInfo& InHornPlayInfo)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24400);

	UTslHornComponent_ServerSetHorn_Params params;
	params.InHornPlayInfo = InHornPlayInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHornComponent.PlayInstantHorn
// (Final, Native, Protected)

void UTslHornComponent::PlayInstantHorn()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24399);

	UTslHornComponent_PlayInstantHorn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHornComponent.PlayHorn
// (Final, Native, Protected)
// Parameters:
// bool                           bIsLocalPlay                   (Parm, ZeroConstructor, IsPlainOldData)
// EHornSoundType                 InHornSoundType                (Parm, ZeroConstructor, IsPlainOldData)

void UTslHornComponent::PlayHorn(bool bIsLocalPlay, EHornSoundType InHornSoundType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24395);

	UTslHornComponent_PlayHorn_Params params;
	params.bIsLocalPlay = bIsLocalPlay;
	params.InHornSoundType = InHornSoundType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHornComponent.OnRep_SetHornPlayInfo
// (Final, Native, Protected)

void UTslHornComponent::OnRep_SetHornPlayInfo()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24394);

	UTslHornComponent_OnRep_SetHornPlayInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHornComponent.OnPostDriverLeave
// (Final, Native, Public)

void UTslHornComponent::OnPostDriverLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24393);

	UTslHornComponent_OnPostDriverLeave_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHornComponent.OnHornKeyUpPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslHornComponent::OnHornKeyUpPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24391);

	UTslHornComponent_OnHornKeyUpPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslHornComponent.OnHornKeyUp
// (Final, Native, Public)

void UTslHornComponent::OnHornKeyUp()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24390);

	UTslHornComponent_OnHornKeyUp_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHornComponent.OnHornKeyDownPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslHornComponent::OnHornKeyDownPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24388);

	UTslHornComponent_OnHornKeyDownPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslHornComponent.OnHornKeyDown
// (Final, Native, Public)

void UTslHornComponent::OnHornKeyDown()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24387);

	UTslHornComponent_OnHornKeyDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHornComponent.OnHornEnd
// (Final, Native, Protected)

void UTslHornComponent::OnHornEnd()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24386);

	UTslHornComponent_OnHornEnd_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHornComponent.MulticastSetInstantHorn
// (Net, NetReliable, Native, Event, NetMulticast, Protected, NetValidate)
// Parameters:
// struct FHornPlayInfo           InHornPlayInfo                 (Parm, IsPlainOldData)

void UTslHornComponent::MulticastSetInstantHorn(const struct FHornPlayInfo& InHornPlayInfo)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24384);

	UTslHornComponent_MulticastSetInstantHorn_Params params;
	params.InHornPlayInfo = InHornPlayInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslParticleInterface.WakeUp_BP
// (Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform              InitialTransform               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UTslParticleInterface::WakeUp_BP(const struct FTransform& InitialTransform)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24413);

	UTslParticleInterface_WakeUp_BP_Params params;
	params.InitialTransform = InitialTransform;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslParticleInterface.PutToSleep_BP
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UTslParticleInterface::PutToSleep_BP()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24412);

	UTslParticleInterface_PutToSleep_BP_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslInstancedGlassWindowComponent.OnRep_ReplicatedOnClient
// (Final, Native, Protected)
// Parameters:
// bool                           bLastReplicatedOnClient        (Parm, ZeroConstructor, IsPlainOldData)

void UTslInstancedGlassWindowComponent::OnRep_ReplicatedOnClient(bool bLastReplicatedOnClient)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24511);

	UTslInstancedGlassWindowComponent_OnRep_ReplicatedOnClient_Params params;
	params.bLastReplicatedOnClient = bLastReplicatedOnClient;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslInstancedGlassWindowComponent.OnRep_PendingDestroy
// (Final, Native, Protected)

void UTslInstancedGlassWindowComponent::OnRep_PendingDestroy()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24510);

	UTslInstancedGlassWindowComponent_OnRep_PendingDestroy_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslInstancedGlassWindowComponent.OnRep_Destroyed
// (Final, Native, Protected)

void UTslInstancedGlassWindowComponent::OnRep_Destroyed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24509);

	UTslInstancedGlassWindowComponent_OnRep_Destroyed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslInstancedGlassWindowComponent.ClientNotifyHit
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// bool                           bBlockingHit                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize     Location                       (ConstParm, Parm, ReferenceParm)
// struct FVector_NetQuantizeNormal ImpactNormal                   (ConstParm, Parm, ReferenceParm)
// int                            InstanceIndex                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslInstancedGlassWindowComponent::ClientNotifyHit(bool bBlockingHit, const struct FVector_NetQuantize& Location, const struct FVector_NetQuantizeNormal& ImpactNormal, int InstanceIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24504);

	UTslInstancedGlassWindowComponent_ClientNotifyHit_Params params;
	params.bBlockingHit = bBlockingHit;
	params.Location = Location;
	params.ImpactNormal = ImpactNormal;
	params.InstanceIndex = InstanceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslInstancedReactionComponent.OnRep_PendingDestroy
// (Final, Native, Protected)

void UTslInstancedReactionComponent::OnRep_PendingDestroy()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24539);

	UTslInstancedReactionComponent_OnRep_PendingDestroy_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslInstancedReactionComponent.Client_ReactByVehicle
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// int                            InstanceIndex                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 ImpulseDir                     (ConstParm, Parm, IsPlainOldData)
// struct FVector                 Velocity                       (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void UTslInstancedReactionComponent::Client_ReactByVehicle(int InstanceIndex, const struct FVector& Impact, const struct FVector& ImpulseDir, const struct FVector& Velocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24534);

	UTslInstancedReactionComponent_Client_ReactByVehicle_Params params;
	params.InstanceIndex = InstanceIndex;
	params.Impact = Impact;
	params.ImpulseDir = ImpulseDir;
	params.Velocity = Velocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslInstancedReactionComponent.Client_ReactByRadialDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// int                            InstanceIndex                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DamageAmount                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 ImpulseDir                     (ConstParm, Parm, IsPlainOldData)
// float                          OuterRadius                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslInstancedReactionComponent::Client_ReactByRadialDamage(int InstanceIndex, float DamageAmount, const struct FVector& Origin, const struct FVector& Impact, const struct FVector& ImpulseDir, float OuterRadius)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24527);

	UTslInstancedReactionComponent_Client_ReactByRadialDamage_Params params;
	params.InstanceIndex = InstanceIndex;
	params.DamageAmount = DamageAmount;
	params.Origin = Origin;
	params.Impact = Impact;
	params.ImpulseDir = ImpulseDir;
	params.OuterRadius = OuterRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslInstancedReactionComponent.Client_ReactByPointDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// int                            InstanceIndex                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DamageAmount                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 ImpulseDir                     (ConstParm, Parm, IsPlainOldData)

void UTslInstancedReactionComponent::Client_ReactByPointDamage(int InstanceIndex, float DamageAmount, const struct FVector& Impact, const struct FVector& ImpulseDir)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24522);

	UTslInstancedReactionComponent_Client_ReactByPointDamage_Params params;
	params.InstanceIndex = InstanceIndex;
	params.DamageAmount = DamageAmount;
	params.Impact = Impact;
	params.ImpulseDir = ImpulseDir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLevelScriptActor.RequestReplayALevelWeatherEvent
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// struct FString                 EventID                        (Parm, ZeroConstructor)

void ATslLevelScriptActor::RequestReplayALevelWeatherEvent(const struct FString& EventID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24567);

	ATslLevelScriptActor_RequestReplayALevelWeatherEvent_Params params;
	params.EventID = EventID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLevelScriptActor.RecordWeatherAsCustomEvent
// (Final, Native, Private)

void ATslLevelScriptActor::RecordWeatherAsCustomEvent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24566);

	ATslLevelScriptActor_RecordWeatherAsCustomEvent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLevelScriptActor.OnRep_SelectedWeatherIndex
// (Final, Native, Private)

void ATslLevelScriptActor::OnRep_SelectedWeatherIndex()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24565);

	ATslLevelScriptActor_OnRep_SelectedWeatherIndex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLevelScriptActor.EnumerateReplayLevelEvents
// (Final, Native, Private, BlueprintCallable)

void ATslLevelScriptActor::EnumerateReplayLevelEvents()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24564);

	ATslLevelScriptActor_EnumerateReplayLevelEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLobbyLevelScriptActor.LatentLoadCustomizationLevel
// (Final, Native, Public)

void ATslLobbyLevelScriptActor::LatentLoadCustomizationLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24573);

	ATslLobbyLevelScriptActor_LatentLoadCustomizationLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslModularBuilding.PassSeparatedFloors
// (Final, Native, Protected, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<class UChildActorComponent*> Floors                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void ATslModularBuilding::PassSeparatedFloors(TArray<class UChildActorComponent*> Floors)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24612);

	ATslModularBuilding_PassSeparatedFloors_Params params;
	params.Floors = Floors;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslModularBuilding.GetMeshOnSapartedFloor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int                            SepartedFloor                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Keyword                        (Parm, ZeroConstructor)
// TArray<class UStaticMeshComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UStaticMeshComponent*> ATslModularBuilding::GetMeshOnSapartedFloor(int SepartedFloor, const struct FString& Keyword)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24607);

	ATslModularBuilding_GetMeshOnSapartedFloor_Params params;
	params.SepartedFloor = SepartedFloor;
	params.Keyword = Keyword;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslModularBuilding.GetBuildingModuleFromTable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FString                 Keyword                        (Parm, ZeroConstructor)
// TArray<class UStaticMeshComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UStaticMeshComponent*> ATslModularBuilding::GetBuildingModuleFromTable(const struct FString& Keyword)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24603);

	ATslModularBuilding_GetBuildingModuleFromTable_Params params;
	params.Keyword = Keyword;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslModularBuilding.GetAttachmentsFromTable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FString                 Keyword                        (Parm, ZeroConstructor)
// TArray<class UStaticMeshComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UStaticMeshComponent*> ATslModularBuilding::GetAttachmentsFromTable(const struct FString& Keyword)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24599);

	ATslModularBuilding_GetAttachmentsFromTable_Params params;
	params.Keyword = Keyword;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslModularBuilding.ClearBuildingModuleTable
// (Final, Native, Protected, BlueprintCallable)

void ATslModularBuilding::ClearBuildingModuleTable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24598);

	ATslModularBuilding_ClearBuildingModuleTable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslModularBuilding.ClearAttachmentTable
// (Final, Native, Protected, BlueprintCallable)

void ATslModularBuilding::ClearAttachmentTable()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24597);

	ATslModularBuilding_ClearAttachmentTable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslModularBuilding.AddBuildingModuleToTable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FString                 Keyword                        (Parm, ZeroConstructor)
// class UStaticMeshComponent*    Building                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslModularBuilding::AddBuildingModuleToTable(const struct FString& Keyword, class UStaticMeshComponent* Building)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24594);

	ATslModularBuilding_AddBuildingModuleToTable_Params params;
	params.Keyword = Keyword;
	params.Building = Building;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslModularBuilding.AddAttachmentToTable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FString                 Keyword                        (Parm, ZeroConstructor)
// class UStaticMeshComponent*    Attachment                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslModularBuilding::AddAttachmentToTable(const struct FString& Keyword, class UStaticMeshComponent* Attachment)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24591);

	ATslModularBuilding_AddAttachmentToTable_Params params;
	params.Keyword = Keyword;
	params.Attachment = Attachment;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslParticle.SetParticleParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 Name                           (Parm, ZeroConstructor)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableRTPC                    (Parm, ZeroConstructor, IsPlainOldData)

void ATslParticle::SetParticleParameter(const struct FString& Name, float Value, bool bEnableRTPC)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24638);

	ATslParticle_SetParticleParameter_Params params;
	params.Name = Name;
	params.Value = Value;
	params.bEnableRTPC = bEnableRTPC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslParticle.OnParticleFinish
// (Final, Native, Protected)
// Parameters:
// class UParticleSystemComponent* PSystem                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslParticle::OnParticleFinish(class UParticleSystemComponent* PSystem)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24636);

	ATslParticle_OnParticleFinish_Params params;
	params.PSystem = PSystem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslParticle.OnParticleCollide
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FName                   EventName                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          EmitterTime                    (Parm, ZeroConstructor, IsPlainOldData)
// int                            ParticleTime                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, IsPlainOldData)
// struct FVector                 Velocity                       (Parm, IsPlainOldData)
// struct FVector                 Direction                      (Parm, IsPlainOldData)
// struct FVector                 Normal                         (Parm, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// class UPhysicalMaterial*       PhysMat                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslParticle::OnParticleCollide(const struct FName& EventName, float EmitterTime, int ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, const struct FName& BoneName, class UPhysicalMaterial* PhysMat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24626);

	ATslParticle_OnParticleCollide_Params params;
	params.EventName = EventName;
	params.EmitterTime = EmitterTime;
	params.ParticleTime = ParticleTime;
	params.Location = Location;
	params.Velocity = Velocity;
	params.Direction = Direction;
	params.Normal = Normal;
	params.BoneName = BoneName;
	params.PhysMat = PhysMat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslParticle.OnParameterUpdated
// (Event, Protected, BlueprintEvent)

void ATslParticle::OnParameterUpdated()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24625);

	ATslParticle_OnParameterUpdated_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslParticle.GetParticleParamter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 Name                           (Parm, ZeroConstructor)
// float                          DefaultValue                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslParticle::GetParticleParamter(const struct FString& Name, float DefaultValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24621);

	ATslParticle_GetParticleParamter_Params params;
	params.Name = Name;
	params.DefaultValue = DefaultValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslParticle.GetEmitterGlobalSpawnRateScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslParticle::GetEmitterGlobalSpawnRateScale()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24619);

	ATslParticle_GetEmitterGlobalSpawnRateScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslParticle.ForceSpawn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            emitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InLocation                     (ConstParm, Parm, IsPlainOldData)

void ATslParticle::ForceSpawn(int emitterIndex, const struct FVector& InLocation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24616);

	ATslParticle_ForceSpawn_Params params;
	params.emitterIndex = emitterIndex;
	params.InLocation = InLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslParticle.AttachToParent
// (Final, Native, Protected)

void ATslParticle::AttachToParent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24615);

	ATslParticle_AttachToParent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslParticleEmitter.OnParticleSystemFinished
// (Native, Public)
// Parameters:
// class UParticleSystemComponent* FinishedComponent              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslParticleEmitter::OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24662);

	ATslParticleEmitter_OnParticleSystemFinished_Params params;
	params.FinishedComponent = FinishedComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPawnInputBindingComponent.OnUseHealItemPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslPawnInputBindingComponent::OnUseHealItemPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24689);

	UTslPawnInputBindingComponent_OnUseHealItemPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPawnInputBindingComponent.OnSelectNextHealItemPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslPawnInputBindingComponent::OnSelectNextHealItemPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24687);

	UTslPawnInputBindingComponent_OnSelectNextHealItemPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPawnInputBindingComponent.OnMoveVehicleSeatPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslPawnInputBindingComponent::OnMoveVehicleSeatPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24685);

	UTslPawnInputBindingComponent_OnMoveVehicleSeatPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPawnInputBindingComponent.OnMoveToDriverSeatPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslPawnInputBindingComponent::OnMoveToDriverSeatPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24683);

	UTslPawnInputBindingComponent_OnMoveToDriverSeatPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPawnInputBindingComponent.OnInteractInVehiclePad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslPawnInputBindingComponent::OnInteractInVehiclePad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24681);

	UTslPawnInputBindingComponent_OnInteractInVehiclePad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPawnInputBindingComponent.NotifyOwnerUnPossessed
// (Final, Native, Public)
// Parameters:
// class ATslPlayerController*    InController                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslPawnInputBindingComponent::NotifyOwnerUnPossessed(class ATslPlayerController* InController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24679);

	UTslPawnInputBindingComponent_NotifyOwnerUnPossessed_Params params;
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPawnInputBindingComponent.NotifyOwnerPossessed
// (Final, Native, Public)
// Parameters:
// class ATslPlayerController*    InController                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslPawnInputBindingComponent::NotifyOwnerPossessed(class ATslPlayerController* InController)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24677);

	UTslPawnInputBindingComponent_NotifyOwnerPossessed_Params params;
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPawnInputBindingComponent.MoveVehicleNextSeat_Gamepad
// (Final, Native, Private)

void UTslPawnInputBindingComponent::MoveVehicleNextSeat_Gamepad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24676);

	UTslPawnInputBindingComponent_MoveVehicleNextSeat_Gamepad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPawnInputBindingComponent.MoveVehicleDriverSeat_Gamepad
// (Final, Native, Private)

void UTslPawnInputBindingComponent::MoveVehicleDriverSeat_Gamepad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24675);

	UTslPawnInputBindingComponent_MoveVehicleDriverSeat_Gamepad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.SetEmoteBitArray
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FEmoteBitArray          InBitArray                     (Parm)

void ATslPlayerState::SetEmoteBitArray(const struct FEmoteBitArray& InBitArray)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24910);

	ATslPlayerState_SetEmoteBitArray_Params params;
	params.InBitArray = InBitArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.OnRep_ReportToken
// (Final, Native, Protected)
// Parameters:
// struct FString                 OldReportToken                 (Parm, ZeroConstructor)

void ATslPlayerState::OnRep_ReportToken(const struct FString& OldReportToken)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24908);

	ATslPlayerState_OnRep_ReportToken_Params params;
	params.OldReportToken = OldReportToken;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.OnRep_Ranking
// (Final, Native, Protected)
// Parameters:
// int                            OldRanking                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerState::OnRep_Ranking(int OldRanking)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24906);

	ATslPlayerState_OnRep_Ranking_Params params;
	params.OldRanking = OldRanking;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.OnRep_PlayerStatisticsForOwner
// (Final, Native, Protected)

void ATslPlayerState::OnRep_PlayerStatisticsForOwner()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24905);

	ATslPlayerState_OnRep_PlayerStatisticsForOwner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.OnRep_PlayerStatistics
// (Final, Native, Protected)
// Parameters:
// struct FTslPlayerStatistics    OldPlayerStatistics            (Parm)

void ATslPlayerState::OnRep_PlayerStatistics(const struct FTslPlayerStatistics& OldPlayerStatistics)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24903);

	ATslPlayerState_OnRep_PlayerStatistics_Params params;
	params.OldPlayerStatistics = OldPlayerStatistics;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.OnRep_LastHitTime
// (Final, Native, Protected)

void ATslPlayerState::OnRep_LastHitTime()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24902);

	ATslPlayerState_OnRep_LastHitTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.IsZombie
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerState::IsZombie()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24900);

	ATslPlayerState_IsZombie_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.IsQuitter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerState::IsQuitter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24898);

	ATslPlayerState_IsQuitter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.IsObserver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerState::IsObserver()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24896);

	ATslPlayerState_IsObserver_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.IsInAircraft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPlayerState::IsInAircraft()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24894);

	ATslPlayerState_IsInAircraft_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.InformAboutKill
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EDamageReason                  DamageReason                   (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// class UDamageType*             DamageType                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerState::InformAboutKill(EDamageReason DamageReason, class AActor* DamageCauser, class UDamageType* DamageType, float Distance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24888);

	ATslPlayerState_InformAboutKill_Params params;
	params.DamageReason = DamageReason;
	params.DamageCauser = DamageCauser;
	params.DamageType = DamageType;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.GetTotalScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPlayerState::GetTotalScore()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24886);

	ATslPlayerState_GetTotalScore_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetTeamNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslPlayerState::GetTeamNum()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24884);

	ATslPlayerState_GetTeamNum_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetShortPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString ATslPlayerState::GetShortPlayerName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24882);

	ATslPlayerState_GetShortPlayerName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetScoreByRanking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPlayerState::GetScoreByRanking()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24880);

	ATslPlayerState_GetScoreByRanking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetScoreByKill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPlayerState::GetScoreByKill()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24878);

	ATslPlayerState_GetScoreByKill_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetScoreByDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPlayerState::GetScoreByDamage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24876);

	ATslPlayerState_GetScoreByDamage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetPlayerScores
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTslPlayerScores        ReturnValue                    (Parm, OutParm, ReturnParm)

struct FTslPlayerScores ATslPlayerState::GetPlayerScores()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24874);

	ATslPlayerState_GetPlayerScores_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetPing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPlayerState::GetPing()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24872);

	ATslPlayerState_GetPing_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetOwningTslPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerController*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerController* ATslPlayerState::GetOwningTslPlayerController()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24870);

	ATslPlayerState_GetOwningTslPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetObserverAuthorityType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverAuthorityType         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EObserverAuthorityType ATslPlayerState::GetObserverAuthorityType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24867);

	ATslPlayerState_GetObserverAuthorityType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetKills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslPlayerState::GetKills()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24865);

	ATslPlayerState_GetKills_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.GetEmoteBitArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEmoteBitArray          ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEmoteBitArray ATslPlayerState::GetEmoteBitArray()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24863);

	ATslPlayerState_GetEmoteBitArray_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPlayerState.ClientInformFirstKill
// (Net, NetReliable, Native, Event, Public, NetClient, Const)

void ATslPlayerState::ClientInformFirstKill()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24862);

	ATslPlayerState_ClientInformFirstKill_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.ClientInformAssist
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerState::ClientInformAssist()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24861);

	ATslPlayerState_ClientInformAssist_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPlayerState.BroadcastDeath
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ATslPlayerState*         KillerPlayerState              (Parm, ZeroConstructor, IsPlainOldData)
// class ATslPlayerState*         GroggyPlayerInstigator         (Parm, ZeroConstructor, IsPlainOldData)
// class UDamageType*             KillerDamageType               (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// EDamageReason                  DamageReason                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   DamageCauserName               (ConstParm, Parm, ReferenceParm)
// class UClass*                  DamageCauserClass              (Parm, ZeroConstructor, IsPlainOldData)
// int                            AlivePlayerNum                 (Parm, ZeroConstructor, IsPlainOldData)
// int                            AliveTeamNum                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbIsStealKilled               (Parm, ZeroConstructor, IsPlainOldData)

void ATslPlayerState::BroadcastDeath(class ATslPlayerState* KillerPlayerState, class ATslPlayerState* GroggyPlayerInstigator, class UDamageType* KillerDamageType, EDamageReason DamageReason, const struct FText& DamageCauserName, class UClass* DamageCauserClass, int AlivePlayerNum, int AliveTeamNum, bool InbIsStealKilled)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24850);

	ATslPlayerState_BroadcastDeath_Params params;
	params.KillerPlayerState = KillerPlayerState;
	params.GroggyPlayerInstigator = GroggyPlayerInstigator;
	params.KillerDamageType = KillerDamageType;
	params.DamageReason = DamageReason;
	params.DamageCauserName = DamageCauserName;
	params.DamageCauserClass = DamageCauserClass;
	params.AlivePlayerNum = AlivePlayerNum;
	params.AliveTeamNum = AliveTeamNum;
	params.InbIsStealKilled = InbIsStealKilled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPostProcessEffect.SetMaterialVectorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            idx                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            Value                          (Parm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPostProcessEffect::SetMaterialVectorParameter(int idx, const struct FName& ParameterName, const struct FLinearColor& Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24960);

	ATslPostProcessEffect_SetMaterialVectorParameter_Params params;
	params.idx = idx;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.SetMaterialParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            idx                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPostProcessEffect::SetMaterialParameter(int idx, const struct FName& ParameterName, float Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24955);

	ATslPostProcessEffect_SetMaterialParameter_Params params;
	params.idx = idx;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.SetMaterialBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            idx                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPostProcessEffect::SetMaterialBlendWeight(int idx, float Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24951);

	ATslPostProcessEffect_SetMaterialBlendWeight_Params params;
	params.idx = idx;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.SetEffectParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 ParameterName                  (Parm, ZeroConstructor)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPostProcessEffect::SetEffectParameter(const struct FString& ParameterName, float Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24947);

	ATslPostProcessEffect_SetEffectParameter_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.SetDepthOfFieldFarBlurSize
// (Final, Native, Public)
// Parameters:
// float                          NewBlurSize                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslPostProcessEffect::SetDepthOfFieldFarBlurSize(float NewBlurSize)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24944);

	ATslPostProcessEffect_SetDepthOfFieldFarBlurSize_Params params;
	params.NewBlurSize = NewBlurSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.OnSetEffectParameter
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FString                 ParameterName                  (Parm, ZeroConstructor)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void ATslPostProcessEffect::OnSetEffectParameter(const struct FString& ParameterName, float Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24941);

	ATslPostProcessEffect_OnSetEffectParameter_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslPostProcessEffect.GetEffectParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ParameterName                  (Parm, ZeroConstructor)
// float                          DefaultValue                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPostProcessEffect::GetEffectParameter(const struct FString& ParameterName, float DefaultValue)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24937);

	ATslPostProcessEffect_GetEffectParameter_Params params;
	params.ParameterName = ParameterName;
	params.DefaultValue = DefaultValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.GetDepthOfFieldFarBlurSize
// (Final, Native, Public, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslPostProcessEffect::GetDepthOfFieldFarBlurSize()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24935);

	ATslPostProcessEffect_GetDepthOfFieldFarBlurSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Projectile.ServerFireProjectile
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                 Origin                         (Parm, IsPlainOldData)
// struct FVector_NetQuantizeNormal ShootDir                       (Parm)

void ATslWeapon_Projectile::ServerFireProjectile(const struct FVector& Origin, const struct FVector_NetQuantizeNormal& ShootDir)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24973);

	ATslWeapon_Projectile_ServerFireProjectile_Params params;
	params.Origin = Origin;
	params.ShootDir = ShootDir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Throwable.ServerStartPinOff
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Throwable::ServerStartPinOff()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24999);

	ATslWeapon_Throwable_ServerStartPinOff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Throwable.ServerStartCooking
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Throwable::ServerStartCooking()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24998);

	ATslWeapon_Throwable_ServerStartCooking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Throwable.ServerRequestCancelThrow
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslWeapon_Throwable::ServerRequestCancelThrow()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24997);

	ATslWeapon_Throwable_ServerRequestCancelThrow_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Throwable.ServerFireProjectile
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                 RelativeLocation               (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 AimDirection                   (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslWeapon_Throwable::ServerFireProjectile(const struct FVector& RelativeLocation, const struct FVector& AimDirection)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24994);

	ATslWeapon_Throwable_ServerFireProjectile_Params params;
	params.RelativeLocation = RelativeLocation;
	params.AimDirection = AimDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Throwable.OnRep_ThrowableState
// (Final, Native, Protected)
// Parameters:
// EThrowableState                LastThrowableState             (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Throwable::OnRep_ThrowableState(EThrowableState LastThrowableState)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24991);

	ATslWeapon_Throwable_OnRep_ThrowableState_Params params;
	params.LastThrowableState = LastThrowableState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Throwable.OnAnimationNotify
// (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*  MeshComp                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   NotifyName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void ATslWeapon_Throwable::OnAnimationNotify(class USkeletalMeshComponent* MeshComp, const struct FName& NotifyName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24988);

	ATslWeapon_Throwable_OnAnimationNotify_Params params;
	params.MeshComp = MeshComp;
	params.NotifyName = NotifyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Throwable.GetThrowableState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EThrowableState                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EThrowableState ATslWeapon_Throwable::GetThrowableState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24985);

	ATslWeapon_Throwable_GetThrowableState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Throwable.GetThrowableCountInInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslWeapon_Throwable::GetThrowableCountInInventory()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24983);

	ATslWeapon_Throwable_GetThrowableCountInInventory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Throwable.GetThrowableCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int ATslWeapon_Throwable::GetThrowableCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24981);

	ATslWeapon_Throwable_GetThrowableCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Throwable.ClientNotifyReset
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ATslWeapon_Throwable::ClientNotifyReset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24980);

	ATslWeapon_Throwable_ClientNotifyReset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Throwable.CalculateFinalThrowVelocity
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 AimDirection                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslWeapon_Throwable::CalculateFinalThrowVelocity(const struct FVector& AimDirection)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(24977);

	ATslWeapon_Throwable_CalculateFinalThrowVelocity_Params params;
	params.AimDirection = AimDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslProjectile.SetMeshRotationFromServer
// (Final, Native, Protected)

void ATslProjectile::SetMeshRotationFromServer()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25027);

	ATslProjectile_SetMeshRotationFromServer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile.PropagateEffectActor_BP
// (Event, Protected, BlueprintEvent)

void ATslProjectile::PropagateEffectActor_BP()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25026);

	ATslProjectile_PropagateEffectActor_BP_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile.PropagateEffectActor
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ATslProjectile::PropagateEffectActor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25025);

	ATslProjectile_PropagateEffectActor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile.OnRep_Exploded
// (Final, Native, Protected)

void ATslProjectile::OnRep_Exploded()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25024);

	ATslProjectile_OnRep_Exploded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile.OnRep_ClientActivate
// (Final, Native, Protected)

void ATslProjectile::OnRep_ClientActivate()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25023);

	ATslProjectile_OnRep_ClientActivate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile.OnRep_ActiveParticle
// (Final, Native, Protected)

void ATslProjectile::OnRep_ActiveParticle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25022);

	ATslProjectile_OnRep_ActiveParticle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile.OnImpact
// (Final, Native, Public, HasOutParms, HasDefaults)
// Parameters:
// struct FHitResult              ImpactResult                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ImpactVelocity                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void ATslProjectile::OnImpact(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25019);

	ATslProjectile_OnImpact_Params params;
	params.ImpactResult = ImpactResult;
	params.ImpactVelocity = ImpactVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile.OnHit
// (Final, Native, Protected, HasOutParms, HasDefaults)
// Parameters:
// class UPrimitiveComponent*     HitComponent                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class AActor*                  OtherActor                     (Parm, ZeroConstructor, IsPlainOldData)
// class UPrimitiveComponent*     OtherComp                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 NormalImpulse                  (Parm, IsPlainOldData)
// struct FHitResult              Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void ATslProjectile::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25013);

	ATslProjectile_OnHit_Params params;
	params.HitComponent = HitComponent;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile.ExplodeBP
// (Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                 Location                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FRotator                Rotation                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FHitResult              Impact                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)

void ATslProjectile::ExplodeBP(const struct FVector& Location, const struct FRotator& Rotation, const struct FHitResult& Impact, float Radius)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25008);

	ATslProjectile_ExplodeBP_Params params;
	params.Location = Location;
	params.Rotation = Rotation;
	params.Impact = Impact;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile.CheckVelocityForStart
// (Final, Native, Protected)

void ATslProjectile::CheckVelocityForStart()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25007);

	ATslProjectile_CheckVelocityForStart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile_Flare.Server_SpawnCarePackageCustom
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// struct FVector                 InLocation                     (Parm, IsPlainOldData)

void ATslProjectile_Flare::Server_SpawnCarePackageCustom(const struct FVector& InLocation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25072);

	ATslProjectile_Flare_Server_SpawnCarePackageCustom_Params params;
	params.InLocation = InLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslProjectile_Flare.ApplyBurn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 InLocation                     (Parm, IsPlainOldData)

void ATslProjectile_Flare::ApplyBurn(const struct FVector& InLocation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25070);

	ATslProjectile_Flare_ApplyBurn_Params params;
	params.InLocation = InLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslReactionDoorComponent.OnRep_DoorBreakingState
// (Final, Native, Protected)

void UTslReactionDoorComponent::OnRep_DoorBreakingState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25086);

	UTslReactionDoorComponent_OnRep_DoorBreakingState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslReactionDoorComponent.ClientTakeDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// float                          Damage                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize     HitLocation                    (ConstParm, Parm, ReferenceParm)
// float                          DamageRadius                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          Impulse                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslReactionDoorComponent::ClientTakeDamage(float Damage, const struct FVector_NetQuantize& HitLocation, float DamageRadius, float Impulse)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25081);

	UTslReactionDoorComponent_ClientTakeDamage_Params params;
	params.Damage = Damage;
	params.HitLocation = HitLocation;
	params.DamageRadius = DamageRadius;
	params.Impulse = Impulse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSceneCaptureComponent2D.CaptureScene
// (Final, Native, Public, BlueprintCallable)

void UTslSceneCaptureComponent2D::CaptureScene()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25153);

	UTslSceneCaptureComponent2D_CaptureScene_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSceneCaptureWorld.InitWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameInstance*           GameInstance                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 SceneCapturePackageName        (Parm, ZeroConstructor)

void UTslSceneCaptureWorld::InitWorld(class UGameInstance* GameInstance, const struct FString& SceneCapturePackageName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25156);

	UTslSceneCaptureWorld_InitWorld_Params params;
	params.GameInstance = GameInstance;
	params.SceneCapturePackageName = SceneCapturePackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSceneCaptureWorld.DestroyWorld
// (Final, Native, Public, BlueprintCallable)

void UTslSceneCaptureWorld::DestroyWorld()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25155);

	UTslSceneCaptureWorld_DestroyWorld_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslServerParticle.StopParticleMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ATslServerParticle::StopParticleMulticast()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25162);

	ATslServerParticle_StopParticleMulticast_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslServerParticle.OnParticleFinish
// (Final, Native, Protected)
// Parameters:
// class UParticleSystemComponent* PSystem                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ATslServerParticle::OnParticleFinish(class UParticleSystemComponent* PSystem)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25160);

	ATslServerParticle_OnParticleFinish_Params params;
	params.PSystem = PSystem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSmokeParticleSystemComponent.ForceSpawn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            InEmitterIndex                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InLocation                     (ConstParm, Parm, IsPlainOldData)
// struct FVector                 InVelocity                     (ConstParm, Parm, IsPlainOldData)

void UTslSmokeParticleSystemComponent::ForceSpawn(int InEmitterIndex, const struct FVector& InLocation, const struct FVector& InVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25330);

	UTslSmokeParticleSystemComponent_ForceSpawn_Params params;
	params.InEmitterIndex = InEmitterIndex;
	params.InLocation = InLocation;
	params.InVelocity = InVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSmokePropagationComponent.InitScan
// (Final, Native, Public, BlueprintCallable)

void UTslSmokePropagationComponent::InitScan()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25334);

	UTslSmokePropagationComponent_InitScan_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.TickMonitoring
// (Final, Native, Private)

void ATslSpectatorPawn::TickMonitoring()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25455);

	ATslSpectatorPawn_TickMonitoring_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.SetShowPlayerInfoDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::SetShowPlayerInfoDistance(float Distance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25453);

	ATslSpectatorPawn_SetShowPlayerInfoDistance_Params params;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.SetPlayerCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                  NewViewTarget                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::SetPlayerCamera(class AActor* NewViewTarget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25451);

	ATslSpectatorPawn_SetPlayerCamera_Params params;
	params.NewViewTarget = NewViewTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.SetObserverCameraMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EObserverCameraMode            NewCameraMode                  (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  NewViewTarget                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::SetObserverCameraMode(EObserverCameraMode NewCameraMode, class AActor* NewViewTarget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25447);

	ATslSpectatorPawn_SetObserverCameraMode_Params params;
	params.NewCameraMode = NewCameraMode;
	params.NewViewTarget = NewViewTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.SetKillerOrVictimCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 strKillerID                    (Parm, ZeroConstructor)
// struct FString                 strKillerName                  (Parm, ZeroConstructor)
// struct FString                 strVictimID                    (Parm, ZeroConstructor)
// struct FString                 strVictimName                  (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslSpectatorPawn::SetKillerOrVictimCamera(const struct FString& strKillerID, const struct FString& strKillerName, const struct FString& strVictimID, const struct FString& strVictimName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25441);

	ATslSpectatorPawn_SetKillerOrVictimCamera_Params params;
	params.strKillerID = strKillerID;
	params.strKillerName = strKillerName;
	params.strVictimID = strVictimID;
	params.strVictimName = strVictimName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.SetFreeCamBattleLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 HitterLoc                      (Parm, IsPlainOldData)
// struct FVector                 AttackedLoc                    (Parm, IsPlainOldData)

void ATslSpectatorPawn::SetFreeCamBattleLocation(const struct FVector& HitterLoc, const struct FVector& AttackedLoc)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25438);

	ATslSpectatorPawn_SetFreeCamBattleLocation_Params params;
	params.HitterLoc = HitterLoc;
	params.AttackedLoc = AttackedLoc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.RestoreTargetCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslSpectatorPawn::RestoreTargetCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25436);

	ATslSpectatorPawn_RestoreTargetCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.PrevSpectatorCameraPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslSpectatorPawn::PrevSpectatorCameraPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25434);

	ATslSpectatorPawn_PrevSpectatorCameraPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.OnViewTargetUpdate
// (Final, Native, Private)
// Parameters:
// class AActor*                  NewViewTarget                  (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::OnViewTargetUpdate(class AActor* NewViewTarget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25432);

	ATslSpectatorPawn_OnViewTargetUpdate_Params params;
	params.NewViewTarget = NewViewTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnToggleShowObseverTagWeapon
// (Final, Native, Private)

void ATslSpectatorPawn::OnToggleShowObseverTagWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25431);

	ATslSpectatorPawn_OnToggleShowObseverTagWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnToggleObseverTagWidget
// (Final, Native, Private)

void ATslSpectatorPawn::OnToggleObseverTagWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25430);

	ATslSpectatorPawn_OnToggleObseverTagWidget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnSwitchCameraSpectator
// (Final, Native, Public)

void ATslSpectatorPawn::OnSwitchCameraSpectator()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25429);

	ATslSpectatorPawn_OnSwitchCameraSpectator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnSwitchCameraFollow
// (Final, Native, Public)

void ATslSpectatorPawn::OnSwitchCameraFollow()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25428);

	ATslSpectatorPawn_OnSwitchCameraFollow_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnStopSlowMove
// (Final, Native, Private)

void ATslSpectatorPawn::OnStopSlowMove()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25427);

	ATslSpectatorPawn_OnStopSlowMove_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnStopFastMove
// (Final, Native, Private)

void ATslSpectatorPawn::OnStopFastMove()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25426);

	ATslSpectatorPawn_OnStopFastMove_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnStartSlowMove
// (Final, Native, Private)

void ATslSpectatorPawn::OnStartSlowMove()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25425);

	ATslSpectatorPawn_OnStartSlowMove_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnStartFastMove
// (Final, Native, Private)

void ATslSpectatorPawn::OnStartFastMove()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25424);

	ATslSpectatorPawn_OnStartFastMove_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnSetLocation
// (Final, Native, Private)
// Parameters:
// unsigned char                  idx                            (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::OnSetLocation(unsigned char idx)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25422);

	ATslSpectatorPawn_OnSetLocation_Params params;
	params.idx = idx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnSetFree
// (Final, Native, Public)

void ATslSpectatorPawn::OnSetFree()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25421);

	ATslSpectatorPawn_OnSetFree_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnSetCharacterSpec
// (Final, Native, Private)
// Parameters:
// unsigned char                  idx                            (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::OnSetCharacterSpec(unsigned char idx)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25419);

	ATslSpectatorPawn_OnSetCharacterSpec_Params params;
	params.idx = idx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnSetCharacter
// (Final, Native, Private)
// Parameters:
// unsigned char                  idx                            (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::OnSetCharacter(unsigned char idx)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25417);

	ATslSpectatorPawn_OnSetCharacter_Params params;
	params.idx = idx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnSaveLocation
// (Final, Native, Private)
// Parameters:
// unsigned char                  idx                            (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::OnSaveLocation(unsigned char idx)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25415);

	ATslSpectatorPawn_OnSaveLocation_Params params;
	params.idx = idx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnSaveCharacter
// (Final, Native, Public)
// Parameters:
// unsigned char                  idx                            (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::OnSaveCharacter(unsigned char idx)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25413);

	ATslSpectatorPawn_OnSaveCharacter_Params params;
	params.idx = idx;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnPlayerInfoDistanceUpHold
// (Final, Native, Public)

void ATslSpectatorPawn::OnPlayerInfoDistanceUpHold()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25412);

	ATslSpectatorPawn_OnPlayerInfoDistanceUpHold_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnPlayerInfoDistanceUp
// (Final, Native, Public)

void ATslSpectatorPawn::OnPlayerInfoDistanceUp()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25411);

	ATslSpectatorPawn_OnPlayerInfoDistanceUp_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnPlayerInfoDistanceDownHold
// (Final, Native, Public)

void ATslSpectatorPawn::OnPlayerInfoDistanceDownHold()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25410);

	ATslSpectatorPawn_OnPlayerInfoDistanceDownHold_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnPlayerInfoDistanceDown
// (Final, Native, Public)

void ATslSpectatorPawn::OnPlayerInfoDistanceDown()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25409);

	ATslSpectatorPawn_OnPlayerInfoDistanceDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.OnGotoTimelineDone
// (Final, Native, Public)

void ATslSpectatorPawn::OnGotoTimelineDone()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25408);

	ATslSpectatorPawn_OnGotoTimelineDone_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.NextSpectatorCameraPad
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslSpectatorPawn::NextSpectatorCameraPad()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25406);

	ATslSpectatorPawn_NextSpectatorCameraPad_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.IsObserverTagWeaponShow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslSpectatorPawn::IsObserverTagWeaponShow()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25404);

	ATslSpectatorPawn_IsObserverTagWeaponShow_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.HandleClipboard
// (Final, Native, Private)

void ATslSpectatorPawn::HandleClipboard()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25403);

	ATslSpectatorPawn_HandleClipboard_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslSpectatorPawn.GetSpectatableCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ATslSpectatorPawn::GetSpectatableCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25401);

	ATslSpectatorPawn_GetSpectatableCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetSpectableCarePackageItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACarePackageItem*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ACarePackageItem* ATslSpectatorPawn::GetSpectableCarePackageItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25399);

	ATslSpectatorPawn_GetSpectableCarePackageItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetShowPlayerInfoDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslSpectatorPawn::GetShowPlayerInfoDistance()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25397);

	ATslSpectatorPawn_GetShowPlayerInfoDistance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetObserverTagShow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslSpectatorPawn::GetObserverTagShow()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25395);

	ATslSpectatorPawn_GetObserverTagShow_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetLastSpectatedCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* ATslSpectatorPawn::GetLastSpectatedCharacter()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25393);

	ATslSpectatorPawn_GetLastSpectatedCharacter_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetCameraMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverCameraMode            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EObserverCameraMode ATslSpectatorPawn::GetCameraMode()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25390);

	ATslSpectatorPawn_GetCameraMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.BackupTargetCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                  ViewTarget                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslSpectatorPawn::BackupTargetCharacter(class AActor* ViewTarget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25388);

	ATslSpectatorPawn_BackupTargetCharacter_Params params;
	params.ViewTarget = ViewTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStreamer.OnOriginShiftedInternal
// (Final, Native, Private, HasDefaults)
// Parameters:
// class UWorld*                  InWorld                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FIntVector              From                           (Parm, IsPlainOldData)
// struct FIntVector              To                             (Parm, IsPlainOldData)

void UTslStreamer::OnOriginShiftedInternal(class UWorld* InWorld, const struct FIntVector& From, const struct FIntVector& To)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25509);

	UTslStreamer_OnOriginShiftedInternal_Params params;
	params.InWorld = InWorld;
	params.From = From;
	params.To = To;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslStreamer.OnLevelChangedInternal
// (Final, Native, Private)

void UTslStreamer::OnLevelChangedInternal()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25508);

	UTslStreamer_OnLevelChangedInternal_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslThrowableTrajectoryViewComponent.AttachToThrowable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslWeapon_Throwable*    ThrowableIn                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UTslThrowableTrajectoryViewComponent::AttachToThrowable(class ATslWeapon_Throwable* ThrowableIn)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25846);

	UTslThrowableTrajectoryViewComponent_AttachToThrowable_Params params;
	params.ThrowableIn = ThrowableIn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEmoteWheelWidget.StartShow
// (Event, Public, BlueprintEvent)

void UTslEmoteWheelWidget::StartShow()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25873);

	UTslEmoteWheelWidget_StartShow_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslEmoteWheelWidget.StartHide
// (Event, Public, BlueprintEvent)

void UTslEmoteWheelWidget::StartHide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25872);

	UTslEmoteWheelWidget_StartHide_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslXboxTeamManageWidget.ToggleVoiceChat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            MemberNumber                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslXboxTeamManageWidget::ToggleVoiceChat(int MemberNumber)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25886);

	UTslXboxTeamManageWidget_ToggleVoiceChat_Params params;
	params.MemberNumber = MemberNumber;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslXboxTeamManageWidget.TeamMemberMuteChanged
// (Final, Native, Private)
// Parameters:
// struct FString                 PlayerId                       (Parm, ZeroConstructor)
// struct FString                 ChannelId                      (Parm, ZeroConstructor)
// bool                           bIsMuted                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslXboxTeamManageWidget::TeamMemberMuteChanged(const struct FString& PlayerId, const struct FString& ChannelId, bool bIsMuted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25882);

	UTslXboxTeamManageWidget_TeamMemberMuteChanged_Params params;
	params.PlayerId = PlayerId;
	params.ChannelId = ChannelId;
	params.bIsMuted = bIsMuted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslXboxTeamManageWidget.ShowGamerCard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            MemberNumber                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslXboxTeamManageWidget::ShowGamerCard(int MemberNumber)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25880);

	UTslXboxTeamManageWidget_ShowGamerCard_Params params;
	params.MemberNumber = MemberNumber;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslXboxTeamManageWidget.GetTeamManageInfoWidgetBySlot
// (Final, Native, Public)
// Parameters:
// int                            SlotIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// class UTslXboxTeamManageInfoWidget* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslXboxTeamManageInfoWidget* UTslXboxTeamManageWidget::GetTeamManageInfoWidgetBySlot(int SlotIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25877);

	UTslXboxTeamManageWidget_GetTeamManageInfoWidgetBySlot_Params params;
	params.SlotIndex = SlotIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslXboxTeamManageWidget.GetTeamManageInfoWidgetByMemberNum
// (Final, Native, Public)
// Parameters:
// int                            MemberNum                      (Parm, ZeroConstructor, IsPlainOldData)
// class UTslXboxTeamManageInfoWidget* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslXboxTeamManageInfoWidget* UTslXboxTeamManageWidget::GetTeamManageInfoWidgetByMemberNum(int MemberNum)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25874);

	UTslXboxTeamManageWidget_GetTeamManageInfoWidgetByMemberNum_Params params;
	params.MemberNum = MemberNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.BluezoneGpsBaseWidget.UpdateBluezoneGpsWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UBluezoneGpsBaseWidget::UpdateBluezoneGpsWidget(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25892);

	UBluezoneGpsBaseWidget_UpdateBluezoneGpsWidget_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.BluezoneGpsBaseWidget.OnNotifyNextGasIn
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                 PoisonGasWarningPosition       (Parm, IsPlainOldData)
// float                          PoisonGasWarningRadius         (Parm, ZeroConstructor, IsPlainOldData)

void UBluezoneGpsBaseWidget::OnNotifyNextGasIn(const struct FVector& PoisonGasWarningPosition, float PoisonGasWarningRadius)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25889);

	UBluezoneGpsBaseWidget_OnNotifyNextGasIn_Params params;
	params.PoisonGasWarningPosition = PoisonGasWarningPosition;
	params.PoisonGasWarningRadius = PoisonGasWarningRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.EquipableItemIconBaseWidget.OnNoBagSpaceEvent
// (Final, Native, Public)

void UEquipableItemIconBaseWidget::OnNoBagSpaceEvent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25937);

	UEquipableItemIconBaseWidget_OnNoBagSpaceEvent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.HudMainBaseWidget.OnInit_Widget
// (Event, Public, BlueprintEvent)
// Parameters:
// class ATslBaseHUD*             TslBaseHUD                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UHudMainBaseWidget::OnInit_Widget(class ATslBaseHUD* TslBaseHUD)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25983);

	UHudMainBaseWidget_OnInit_Widget_Params params;
	params.TslBaseHUD = TslBaseHUD;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.HudMainBaseWidget.OnInit_Replay
// (Event, Public, BlueprintEvent)
// Parameters:
// class ATslBaseHUD*             TslBaseHUD                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UHudMainBaseWidget::OnInit_Replay(class ATslBaseHUD* TslBaseHUD)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25980);

	UHudMainBaseWidget_OnInit_Replay_Params params;
	params.TslBaseHUD = TslBaseHUD;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.HudMainBaseWidget.OnInit_Input
// (Event, Public, BlueprintEvent)
// Parameters:
// class ATslBaseHUD*             TslBaseHUD                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UHudMainBaseWidget::OnInit_Input(class ATslBaseHUD* TslBaseHUD)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25977);

	UHudMainBaseWidget_OnInit_Input_Params params;
	params.TslBaseHUD = TslBaseHUD;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.HudMainBaseWidget.OnInit_Delegate
// (Event, Public, BlueprintEvent)
// Parameters:
// class ATslBaseHUD*             TslBaseHUD                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UHudMainBaseWidget::OnInit_Delegate(class ATslBaseHUD* TslBaseHUD)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25974);

	UHudMainBaseWidget_OnInit_Delegate_Params params;
	params.TslBaseHUD = TslBaseHUD;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.InteractionBaseWidget.OnNotifyInteractionItemChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                           bIsInteractEnable              (Parm, ZeroConstructor, IsPlainOldData)

void UInteractionBaseWidget::OnNotifyInteractionItemChanged(bool bIsInteractEnable)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(25988);

	UInteractionBaseWidget_OnNotifyInteractionItemChanged_Params params;
	params.bIsInteractEnable = bIsInteractEnable;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.KillCountBaseWidget.GetLastKillCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UKillCountBaseWidget::GetLastKillCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26014);

	UKillCountBaseWidget_GetLastKillCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.LifeGaugeBaseWidget.OnNotifyHit
// (Final, Native, Protected)
// Parameters:
// float                          Damage                         (Parm, ZeroConstructor, IsPlainOldData)
// EDamageTypeCategory            DamageType                     (Parm, ZeroConstructor, IsPlainOldData)

void ULifeGaugeBaseWidget::OnNotifyHit(float Damage, EDamageTypeCategory DamageType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26026);

	ULifeGaugeBaseWidget_OnNotifyHit_Params params;
	params.Damage = Damage;
	params.DamageType = DamageType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LifeGaugeBaseWidget.OnNotifyHeal
// (Final, Native, Protected)
// Parameters:
// float                          StartHealth                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          GoalHealth                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxHealth                      (Parm, ZeroConstructor, IsPlainOldData)

void ULifeGaugeBaseWidget::OnNotifyHeal(float StartHealth, float GoalHealth, float MaxHealth)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26022);

	ULifeGaugeBaseWidget_OnNotifyHeal_Params params;
	params.StartHealth = StartHealth;
	params.GoalHealth = GoalHealth;
	params.MaxHealth = MaxHealth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LifeGaugeTemplateBaseWidget.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Life                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxLife                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsGroggy                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          HealAmount                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDisableEffect                 (Parm, ZeroConstructor, IsPlainOldData)

void ULifeGaugeTemplateBaseWidget::Update(float Life, float MaxLife, bool bIsGroggy, float HealAmount, bool bDisableEffect)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26074);

	ULifeGaugeTemplateBaseWidget_Update_Params params;
	params.Life = Life;
	params.MaxLife = MaxLife;
	params.bIsGroggy = bIsGroggy;
	params.HealAmount = HealAmount;
	params.bDisableEffect = bDisableEffect;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LifeGaugeTemplateBaseWidget.OnDestoryHealEffect
// (Final, Native, Public)
// Parameters:
// class ULifeGaugeEffectBaseWidget* HealEffect                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ULifeGaugeTemplateBaseWidget::OnDestoryHealEffect(class ULifeGaugeEffectBaseWidget* HealEffect)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26072);

	ULifeGaugeTemplateBaseWidget_OnDestoryHealEffect_Params params;
	params.HealEffect = HealEffect;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LifeGaugeTemplateBaseWidget.OnDestoryDamageEffect
// (Final, Native, Public)
// Parameters:
// class ULifeGaugeEffectBaseWidget* DamageEffect                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void ULifeGaugeTemplateBaseWidget::OnDestoryDamageEffect(class ULifeGaugeEffectBaseWidget* DamageEffect)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26070);

	ULifeGaugeTemplateBaseWidget_OnDestoryDamageEffect_Params params;
	params.DamageEffect = DamageEffect;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.LifeGaugeTemplateBaseWidget.HasEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ULifeGaugeTemplateBaseWidget::HasEffect()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26068);

	ULifeGaugeTemplateBaseWidget_HasEffect_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapCarePackageItemIconBaseWidget.OnButtonDown
// (Final, Native, Public, HasOutParms)
// Parameters:
// struct FGeometry               Geometry                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FPointerEvent           MouseEvent                     (ConstParm, Parm, OutParm, ReferenceParm)
// struct FEventReply             ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEventReply UMapCarePackageItemIconBaseWidget::OnButtonDown(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26102);

	UMapCarePackageItemIconBaseWidget_OnButtonDown_Params params;
	params.Geometry = Geometry;
	params.MouseEvent = MouseEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapCharacterIconBaseWidget.OnButtonDown
// (Final, Native, Public, HasOutParms)
// Parameters:
// struct FGeometry               Geometry                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FPointerEvent           MouseEvent                     (ConstParm, Parm, OutParm, ReferenceParm)
// struct FEventReply             ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEventReply UMapCharacterIconBaseWidget::OnButtonDown(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26110);

	UMapCharacterIconBaseWidget_OnButtonDown_Params params;
	params.Geometry = Geometry;
	params.MouseEvent = MouseEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.UpdateZoomAndWidgetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                          Zoom                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               WidgetSize                     (Parm, IsPlainOldData)

void UMapGridWidget::UpdateZoomAndWidgetSize(float Zoom, const struct FVector2D& WidgetSize)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26209);

	UMapGridWidget_UpdateZoomAndWidgetSize_Params params;
	params.Zoom = Zoom;
	params.WidgetSize = WidgetSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.UpdateWidgetSize_UC
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               WidgetSize                     (Parm, IsPlainOldData)

void UMapGridWidget::UpdateWidgetSize_UC(const struct FVector2D& WidgetSize)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26207);

	UMapGridWidget_UpdateWidgetSize_UC_Params params;
	params.WidgetSize = WidgetSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.UpdateReplicatedCharacterList
// (Final, Native, Public)

void UMapGridWidget::UpdateReplicatedCharacterList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26206);

	UMapGridWidget_UpdateReplicatedCharacterList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.UpdateReplicatedCarePackageItemList
// (Final, Native, Public)

void UMapGridWidget::UpdateReplicatedCarePackageItemList()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26205);

	UMapGridWidget_UpdateReplicatedCarePackageItemList_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.UpdateRectangleViewByWidgetSize
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D               WidgetSize                     (Parm, IsPlainOldData)

void UMapGridWidget::UpdateRectangleViewByWidgetSize(const struct FVector2D& WidgetSize)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26203);

	UMapGridWidget_UpdateRectangleViewByWidgetSize_Params params;
	params.WidgetSize = WidgetSize;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.UpdateRectangleView
// (Event, Public, BlueprintEvent)

void UMapGridWidget::UpdateRectangleView()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26202);

	UMapGridWidget_UpdateRectangleView_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.UCtoMC
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               UC                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D UMapGridWidget::UCtoMC(const struct FVector2D& UC)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26199);

	UMapGridWidget_UCtoMC_Params params;
	params.UC = UC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.SetZoomLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewZoomLevel                   (Parm, ZeroConstructor, IsPlainOldData)

void UMapGridWidget::SetZoomLevel(float NewZoomLevel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26197);

	UMapGridWidget_SetZoomLevel_Params params;
	params.NewZoomLevel = NewZoomLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.SetImageBrush
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic* NewMatInst                     (Parm, ZeroConstructor, IsPlainOldData)

void UMapGridWidget::SetImageBrush(class UMaterialInstanceDynamic* NewMatInst)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26195);

	UMapGridWidget_SetImageBrush_Params params;
	params.NewMatInst = NewMatInst;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.SetCharacterIconPositionAndRotation_UC
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D               Pos_UC                         (Parm, IsPlainOldData)
// float                          Angle                          (Parm, ZeroConstructor, IsPlainOldData)

void UMapGridWidget::SetCharacterIconPositionAndRotation_UC(const struct FVector2D& Pos_UC, float Angle)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26192);

	UMapGridWidget_SetCharacterIconPositionAndRotation_UC_Params params;
	params.Pos_UC = Pos_UC;
	params.Angle = Angle;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.SetCenter_MC
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               Center                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UMapGridWidget::SetCenter_MC(const struct FVector2D& Center)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26190);

	UMapGridWidget_SetCenter_MC_Params params;
	params.Center = Center;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.OnMapIconClicked
// (Final, Native, Public)
// Parameters:
// class UMapCharacterIconBaseWidget* MapIconWidget                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UMapGridWidget::OnMapIconClicked(class UMapCharacterIconBaseWidget* MapIconWidget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26188);

	UMapGridWidget_OnMapIconClicked_Params params;
	params.MapIconWidget = MapIconWidget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.OnMapCarePackageItemIconClicked
// (Final, Native, Public)
// Parameters:
// class UMapCarePackageItemIconBaseWidget* MapIconWidget                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UMapGridWidget::OnMapCarePackageItemIconClicked(class UMapCarePackageItemIconBaseWidget* MapIconWidget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26186);

	UMapGridWidget_OnMapCarePackageItemIconClicked_Params params;
	params.MapIconWidget = MapIconWidget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.OnGotoTimelineDone
// (Final, Native, Private)

void UMapGridWidget::OnGotoTimelineDone()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26185);

	UMapGridWidget_OnGotoTimelineDone_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.OnGameUserSettingApplied
// (Final, Native, Public)

void UMapGridWidget::OnGameUserSettingApplied()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26184);

	UMapGridWidget_OnGameUserSettingApplied_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.MCtoUC
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               MapCoord                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D UMapGridWidget::MCtoUC(const struct FVector2D& MapCoord)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26181);

	UMapGridWidget_MCtoUC_Params params;
	params.MapCoord = MapCoord;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.IsMouseInMarker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UMapGridWidget::IsMouseInMarker()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26179);

	UMapGridWidget_IsMouseInMarker_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.GetZoomLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UMapGridWidget::GetZoomLevel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26177);

	UMapGridWidget_GetZoomLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.GetWidgetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D UMapGridWidget::GetWidgetSize()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26175);

	UMapGridWidget_GetWidgetSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.GetWidgetPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D UMapGridWidget::GetWidgetPosition()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26173);

	UMapGridWidget_GetWidgetPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.GetScreenOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D UMapGridWidget::GetScreenOffset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26171);

	UMapGridWidget_GetScreenOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.GetMapImageWigetSizeAndImageOffset
// (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D               WidgetSize                     (Parm, OutParm, IsPlainOldData)
// struct FVector2D               ImageOffset                    (Parm, OutParm, IsPlainOldData)

void UMapGridWidget::GetMapImageWigetSizeAndImageOffset(struct FVector2D* WidgetSize, struct FVector2D* ImageOffset)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26168);

	UMapGridWidget_GetMapImageWigetSizeAndImageOffset_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WidgetSize != nullptr)
		*WidgetSize = params.WidgetSize;
	if (ImageOffset != nullptr)
		*ImageOffset = params.ImageOffset;
}


// Function TslGame.MapGridWidget.GetLocalMousePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D UMapGridWidget::GetLocalMousePosition()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26166);

	UMapGridWidget_GetLocalMousePosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.GetCharacterGridVertical
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UMapGridWidget::GetCharacterGridVertical()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26164);

	UMapGridWidget_GetCharacterGridVertical_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.GetCharacterGridTextHorizental
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UMapGridWidget::GetCharacterGridTextHorizental()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26162);

	UMapGridWidget_GetCharacterGridTextHorizental_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.GetAlignment
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D UMapGridWidget::GetAlignment()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26160);

	UMapGridWidget_GetAlignment_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.DrawRedZone_UC
// (Event, Public, HasOutParms, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector2D               Center_UC                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Radius_UC                      (Parm, ZeroConstructor, IsPlainOldData)

void UMapGridWidget::DrawRedZone_UC(const struct FVector2D& Center_UC, float Radius_UC)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26157);

	UMapGridWidget_DrawRedZone_UC_Params params;
	params.Center_UC = Center_UC;
	params.Radius_UC = Radius_UC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.DrawMarker_UC
// (Event, Public, HasOutParms, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector2D               MarkerCenter_UC                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UMapGridWidget::DrawMarker_UC(const struct FVector2D& MarkerCenter_UC)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26155);

	UMapGridWidget_DrawMarker_UC_Params params;
	params.MarkerCenter_UC = MarkerCenter_UC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MapGridWidget.CursorUCtoCenterMC
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               UC                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector2D               Offest_MC                      (Parm, OutParm, IsPlainOldData)
// bool                           bUpdate                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UMapGridWidget::CursorUCtoCenterMC(const struct FVector2D& UC, struct FVector2D* Offest_MC, bool* bUpdate)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26151);

	UMapGridWidget_CursorUCtoCenterMC_Params params;
	params.UC = UC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Offest_MC != nullptr)
		*Offest_MC = params.Offest_MC;
	if (bUpdate != nullptr)
		*bUpdate = params.bUpdate;
}


// Function TslGame.MapGridWidget.ClampPositionByWidgetSize_UC
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               Positon                        (Parm, IsPlainOldData)
// struct FVector2D               WidgetSize                     (Parm, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D UMapGridWidget::ClampPositionByWidgetSize_UC(const struct FVector2D& Positon, const struct FVector2D& WidgetSize)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26147);

	UMapGridWidget_ClampPositionByWidgetSize_UC_Params params;
	params.Positon = Positon;
	params.WidgetSize = WidgetSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.ClampPosition_UC
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               Positon                        (Parm, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D UMapGridWidget::ClampPosition_UC(const struct FVector2D& Positon)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26144);

	UMapGridWidget_ClampPosition_UC_Params params;
	params.Positon = Positon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.MapGridWidget.AddCenter_UC
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               Offset_UC                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UMapGridWidget::AddCenter_UC(const struct FVector2D& Offset_UC)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26142);

	UMapGridWidget_AddCenter_UC_Params params;
	params.Offset_UC = Offset_UC;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.MinimapCanvasWidget.IsBluezoneGpsReset
// (Final, Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UMinimapCanvasWidget::IsBluezoneGpsReset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26286);

	UMinimapCanvasWidget_IsBluezoneGpsReset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.ParachuteVehicleWidget.OnUpdateParachuteVehicle
// (Event, Public, BlueprintEvent)
// Parameters:
// class AParachuteVehicle*       SavedParachuteVehicle          (Parm, ZeroConstructor, IsPlainOldData)

void UParachuteVehicleWidget::OnUpdateParachuteVehicle(class AParachuteVehicle* SavedParachuteVehicle)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26299);

	UParachuteVehicleWidget_OnUpdateParachuteVehicle_Params params;
	params.SavedParachuteVehicle = SavedParachuteVehicle;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.ParachuteVehicleWidget.GetSavedParachuteVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AParachuteVehicle*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AParachuteVehicle* UParachuteVehicleWidget::GetSavedParachuteVehicle()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26297);

	UParachuteVehicleWidget_GetSavedParachuteVehicle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TeamMarkWidget.InitializeTeamMarkGrid
// (Final, Native, Public, BlueprintCallable)

void UTeamMarkWidget::InitializeTeamMarkGrid()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26309);

	UTeamMarkWidget_InitializeTeamMarkGrid_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TeamOverallKillCountBaseWidget.GetLastTeamOverallKillCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTeamOverallKillCountBaseWidget::GetLastTeamOverallKillCount()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26339);

	UTeamOverallKillCountBaseWidget_GetLastTeamOverallKillCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetShowCrosshairWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bShow                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslAdaptiveCrosshairWidget::SetShowCrosshairWidget(bool bShow)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26359);

	UTslAdaptiveCrosshairWidget_SetShowCrosshairWidget_Params params;
	params.bShow = bShow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetCenterCrosshairVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bVisible                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslAdaptiveCrosshairWidget::SetCenterCrosshairVisibility(bool bVisible)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26357);

	UTslAdaptiveCrosshairWidget_SetCenterCrosshairVisibility_Params params;
	params.bVisible = bVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetCenterCrosshairDeviation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InDeviation                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslAdaptiveCrosshairWidget::SetCenterCrosshairDeviation(float InDeviation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26355);

	UTslAdaptiveCrosshairWidget_SetCenterCrosshairDeviation_Params params;
	params.InDeviation = InDeviation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetCenterCrosshairClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWeaponClass                   InWeaponClass                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bHasWeapon                     (Parm, ZeroConstructor, IsPlainOldData)

void UTslAdaptiveCrosshairWidget::SetCenterCrosshairClass(EWeaponClass InWeaponClass, bool bHasWeapon)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26351);

	UTslAdaptiveCrosshairWidget_SetCenterCrosshairClass_Params params;
	params.InWeaponClass = InWeaponClass;
	params.bHasWeapon = bHasWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetAdaptiveCrosshairVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bVisible                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslAdaptiveCrosshairWidget::SetAdaptiveCrosshairVisibility(bool bVisible)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26349);

	UTslAdaptiveCrosshairWidget_SetAdaptiveCrosshairVisibility_Params params;
	params.bVisible = bVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetAdaptiveCrosshairPosition
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               ScreenPosition                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslAdaptiveCrosshairWidget::SetAdaptiveCrosshairPosition(const struct FVector2D& ScreenPosition, float Distance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26346);

	UTslAdaptiveCrosshairWidget_SetAdaptiveCrosshairPosition_Params params;
	params.ScreenPosition = ScreenPosition;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAdaptiveCrosshairWidget.HandleGameUserSettingApplied
// (Final, Native, Public)

void UTslAdaptiveCrosshairWidget::HandleGameUserSettingApplied()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26345);

	UTslAdaptiveCrosshairWidget_HandleGameUserSettingApplied_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAdaptiveCrosshairWidget.DecideAdaptiveCrosshairColor
// (Final, Native, Public, BlueprintCallable)

void UTslAdaptiveCrosshairWidget::DecideAdaptiveCrosshairColor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26344);

	UTslAdaptiveCrosshairWidget_DecideAdaptiveCrosshairColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAlivePlayerInfoWidget.OnMatchStarted
// (Final, Native, Public)

void UTslAlivePlayerInfoWidget::OnMatchStarted()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26392);

	UTslAlivePlayerInfoWidget_OnMatchStarted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslAlivePlayerInfoWidget.OnAliveCountChanged
// (Final, Native, Public)
// Parameters:
// int                            InKillCount                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslAlivePlayerInfoWidget::OnAliveCountChanged(int InKillCount)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26390);

	UTslAlivePlayerInfoWidget_OnAliveCountChanged_Params params;
	params.InKillCount = InKillCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseOptionWidget.OnReset
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UTslBaseOptionWidget::OnReset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26413);

	UTslBaseOptionWidget_OnReset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseOptionWidget.OnDefault
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UTslBaseOptionWidget::OnDefault()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26412);

	UTslBaseOptionWidget_OnDefault_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseOptionWidget.OnApply
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UTslBaseOptionWidget::OnApply()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26411);

	UTslBaseOptionWidget_OnApply_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBaseOptionWidget.IsKeyUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslBaseOptionWidget::IsKeyUp()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26409);

	UTslBaseOptionWidget_IsKeyUp_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseOptionWidget.IsEnableApply
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslBaseOptionWidget::IsEnableApply()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26407);

	UTslBaseOptionWidget_IsEnableApply_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBaseOptionWidget.IsChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslBaseOptionWidget::IsChanged()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26405);

	UTslBaseOptionWidget_IsChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslKeyDisplayWidget.TransferInputEvent
// (Final, Native, Public)
// Parameters:
// struct FTslInputKey            TslInputKey                    (Parm)

void UTslKeyDisplayWidget::TransferInputEvent(const struct FTslInputKey& TslInputKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26424);

	UTslKeyDisplayWidget_TransferInputEvent_Params params;
	params.TslInputKey = TslInputKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyDisplayWidget.SetupKeyDisplayWidget
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   InInputName                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FText                   InDisplayName                  (ConstParm, Parm, OutParm, ReferenceParm)
// struct FName                   InCategoryName                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           InbAxisInput                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          InAxisScale                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbGamepad                     (Parm, ZeroConstructor, IsPlainOldData)

void UTslKeyDisplayWidget::SetupKeyDisplayWidget(const struct FName& InInputName, const struct FText& InDisplayName, const struct FName& InCategoryName, bool InbAxisInput, float InAxisScale, bool InbGamepad)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26417);

	UTslKeyDisplayWidget_SetupKeyDisplayWidget_Params params;
	params.InInputName = InInputName;
	params.InDisplayName = InDisplayName;
	params.InCategoryName = InCategoryName;
	params.InbAxisInput = InbAxisInput;
	params.InAxisScale = InAxisScale;
	params.InbGamepad = InbGamepad;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyDisplayWidget.InitializeKeyDisplayWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bDefault                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslKeyDisplayWidget::InitializeKeyDisplayWidget(bool bDefault)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26415);

	UTslKeyDisplayWidget_InitializeKeyDisplayWidget_Params params;
	params.bDefault = bDefault;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyDisplayWidget.ApplyKey
// (Final, Native, Public, BlueprintCallable)

void UTslKeyDisplayWidget::ApplyKey()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26414);

	UTslKeyDisplayWidget_ApplyKey_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyOptionWidget.OnKeyChanged
// (Final, Native, Private)
// Parameters:
// class UTslKeyDisplayWidget*    InKeyDisplayWidget             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FTslInputKey            InInputedKey                   (Parm)

void UTslKeyOptionWidget::OnKeyChanged(class UTslKeyDisplayWidget* InKeyDisplayWidget, const struct FTslInputKey& InInputedKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26438);

	UTslKeyOptionWidget_OnKeyChanged_Params params;
	params.InKeyDisplayWidget = InKeyDisplayWidget;
	params.InInputedKey = InInputedKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyOptionWidget.InitializeKeyAndMouseSetting
// (Final, Native, Public)

void UTslKeyOptionWidget::InitializeKeyAndMouseSetting()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26437);

	UTslKeyOptionWidget_InitializeKeyAndMouseSetting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeySettingWidget.TransferInputEvent
// (Final, Native, Public)
// Parameters:
// class UTslKeyDisplayWidget*    KeyDisplayWidget               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FTslInputKey            TslInputKey                    (Parm)

void UTslKeySettingWidget::TransferInputEvent(class UTslKeyDisplayWidget* KeyDisplayWidget, const struct FTslInputKey& TslInputKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26456);

	UTslKeySettingWidget_TransferInputEvent_Params params;
	params.KeyDisplayWidget = KeyDisplayWidget;
	params.TslInputKey = TslInputKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeySettingWidget.StartupKeySettingWidget
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   InCategoryName                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FText                   InDisplayText                  (ConstParm, Parm, OutParm, ReferenceParm)

void UTslKeySettingWidget::StartupKeySettingWidget(const struct FName& InCategoryName, const struct FText& InDisplayText)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26453);

	UTslKeySettingWidget_StartupKeySettingWidget_Params params;
	params.InCategoryName = InCategoryName;
	params.InDisplayText = InDisplayText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeySettingWidget.SetToDefault
// (Final, Native, Public, BlueprintCallable)

void UTslKeySettingWidget::SetToDefault()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26452);

	UTslKeySettingWidget_SetToDefault_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeySettingWidget.InitializeKeySettingWidget
// (Final, Native, Public, BlueprintCallable)

void UTslKeySettingWidget::InitializeKeySettingWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26451);

	UTslKeySettingWidget_InitializeKeySettingWidget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBreatheBarWidget.OnStartBuff
// (Final, Native, Protected)
// Parameters:
// struct FName                   BuffName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bStart                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslBreatheBarWidget::OnStartBuff(const struct FName& BuffName, bool bStart)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26482);

	UTslBreatheBarWidget_OnStartBuff_Params params;
	params.BuffName = BuffName;
	params.bStart = bStart;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBuffIconListWidget.UpdateRunBuffIconVisibility
// (Final, Native, Public)
// Parameters:
// float                          InBoostPercentage              (Parm, ZeroConstructor, IsPlainOldData)

void UTslBuffIconListWidget::UpdateRunBuffIconVisibility(float InBoostPercentage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26516);

	UTslBuffIconListWidget_UpdateRunBuffIconVisibility_Params params;
	params.InBoostPercentage = InBoostPercentage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBuffIconListWidget.UpdateRunBuffIcon
// (Final, Native, Public)
// Parameters:
// float                          InBoostPercentage              (Parm, ZeroConstructor, IsPlainOldData)

void UTslBuffIconListWidget::UpdateRunBuffIcon(float InBoostPercentage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26514);

	UTslBuffIconListWidget_UpdateRunBuffIcon_Params params;
	params.InBoostPercentage = InBoostPercentage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBuffIconListWidget.UpdateHealBuffIconVisibility
// (Final, Native, Public)
// Parameters:
// float                          InBoostPercentage              (Parm, ZeroConstructor, IsPlainOldData)

void UTslBuffIconListWidget::UpdateHealBuffIconVisibility(float InBoostPercentage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26512);

	UTslBuffIconListWidget_UpdateHealBuffIconVisibility_Params params;
	params.InBoostPercentage = InBoostPercentage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBuffIconListWidget.UpdateHealBuffIcon
// (Final, Native, Public)
// Parameters:
// float                          InBoostPercentage              (Parm, ZeroConstructor, IsPlainOldData)

void UTslBuffIconListWidget::UpdateHealBuffIcon(float InBoostPercentage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26510);

	UTslBuffIconListWidget_UpdateHealBuffIcon_Params params;
	params.InBoostPercentage = InBoostPercentage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslBuffIconListWidget.GetRunBuffIconOpacity
// (Final, Native, Public, HasDefaults, Const)
// Parameters:
// float                          InBoostPercentage              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FLinearColor UTslBuffIconListWidget::GetRunBuffIconOpacity(float InBoostPercentage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26507);

	UTslBuffIconListWidget_GetRunBuffIconOpacity_Params params;
	params.InBoostPercentage = InBoostPercentage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslBuffIconListWidget.GetHealBuffIconOpacity
// (Final, Native, Public, HasDefaults, Const)
// Parameters:
// float                          InBoostPercentage              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FLinearColor UTslBuffIconListWidget::GetHealBuffIconOpacity(float InBoostPercentage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26504);

	UTslBuffIconListWidget_GetHealBuffIconOpacity_Params params;
	params.InBoostPercentage = InBoostPercentage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslCastableItemIconWidget.GetCastableItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECastableItemType              InItemType                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslCastableItemIconWidget::GetCastableItemCount(ECastableItemType InItemType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26525);

	UTslCastableItemIconWidget_GetCastableItemCount_Params params;
	params.InItemType = InItemType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslConfirmationDialogWidget.OnButtonClick
// (Final, Native, Public)
// Parameters:
// EPopupButtonID                 ButtonID                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslConfirmationDialogWidget::OnButtonClick(EPopupButtonID ButtonID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26572);

	UTslConfirmationDialogWidget_OnButtonClick_Params params;
	params.ButtonID = ButtonID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslConsoleGuideWidget.SetActiveWidget
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// int                            WidgetIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// EGuideKeyType                  GuideKeyType                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslConsoleGuideWidget::SetActiveWidget(int WidgetIndex, EGuideKeyType GuideKeyType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26585);

	UTslConsoleGuideWidget_SetActiveWidget_Params params;
	params.WidgetIndex = WidgetIndex;
	params.GuideKeyType = GuideKeyType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslConsoleGuideWidget.RefreshWidgetSelectState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEquipment*              Equipment                      (Parm, ZeroConstructor, IsPlainOldData)
// class UItem*                   TargetItem                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            FocusIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            SelfPutIndex                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslConsoleGuideWidget::RefreshWidgetSelectState(class AEquipment* Equipment, class UItem* TargetItem, int FocusIndex, int SelfPutIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26580);

	UTslConsoleGuideWidget_RefreshWidgetSelectState_Params params;
	params.Equipment = Equipment;
	params.TargetItem = TargetItem;
	params.FocusIndex = FocusIndex;
	params.SelfPutIndex = SelfPutIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslConsoleGuideWidget.RefreshWidgetAmountControl
// (Final, Native, Public, BlueprintCallable)

void UTslConsoleGuideWidget::RefreshWidgetAmountControl()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26579);

	UTslConsoleGuideWidget_RefreshWidgetAmountControl_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslConsoleGuideWidget.RefreshWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEquipment*              Equipment                      (Parm, ZeroConstructor, IsPlainOldData)
// class UItem*                   TargetItem                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            FocusIndex                     (Parm, ZeroConstructor, IsPlainOldData)

void UTslConsoleGuideWidget::RefreshWidget(class AEquipment* Equipment, class UItem* TargetItem, int FocusIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26575);

	UTslConsoleGuideWidget_RefreshWidget_Params params;
	params.Equipment = Equipment;
	params.TargetItem = TargetItem;
	params.FocusIndex = FocusIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslGamepadHudWidget.RuntimeInit_Implementation
// (Event, Public, BlueprintEvent)

void UTslGamepadHudWidget::RuntimeInit_Implementation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26589);

	UTslGamepadHudWidget_RuntimeInit_Implementation_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHealItemSelectorWidget.OnUseHealItem
// (Final, Native, Public)

void UTslHealItemSelectorWidget::OnUseHealItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26601);

	UTslHealItemSelectorWidget_OnUseHealItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHealItemSelectorWidget.OnSelectNextHealItem
// (Final, Native, Public)

void UTslHealItemSelectorWidget::OnSelectNextHealItem()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26600);

	UTslHealItemSelectorWidget_OnSelectNextHealItem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHealItemSelectorWidget.OnHideWidget
// (Final, Native, Public)

void UTslHealItemSelectorWidget::OnHideWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26599);

	UTslHealItemSelectorWidget_OnHideWidget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslHealItemSelectorWidget.NotifyHealItemSelectorInput
// (Final, Native, Public)

void UTslHealItemSelectorWidget::NotifyHealItemSelectorInput()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26598);

	UTslHealItemSelectorWidget_NotifyHealItemSelectorInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslInventoryCapacityWidget.GetInventoryCached
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInventory*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AInventory* UTslInventoryCapacityWidget::GetInventoryCached()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26645);

	UTslInventoryCapacityWidget_GetInventoryCached_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslInventoryCapacityWidget.GetFeedbackParamsFromVicinityItem
// (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          CurrMaxSpace                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          CurrSpace                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ItemSpace                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          OutFeedbackStart               (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutFeedbackEnd                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           OutIsPositive                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UTslInventoryCapacityWidget::GetFeedbackParamsFromVicinityItem(float CurrMaxSpace, float CurrSpace, float ItemSpace, float* OutFeedbackStart, float* OutFeedbackEnd, bool* OutIsPositive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26638);

	UTslInventoryCapacityWidget_GetFeedbackParamsFromVicinityItem_Params params;
	params.CurrMaxSpace = CurrMaxSpace;
	params.CurrSpace = CurrSpace;
	params.ItemSpace = ItemSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutFeedbackStart != nullptr)
		*OutFeedbackStart = params.OutFeedbackStart;
	if (OutFeedbackEnd != nullptr)
		*OutFeedbackEnd = params.OutFeedbackEnd;
	if (OutIsPositive != nullptr)
		*OutIsPositive = params.OutIsPositive;
}


// Function TslGame.TslInventoryCapacityWidget.GetFeedbackParamsFromVicinityEquipment
// (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          CurrMaxSpace                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          CurrSpace                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEquipableItem*          EquipableItem                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutFeedbackStart               (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutFeedbackEnd                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           OutIsPositive                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UTslInventoryCapacityWidget::GetFeedbackParamsFromVicinityEquipment(float CurrMaxSpace, float CurrSpace, class UEquipableItem* EquipableItem, float* OutFeedbackStart, float* OutFeedbackEnd, bool* OutIsPositive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26631);

	UTslInventoryCapacityWidget_GetFeedbackParamsFromVicinityEquipment_Params params;
	params.CurrMaxSpace = CurrMaxSpace;
	params.CurrSpace = CurrSpace;
	params.EquipableItem = EquipableItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutFeedbackStart != nullptr)
		*OutFeedbackStart = params.OutFeedbackStart;
	if (OutFeedbackEnd != nullptr)
		*OutFeedbackEnd = params.OutFeedbackEnd;
	if (OutIsPositive != nullptr)
		*OutIsPositive = params.OutIsPositive;
}


// Function TslGame.TslInventoryCapacityWidget.GetFeedbackParamsFromInventoryItem
// (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          CurrMaxSpace                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          CurrSpace                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ItemSpace                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          OutFeedbackStart               (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutFeedbackEnd                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           OutIsPositive                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UTslInventoryCapacityWidget::GetFeedbackParamsFromInventoryItem(float CurrMaxSpace, float CurrSpace, float ItemSpace, float* OutFeedbackStart, float* OutFeedbackEnd, bool* OutIsPositive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26624);

	UTslInventoryCapacityWidget_GetFeedbackParamsFromInventoryItem_Params params;
	params.CurrMaxSpace = CurrMaxSpace;
	params.CurrSpace = CurrSpace;
	params.ItemSpace = ItemSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutFeedbackStart != nullptr)
		*OutFeedbackStart = params.OutFeedbackStart;
	if (OutFeedbackEnd != nullptr)
		*OutFeedbackEnd = params.OutFeedbackEnd;
	if (OutIsPositive != nullptr)
		*OutIsPositive = params.OutIsPositive;
}


// Function TslGame.TslInventoryCapacityWidget.GetFeedbackParamsFromEquipmentSlot
// (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          CurrMaxSpace                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          CurrSpace                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEquipableItem*          EquipableItem                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutFeedbackStart               (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutFeedbackEnd                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           OutIsPositive                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UTslInventoryCapacityWidget::GetFeedbackParamsFromEquipmentSlot(float CurrMaxSpace, float CurrSpace, class UEquipableItem* EquipableItem, float* OutFeedbackStart, float* OutFeedbackEnd, bool* OutIsPositive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26617);

	UTslInventoryCapacityWidget_GetFeedbackParamsFromEquipmentSlot_Params params;
	params.CurrMaxSpace = CurrMaxSpace;
	params.CurrSpace = CurrSpace;
	params.EquipableItem = EquipableItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutFeedbackStart != nullptr)
		*OutFeedbackStart = params.OutFeedbackStart;
	if (OutFeedbackEnd != nullptr)
		*OutFeedbackEnd = params.OutFeedbackEnd;
	if (OutIsPositive != nullptr)
		*OutIsPositive = params.OutIsPositive;
}


// Function TslGame.TslInventoryCapacityWidget.GetCapacityParams
// (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          CurrMaxSpace                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          CurrSpace                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          OutCurrMaxSpaceStart           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutCurrSpaceStart              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UTslInventoryCapacityWidget::GetCapacityParams(float CurrMaxSpace, float CurrSpace, float* OutCurrMaxSpaceStart, float* OutCurrSpaceStart)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26612);

	UTslInventoryCapacityWidget_GetCapacityParams_Params params;
	params.CurrMaxSpace = CurrMaxSpace;
	params.CurrSpace = CurrSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutCurrMaxSpaceStart != nullptr)
		*OutCurrMaxSpaceStart = params.OutCurrMaxSpaceStart;
	if (OutCurrSpaceStart != nullptr)
		*OutCurrSpaceStart = params.OutCurrSpaceStart;
}


// Function TslGame.TslKeyGuideWidget.ShowKeyGuideWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeyGuideShowCases             eShowCase                      (Parm, ZeroConstructor, IsPlainOldData)

void UTslKeyGuideWidget::ShowKeyGuideWidget(EKeyGuideShowCases eShowCase)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26650);

	UTslKeyGuideWidget_ShowKeyGuideWidget_Params params;
	params.eShowCase = eShowCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyGuideWidget.HideKeyGuideWidget
// (Final, Native, Public, BlueprintCallable)

void UTslKeyGuideWidget::HideKeyGuideWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26649);

	UTslKeyGuideWidget_HideKeyGuideWidget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyReceiverWidget.UpdateKeyUp
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKey                    InKey                          (Parm)

void UTslKeyReceiverWidget::UpdateKeyUp(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26669);

	UTslKeyReceiverWidget_UpdateKeyUp_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyReceiverWidget.UpdateKeyDown
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKey                    InKey                          (Parm)

void UTslKeyReceiverWidget::UpdateKeyDown(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26667);

	UTslKeyReceiverWidget_UpdateKeyDown_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyReceiverWidget.KeyUp
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKey                    InKey                          (Parm)

void UTslKeyReceiverWidget::KeyUp(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26665);

	UTslKeyReceiverWidget_KeyUp_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyReceiverWidget.KeyDown
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKey                    InKey                          (Parm)

void UTslKeyReceiverWidget::KeyDown(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26663);

	UTslKeyReceiverWidget_KeyDown_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKeyReceiverWidget.IsInputKeyDown
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslKeyReceiverWidget::IsInputKeyDown()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26661);

	UTslKeyReceiverWidget_IsInputKeyDown_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslKeyReceiverWidget.GetLastDownedKeyName
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UTslKeyReceiverWidget::GetLastDownedKeyName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26659);

	UTslKeyReceiverWidget_GetLastDownedKeyName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslKillMessageListWidget.UpdateMessageListWidget
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UTslKillMessageListWidget::UpdateMessageListWidget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26689);

	UTslKillMessageListWidget_UpdateMessageListWidget_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKillMessageListWidget.OnVanishAnimationFinished
// (Final, Native, Public)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UTslKillMessageListWidget::OnVanishAnimationFinished(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26687);

	UTslKillMessageListWidget_OnVanishAnimationFinished_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKillMessageListWidget.EnqueueDeathMessage
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FDeathMessage           DeathMessage                   (ConstParm, Parm, OutParm, ReferenceParm)

void UTslKillMessageListWidget::EnqueueDeathMessage(const struct FDeathMessage& DeathMessage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26685);

	UTslKillMessageListWidget_EnqueueDeathMessage_Params params;
	params.DeathMessage = DeathMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKillMessageListWidget.DequeueDeathMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UTslKillMessageListWidget::DequeueDeathMessage(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26683);

	UTslKillMessageListWidget_DequeueDeathMessage_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKillMessageWidget.SetVanishTimer
// (Final, Native, Public)
// Parameters:
// float                          TimeDelay                      (Parm, ZeroConstructor, IsPlainOldData)

void UTslKillMessageWidget::SetVanishTimer(float TimeDelay)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26707);

	UTslKillMessageWidget_SetVanishTimer_Params params;
	params.TimeDelay = TimeDelay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKillMessageWidget.SetDeathMessage
// (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
// struct FDeathMessage           InDeathMessage                 (ConstParm, Parm, OutParm, ReferenceParm)

void UTslKillMessageWidget::SetDeathMessage(const struct FDeathMessage& InDeathMessage)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26705);

	UTslKillMessageWidget_SetDeathMessage_Params params;
	params.InDeathMessage = InDeathMessage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKillMessageWidget.PlayVanishAnimation
// (Final, Native, Public)

void UTslKillMessageWidget::PlayVanishAnimation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26704);

	UTslKillMessageWidget_PlayVanishAnimation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslKillMessageWidget.GetTextureFromDamageTypeCategory
// (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDamageTypeCategory            InDamageTypeCategory           (Parm, ZeroConstructor, IsPlainOldData)
// class UTexture*                OutTexture                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutRatio                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UTslKillMessageWidget::GetTextureFromDamageTypeCategory(EDamageTypeCategory InDamageTypeCategory, class UTexture** OutTexture, float* OutRatio)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26699);

	UTslKillMessageWidget_GetTextureFromDamageTypeCategory_Params params;
	params.InDamageTypeCategory = InDamageTypeCategory;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutTexture != nullptr)
		*OutTexture = params.OutTexture;
	if (OutRatio != nullptr)
		*OutRatio = params.OutRatio;
}


// Function TslGame.TslKillMessageWidget.GetTextureFromConditionOfDeathCategory
// (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EConditionOfDeath              InConditionOfDeathCategory     (Parm, ZeroConstructor, IsPlainOldData)
// class UTexture*                OutTexture                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutRatio                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UTslKillMessageWidget::GetTextureFromConditionOfDeathCategory(EConditionOfDeath InConditionOfDeathCategory, class UTexture** OutTexture, float* OutRatio)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26694);

	UTslKillMessageWidget_GetTextureFromConditionOfDeathCategory_Params params;
	params.InConditionOfDeathCategory = InConditionOfDeathCategory;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutTexture != nullptr)
		*OutTexture = params.OutTexture;
	if (OutRatio != nullptr)
		*OutRatio = params.OutRatio;
}


// Function TslGame.TslLobbyNameTagWidget.UpdateWidgetsVisibilities
// (Final, Native, Public, BlueprintCallable)

void UTslLobbyNameTagWidget::UpdateWidgetsVisibilities()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26733);

	UTslLobbyNameTagWidget_UpdateWidgetsVisibilities_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLobbyNameTagWidget.SetSpeaking
// (Final, Native, Private)
// Parameters:
// bool                           InbSpeaking                    (Parm, ZeroConstructor, IsPlainOldData)

void UTslLobbyNameTagWidget::SetSpeaking(bool InbSpeaking)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26731);

	UTslLobbyNameTagWidget_SetSpeaking_Params params;
	params.InbSpeaking = InbSpeaking;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLobbyNameTagWidget.SetReady
// (Final, Native, Private)
// Parameters:
// bool                           InbReady                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslLobbyNameTagWidget::SetReady(bool InbReady)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26729);

	UTslLobbyNameTagWidget_SetReady_Params params;
	params.InbReady = InbReady;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLobbyNameTagWidget.SetNickName
// (Final, Native, Private)
// Parameters:
// struct FString                 InNickName                     (Parm, ZeroConstructor)

void UTslLobbyNameTagWidget::SetNickName(const struct FString& InNickName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26727);

	UTslLobbyNameTagWidget_SetNickName_Params params;
	params.InNickName = InNickName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLobbyNameTagWidget.SetHost
// (Final, Native, Private)
// Parameters:
// bool                           InbHost                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslLobbyNameTagWidget::SetHost(bool InbHost)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26725);

	UTslLobbyNameTagWidget_SetHost_Params params;
	params.InbHost = InbHost;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLobbyNameTagWidget.SetBinding
// (Final, Native, Private)

void UTslLobbyNameTagWidget::SetBinding()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26724);

	UTslLobbyNameTagWidget_SetBinding_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLobbyNameTagWidget.OnVoiceChatUpdated
// (Final, Native, Public)
// Parameters:
// struct FString                 InUniqueId                     (Parm, ZeroConstructor)
// bool                           InbTeamChannel                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbSpeaking                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          InEnergy                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslLobbyNameTagWidget::OnVoiceChatUpdated(const struct FString& InUniqueId, bool InbTeamChannel, bool InbSpeaking, float InEnergy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26719);

	UTslLobbyNameTagWidget_OnVoiceChatUpdated_Params params;
	params.InUniqueId = InUniqueId;
	params.InbTeamChannel = InbTeamChannel;
	params.InbSpeaking = InbSpeaking;
	params.InEnergy = InEnergy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslLobbyNameTagWidget.IsAlone
// (Final, Native, Private, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslLobbyNameTagWidget::IsAlone()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26717);

	UTslLobbyNameTagWidget_IsAlone_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslLobbyNameTagWidget.InitWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 InNickName                     (Parm, ZeroConstructor)

void UTslLobbyNameTagWidget::InitWidget(const struct FString& InNickName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26715);

	UTslLobbyNameTagWidget_InitWidget_Params params;
	params.InNickName = InNickName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateVoiceImage
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateVoiceImage()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26808);

	UTslTeamInfoWidget_UpdateVoiceImage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateVivoxChat
// (Final, Native, Private)
// Parameters:
// struct FString                 UniqueId                       (Parm, ZeroConstructor)
// bool                           bIsTeamChannel                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InbSpeaking                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          InMeterEnergy                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslTeamInfoWidget::UpdateVivoxChat(const struct FString& UniqueId, bool bIsTeamChannel, bool InbSpeaking, float InMeterEnergy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26803);

	UTslTeamInfoWidget_UpdateVivoxChat_Params params;
	params.UniqueId = UniqueId;
	params.bIsTeamChannel = bIsTeamChannel;
	params.InbSpeaking = InbSpeaking;
	params.InMeterEnergy = InMeterEnergy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamMemberName
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamMemberName()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26802);

	UTslTeamInfoWidget_UpdateTeamMemberName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamMemberIcon
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamMemberIcon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26801);

	UTslTeamInfoWidget_UpdateTeamMemberIcon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamMemberColor
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamMemberColor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26800);

	UTslTeamInfoWidget_UpdateTeamMemberColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamMarkerBorder
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamMarkerBorder()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26799);

	UTslTeamInfoWidget_UpdateTeamMarkerBorder_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamMarker
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamMarker()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26798);

	UTslTeamInfoWidget_UpdateTeamMarker_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamInfoIcon
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamInfoIcon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26797);

	UTslTeamInfoWidget_UpdateTeamInfoIcon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamInfoArea
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamInfoArea()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26796);

	UTslTeamInfoWidget_UpdateTeamInfoArea_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdatePlayerIcon
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdatePlayerIcon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26795);

	UTslTeamInfoWidget_UpdatePlayerIcon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateHealthGaugeAndVisibility
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateHealthGaugeAndVisibility()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26794);

	UTslTeamInfoWidget_UpdateHealthGaugeAndVisibility_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.UpdateBoostGauge
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateBoostGauge()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26793);

	UTslTeamInfoWidget_UpdateBoostGauge_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.SetTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATeam*                   InTeam                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslTeamInfoWidget::SetTeam(class ATeam* InTeam)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26791);

	UTslTeamInfoWidget_SetTeam_Params params;
	params.InTeam = InTeam;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.OnVoiceChat
// (Final, Native, Private)
// Parameters:
// bool                           InbSpeaking                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          InMeterEnergy                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslTeamInfoWidget::OnVoiceChat(bool InbSpeaking, float InMeterEnergy)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26788);

	UTslTeamInfoWidget_OnVoiceChat_Params params;
	params.InbSpeaking = InbSpeaking;
	params.InMeterEnergy = InMeterEnergy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.OnParticipantRestrictionChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ATeam*                   Team                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 UniqueId                       (Parm, ZeroConstructor)
// bool                           bIsRestricted                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslTeamInfoWidget::OnParticipantRestrictionChanged(class ATeam* Team, const struct FString& UniqueId, bool bIsRestricted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26784);

	UTslTeamInfoWidget_OnParticipantRestrictionChanged_Params params;
	params.Team = Team;
	params.UniqueId = UniqueId;
	params.bIsRestricted = bIsRestricted;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.OnParticipantMuteChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ATeam*                   Team                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ParticipantId                  (Parm, ZeroConstructor)
// struct FString                 ChannelId                      (Parm, ZeroConstructor)
// bool                           bIsMuted                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslTeamInfoWidget::OnParticipantMuteChanged(class ATeam* Team, const struct FString& ParticipantId, const struct FString& ChannelId, bool bIsMuted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26779);

	UTslTeamInfoWidget_OnParticipantMuteChanged_Params params;
	params.Team = Team;
	params.ParticipantId = ParticipantId;
	params.ChannelId = ChannelId;
	params.bIsMuted = bIsMuted;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.OnNativeParticipantRestrictionChanged
// (Final, Native, Private)
// Parameters:
// struct FString                 UniqueId                       (Parm, ZeroConstructor)
// bool                           bIsRestricted                  (Parm, ZeroConstructor, IsPlainOldData)

void UTslTeamInfoWidget::OnNativeParticipantRestrictionChanged(const struct FString& UniqueId, bool bIsRestricted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26776);

	UTslTeamInfoWidget_OnNativeParticipantRestrictionChanged_Params params;
	params.UniqueId = UniqueId;
	params.bIsRestricted = bIsRestricted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.OnNativeParticipantMuteChanged
// (Final, Native, Private)
// Parameters:
// struct FString                 ParticipantId                  (Parm, ZeroConstructor)
// struct FString                 ChannelId                      (Parm, ZeroConstructor)
// bool                           bIsMuted                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslTeamInfoWidget::OnNativeParticipantMuteChanged(const struct FString& ParticipantId, const struct FString& ChannelId, bool bIsMuted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26772);

	UTslTeamInfoWidget_OnNativeParticipantMuteChanged_Params params;
	params.ParticipantId = ParticipantId;
	params.ChannelId = ChannelId;
	params.bIsMuted = bIsMuted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.DecideTeamNameColor
// (Final, Native, Private)

void UTslTeamInfoWidget::DecideTeamNameColor()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26771);

	UTslTeamInfoWidget_DecideTeamNameColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslTeamInfoWidget.BindVoiceChatIfNeed
// (Final, Native, Private)

void UTslTeamInfoWidget::BindVoiceChatIfNeed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26770);

	UTslTeamInfoWidget_BindVoiceChatIfNeed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslXboxTeamManageInfoWidget.UpdateVoiceIcon
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                           InbVoiceMute                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslXboxTeamManageInfoWidget::UpdateVoiceIcon(bool InbVoiceMute)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26836);

	UTslXboxTeamManageInfoWidget_UpdateVoiceIcon_Params params;
	params.InbVoiceMute = InbVoiceMute;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslXboxTeamManageInfoWidget.UpdateUserNameText
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FName                   InUserName                     (Parm, ZeroConstructor, IsPlainOldData)

void UTslXboxTeamManageInfoWidget::UpdateUserNameText(const struct FName& InUserName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26834);

	UTslXboxTeamManageInfoWidget_UpdateUserNameText_Params params;
	params.InUserName = InUserName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VehicleSeatInfoBaseWidget.GetSeatState
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UVehicleSeatInfoBaseWidget::GetSeatState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26848);

	UVehicleSeatInfoBaseWidget_GetSeatState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnNotifyWeaponUnarm
// (Final, Native, Public)
// Parameters:
// bool                           bIsUnarmed                     (Parm, ZeroConstructor, IsPlainOldData)

void UWeaponSlotHudBaseWidget::OnNotifyWeaponUnarm(bool bIsUnarmed)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26935);

	UWeaponSlotHudBaseWidget_OnNotifyWeaponUnarm_Params params;
	params.bIsUnarmed = bIsUnarmed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnNotifyWeaponChange
// (Final, Native, Public)
// Parameters:
// int                            WeaponIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void UWeaponSlotHudBaseWidget::OnNotifyWeaponChange(int WeaponIndex, float Duration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26932);

	UWeaponSlotHudBaseWidget_OnNotifyWeaponChange_Params params;
	params.WeaponIndex = WeaponIndex;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnNotifyWeaponArmed
// (Final, Native, Public)

void UWeaponSlotHudBaseWidget::OnNotifyWeaponArmed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26931);

	UWeaponSlotHudBaseWidget_OnNotifyWeaponArmed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnMovingStarted
// (Final, Native, Public)

void UWeaponSlotHudBaseWidget::OnMovingStarted()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26930);

	UWeaponSlotHudBaseWidget_OnMovingStarted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnMovingFinished
// (Final, Native, Public)

void UWeaponSlotHudBaseWidget::OnMovingFinished()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26929);

	UWeaponSlotHudBaseWidget_OnMovingFinished_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.SetVehicleHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewHealth                      (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleCommonComponent::SetVehicleHealth(float NewHealth)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27010);

	UTslVehicleCommonComponent_SetVehicleHealth_Params params;
	params.NewHealth = NewHealth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.SetVehicleFuelPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Percent                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleCommonComponent::SetVehicleFuelPercent(float Percent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27008);

	UTslVehicleCommonComponent_SetVehicleFuelPercent_Params params;
	params.Percent = Percent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.SetVehicleFuel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewFuel                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleCommonComponent::SetVehicleFuel(float NewFuel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27006);

	UTslVehicleCommonComponent_SetVehicleFuel_Params params;
	params.NewFuel = NewFuel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.Repair
// (Final, Native, Public, BlueprintCallable)

void UTslVehicleCommonComponent::Repair()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27005);

	UTslVehicleCommonComponent_Repair_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.OnRep_Health
// (Final, Native, Private)
// Parameters:
// float                          LastHealth                     (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleCommonComponent::OnRep_Health(float LastHealth)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27003);

	UTslVehicleCommonComponent_OnRep_Health_Params params;
	params.LastHealth = LastHealth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.OnRep_Fuel
// (Final, Native, Private)
// Parameters:
// float                          LastFuel                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleCommonComponent::OnRep_Fuel(float LastFuel)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27001);

	UTslVehicleCommonComponent_OnRep_Fuel_Params params;
	params.LastFuel = LastFuel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.OnRep_Dying
// (Final, Native, Private)

void UTslVehicleCommonComponent::OnRep_Dying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27000);

	UTslVehicleCommonComponent_OnRep_Dying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.OnRep_Broken
// (Final, Native, Private)

void UTslVehicleCommonComponent::OnRep_Broken()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26999);

	UTslVehicleCommonComponent_OnRep_Broken_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.IsDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslVehicleCommonComponent::IsDying()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26997);

	UTslVehicleCommonComponent_IsDying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.IsBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslVehicleCommonComponent::IsBroken()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26995);

	UTslVehicleCommonComponent_IsBroken_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* UTslVehicleCommonComponent::GetVehicleUI()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26993);

	UTslVehicleCommonComponent_GetVehicleUI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleHealthPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslVehicleCommonComponent::GetVehicleHealthPercent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26991);

	UTslVehicleCommonComponent_GetVehicleHealthPercent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslVehicleCommonComponent::GetVehicleHealth()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26989);

	UTslVehicleCommonComponent_GetVehicleHealth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleFuelPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslVehicleCommonComponent::GetVehicleFuelPercent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26987);

	UTslVehicleCommonComponent_GetVehicleFuelPercent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleFuel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslVehicleCommonComponent::GetVehicleFuel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26985);

	UTslVehicleCommonComponent_GetVehicleFuel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleBaseHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslVehicleCommonComponent::GetVehicleBaseHealth()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26983);

	UTslVehicleCommonComponent_GetVehicleBaseHealth_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleBaseFuel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UTslVehicleCommonComponent::GetVehicleBaseFuel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26981);

	UTslVehicleCommonComponent_GetVehicleBaseFuel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.CanIgnoreCharacterDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDamageTypeCategory            DamageTypeCategory             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UTslVehicleCommonComponent::CanIgnoreCharacterDamage(EDamageTypeCategory DamageTypeCategory)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26977);

	UTslVehicleCommonComponent_CanIgnoreCharacterDamage_Params params;
	params.DamageTypeCategory = DamageTypeCategory;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.Break
// (Final, Native, Public, BlueprintCallable)

void UTslVehicleCommonComponent::Break()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26976);

	UTslVehicleCommonComponent_Break_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleCommonComponent.AddVehicleFuel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Delta                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleCommonComponent::AddVehicleFuel(float Delta)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(26974);

	UTslVehicleCommonComponent_AddVehicleFuel_Params params;
	params.Delta = Delta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleEffectComponent.SetVehicleMaterialsToDestroyed
// (Final, Native, Public, BlueprintCallable)

void UTslVehicleEffectComponent::SetVehicleMaterialsToDestroyed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27058);

	UTslVehicleEffectComponent_SetVehicleMaterialsToDestroyed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleEffectComponent.SetEngineSoundRTPC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 RTPC                           (Parm, ZeroConstructor)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleEffectComponent::SetEngineSoundRTPC(const struct FString& RTPC, float Value)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27055);

	UTslVehicleEffectComponent_SetEngineSoundRTPC_Params params;
	params.RTPC = RTPC;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleEffectComponent.OnHit
// (Native, Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                  SelfActor                      (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  OtherActor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NormalImpulse                  (Parm, IsPlainOldData)
// struct FHitResult              Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UTslVehicleEffectComponent::OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27050);

	UTslVehicleEffectComponent_OnHit_Params params;
	params.SelfActor = SelfActor;
	params.OtherActor = OtherActor;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleEffectComponent.OnHealthChange
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                          CurrentHealth                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          LastHealth                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          HealthMax                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsDying                       (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleEffectComponent::OnHealthChange(float CurrentHealth, float LastHealth, float HealthMax, bool bIsDying)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27045);

	UTslVehicleEffectComponent_OnHealthChange_Params params;
	params.CurrentHealth = CurrentHealth;
	params.LastHealth = LastHealth;
	params.HealthMax = HealthMax;
	params.bIsDying = bIsDying;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleEffectComponent.OnDestroyedImpactEffect
// (Final, Native, Private)
// Parameters:
// class AActor*                  DestroyedActor                 (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleEffectComponent::OnDestroyedImpactEffect(class AActor* DestroyedActor)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27043);

	UTslVehicleEffectComponent_OnDestroyedImpactEffect_Params params;
	params.DestroyedActor = DestroyedActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleEffectComponent.OnDeath
// (Native, Event, Protected, HasOutParms, BlueprintEvent)
// Parameters:
// float                          KillingDamage                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FDamageEvent            DamageEvent                    (ConstParm, Parm, OutParm, ReferenceParm)
// class ATslPlayerState*         PlayerInstigator               (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleEffectComponent::OnDeath(float KillingDamage, const struct FDamageEvent& DamageEvent, class ATslPlayerState* PlayerInstigator, class AActor* DamageCauser)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27038);

	UTslVehicleEffectComponent_OnDeath_Params params;
	params.KillingDamage = KillingDamage;
	params.DamageEvent = DamageEvent;
	params.PlayerInstigator = PlayerInstigator;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleEffectComponent.GetEngineSoundComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkComponent*            ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UAkComponent* UTslVehicleEffectComponent::GetEngineSoundComponent()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27036);

	UTslVehicleEffectComponent_GetEngineSoundComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleEffectComponent.ApplyDestoyedMaterialWithDelay
// (Final, Native, Public, BlueprintCallable)

void UTslVehicleEffectComponent::ApplyDestoyedMaterialWithDelay()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27035);

	UTslVehicleEffectComponent_ApplyDestoyedMaterialWithDelay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleHitComponent.OnSyncHit
// (Final, Native, Protected, HasOutParms, HasDefaults)
// Parameters:
// struct FVector                 NormalImpulse                  (Parm, IsPlainOldData)
// struct FHitResult              Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UTslVehicleHitComponent::OnSyncHit(const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27133);

	UTslVehicleHitComponent_OnSyncHit_Params params;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleHitComponent.OnHit
// (Native, Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                  SelfActor                      (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  OtherActor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NormalImpulse                  (Parm, IsPlainOldData)
// struct FHitResult              Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UTslVehicleHitComponent::OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27128);

	UTslVehicleHitComponent_OnHit_Params params;
	params.SelfActor = SelfActor;
	params.OtherActor = OtherActor;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleHitComponent.OnDeath
// (Final, Native, Private, HasOutParms)
// Parameters:
// float                          KillingDamage                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FDamageEvent            DamageEvent                    (ConstParm, Parm, OutParm, ReferenceParm)
// class ATslPlayerState*         PlayerInstigator               (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleHitComponent::OnDeath(float KillingDamage, const struct FDamageEvent& DamageEvent, class ATslPlayerState* PlayerInstigator, class AActor* DamageCauser)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27123);

	UTslVehicleHitComponent_OnDeath_Params params;
	params.KillingDamage = KillingDamage;
	params.DamageEvent = DamageEvent;
	params.PlayerInstigator = PlayerInstigator;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleReactionInterface.OnImpactedByVehicle
// (Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult              Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 Velocity                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UTslVehicleReactionInterface::OnImpactedByVehicle(const struct FHitResult& Hit, const struct FVector& Velocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27176);

	UTslVehicleReactionInterface_OnImpactedByVehicle_Params params;
	params.Hit = Hit;
	params.Velocity = Velocity;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.TryToStabilize
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UTslVehicleSeatComponent::TryToStabilize()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27221);

	UTslVehicleSeatComponent_TryToStabilize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.TryToRide
// (Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UTslVehicleSeatComponent::TryToRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27218);

	UTslVehicleSeatComponent_TryToRide_Params params;
	params.Rider = Rider;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.TryToLeave
// (Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bForce                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleSeatComponent::TryToLeave(class ATslCharacter* Rider, bool bForce)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27215);

	UTslVehicleSeatComponent_TryToLeave_Params params;
	params.Rider = Rider;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.TryToFlip
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UTslVehicleSeatComponent::TryToFlip()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27214);

	UTslVehicleSeatComponent_TryToFlip_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.Ride
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UTslVehicleSeatComponent::Ride(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27211);

	UTslVehicleSeatComponent_Ride_Params params;
	params.Rider = Rider;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.PostDriverRide
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UTslVehicleSeatComponent::PostDriverRide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27210);

	UTslVehicleSeatComponent_PostDriverRide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.PostDriverLeave
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UTslVehicleSeatComponent::PostDriverLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27209);

	UTslVehicleSeatComponent_PostDriverLeave_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.OnFuelChange
// (Final, Native, Private)
// Parameters:
// float                          CurrentFuel                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          LastFuel                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          FuelMax                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleSeatComponent::OnFuelChange(float CurrentFuel, float LastFuel, float FuelMax)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27205);

	UTslVehicleSeatComponent_OnFuelChange_Params params;
	params.CurrentFuel = CurrentFuel;
	params.LastFuel = LastFuel;
	params.FuelMax = FuelMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.Leave
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ATslCharacter*           Rider                          (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           bForce                         (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleSeatComponent::Leave(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat, bool bForce)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27201);

	UTslVehicleSeatComponent_Leave_Params params;
	params.Rider = Rider;
	params.Seat = Seat;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.KillAllRiders
// (Final, Native, Private, HasOutParms)
// Parameters:
// float                          KillingDamage                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FDamageEvent            DamageEvent                    (ConstParm, Parm, OutParm, ReferenceParm)
// class ATslPlayerState*         PlayerInstigator               (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleSeatComponent::KillAllRiders(float KillingDamage, const struct FDamageEvent& DamageEvent, class ATslPlayerState* PlayerInstigator, class AActor* DamageCauser)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27196);

	UTslVehicleSeatComponent_KillAllRiders_Params params;
	params.KillingDamage = KillingDamage;
	params.DamageEvent = DamageEvent;
	params.PlayerInstigator = PlayerInstigator;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSeatComponent.GetVehicleSeatIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVehicleSeatInteractionComponent* Seat                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UTslVehicleSeatComponent::GetVehicleSeatIndex(class UVehicleSeatInteractionComponent* Seat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27193);

	UTslVehicleSeatComponent_GetVehicleSeatIndex_Params params;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetSeats
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UVehicleSeatInteractionComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UVehicleSeatInteractionComponent*> UTslVehicleSeatComponent::GetSeats()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27190);

	UTslVehicleSeatComponent_GetSeats_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetSeat
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            SeatIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// class UVehicleSeatInteractionComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UVehicleSeatInteractionComponent* UTslVehicleSeatComponent::GetSeat(int SeatIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27187);

	UTslVehicleSeatComponent_GetSeat_Params params;
	params.SeatIndex = SeatIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetRiders
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ATslCharacter*>   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class ATslCharacter*> UTslVehicleSeatComponent::GetRiders()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27184);

	UTslVehicleSeatComponent_GetRiders_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetLastDriver
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          LastDuration                   (Parm, ZeroConstructor, IsPlainOldData)
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UTslVehicleSeatComponent::GetLastDriver(float LastDuration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27181);

	UTslVehicleSeatComponent_GetLastDriver_Params params;
	params.LastDuration = LastDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetDriver
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UTslVehicleSeatComponent::GetDriver()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27179);

	UTslVehicleSeatComponent_GetDriver_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslVehicleSyncComponent.SendServerMoveToClient
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// int                            InCorrectionId                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize100  ServerLocation                 (Parm)
// struct FVector_NetQuantize100  ServerLinearVelocity           (Parm)
// struct FVector_NetQuantizeNormal ServerRotator                  (Parm)
// struct FVector_NetQuantize100  ServerAngularVelocity          (Parm)
// bool                           bIsSnap                        (Parm, ZeroConstructor, IsPlainOldData)

void UTslVehicleSyncComponent::SendServerMoveToClient(int InCorrectionId, const struct FVector_NetQuantize100& ServerLocation, const struct FVector_NetQuantize100& ServerLinearVelocity, const struct FVector_NetQuantizeNormal& ServerRotator, const struct FVector_NetQuantize100& ServerAngularVelocity, bool bIsSnap)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27281);

	UTslVehicleSyncComponent_SendServerMoveToClient_Params params;
	params.InCorrectionId = InCorrectionId;
	params.ServerLocation = ServerLocation;
	params.ServerLinearVelocity = ServerLinearVelocity;
	params.ServerRotator = ServerRotator;
	params.ServerAngularVelocity = ServerAngularVelocity;
	params.bIsSnap = bIsSnap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSyncComponent.SendClientMoveToServerUnreliably
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            InCorrectionId                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize100  ClientLocation                 (Parm)
// struct FVector_NetQuantize100  ClientLinearVelocity           (Parm)
// struct FVector_NetQuantizeNormal ClientRotator                  (Parm)
// struct FVector_NetQuantize100  ClientAngularVelocity          (Parm)

void UTslVehicleSyncComponent::SendClientMoveToServerUnreliably(int InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27275);

	UTslVehicleSyncComponent_SendClientMoveToServerUnreliably_Params params;
	params.InCorrectionId = InCorrectionId;
	params.ClientLocation = ClientLocation;
	params.ClientLinearVelocity = ClientLinearVelocity;
	params.ClientRotator = ClientRotator;
	params.ClientAngularVelocity = ClientAngularVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSyncComponent.SendClientMoveToServerReliably
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            InCorrectionId                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize100  ClientLocation                 (Parm)
// struct FVector_NetQuantize100  ClientLinearVelocity           (Parm)
// struct FVector_NetQuantizeNormal ClientRotator                  (Parm)
// struct FVector_NetQuantize100  ClientAngularVelocity          (Parm)

void UTslVehicleSyncComponent::SendClientMoveToServerReliably(int InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27269);

	UTslVehicleSyncComponent_SendClientMoveToServerReliably_Params params;
	params.InCorrectionId = InCorrectionId;
	params.ClientLocation = ClientLocation;
	params.ClientLinearVelocity = ClientLinearVelocity;
	params.ClientRotator = ClientRotator;
	params.ClientAngularVelocity = ClientAngularVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSyncComponent.SendClientHitToServerUnreliably
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            InCorrectionId                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize100  ClientLocation                 (Parm)
// struct FVector_NetQuantize100  ClientLinearVelocity           (Parm)
// struct FVector_NetQuantizeNormal ClientRotator                  (Parm)
// struct FVector_NetQuantize100  ClientAngularVelocity          (Parm)
// struct FVector_NetQuantize100  NormalImpulse                  (Parm)
// struct FHitResult              Hit                            (Parm, IsPlainOldData)

void UTslVehicleSyncComponent::SendClientHitToServerUnreliably(int InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity, const struct FVector_NetQuantize100& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27261);

	UTslVehicleSyncComponent_SendClientHitToServerUnreliably_Params params;
	params.InCorrectionId = InCorrectionId;
	params.ClientLocation = ClientLocation;
	params.ClientLinearVelocity = ClientLinearVelocity;
	params.ClientRotator = ClientRotator;
	params.ClientAngularVelocity = ClientAngularVelocity;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSyncComponent.SendClientHitToServerReliably
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            InCorrectionId                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize100  ClientLocation                 (Parm)
// struct FVector_NetQuantize100  ClientLinearVelocity           (Parm)
// struct FVector_NetQuantizeNormal ClientRotator                  (Parm)
// struct FVector_NetQuantize100  ClientAngularVelocity          (Parm)
// struct FVector_NetQuantize100  NormalImpulse                  (Parm)
// struct FHitResult              Hit                            (Parm, IsPlainOldData)

void UTslVehicleSyncComponent::SendClientHitToServerReliably(int InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity, const struct FVector_NetQuantize100& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27253);

	UTslVehicleSyncComponent_SendClientHitToServerReliably_Params params;
	params.InCorrectionId = InCorrectionId;
	params.ClientLocation = ClientLocation;
	params.ClientLinearVelocity = ClientLinearVelocity;
	params.ClientRotator = ClientRotator;
	params.ClientAngularVelocity = ClientAngularVelocity;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSyncComponent.OnHitAtServer
// (Final, Native, Private, HasOutParms, HasDefaults)
// Parameters:
// class AActor*                  SelfActor                      (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  OtherActor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NormalImpulse                  (Parm, IsPlainOldData)
// struct FHitResult              Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UTslVehicleSyncComponent::OnHitAtServer(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27248);

	UTslVehicleSyncComponent_OnHitAtServer_Params params;
	params.SelfActor = SelfActor;
	params.OtherActor = OtherActor;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSyncComponent.OnHitAtClient
// (Final, Native, Private, HasOutParms, HasDefaults)
// Parameters:
// class AActor*                  SelfActor                      (Parm, ZeroConstructor, IsPlainOldData)
// class AActor*                  OtherActor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NormalImpulse                  (Parm, IsPlainOldData)
// struct FHitResult              Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UTslVehicleSyncComponent::OnHitAtClient(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27243);

	UTslVehicleSyncComponent_OnHitAtClient_Params params;
	params.SelfActor = SelfActor;
	params.OtherActor = OtherActor;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslVehicleSyncComponent.OnDriverRide
// (Final, Native, Private)

void UTslVehicleSyncComponent::OnDriverRide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27242);

	UTslVehicleSyncComponent_OnDriverRide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslViewTargetTempComponent.AddTempComponentWithDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*         TempComponent                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FScriptDelegate         DelegateToCall                 (Parm, ZeroConstructor)

void UTslViewTargetTempComponent::AddTempComponentWithDelegate(class USceneComponent* TempComponent, const struct FScriptDelegate& DelegateToCall)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27299);

	UTslViewTargetTempComponent_AddTempComponentWithDelegate_Params params;
	params.TempComponent = TempComponent;
	params.DelegateToCall = DelegateToCall;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslViewTargetTempComponent.AddTempComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*         TempComponent                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UTslViewTargetTempComponent::AddTempComponent(class USceneComponent* TempComponent)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27297);

	UTslViewTargetTempComponent_AddTempComponent_Params params;
	params.TempComponent = TempComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun_Projectile.SimulateFire_BP
// (Native, Event, Public, BlueprintEvent)

void ATslWeapon_Gun_Projectile::SimulateFire_BP()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27307);

	ATslWeapon_Gun_Projectile_SimulateFire_BP_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Gun_Projectile.Server_FireProjectile
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                 InLocation                     (Parm, IsPlainOldData)
// struct FRotator                InRotation                     (Parm, IsPlainOldData)

void ATslWeapon_Gun_Projectile::Server_FireProjectile(const struct FVector& InLocation, const struct FRotator& InRotation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27304);

	ATslWeapon_Gun_Projectile_Server_FireProjectile_Params params;
	params.InLocation = InLocation;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.SimulateUnderwaterTrail
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FVector                 SurfaceImpactPoint             (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 ShootDirection                 (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// float                          TravelDistance                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Trajectory::SimulateUnderwaterTrail(const struct FVector& SurfaceImpactPoint, const struct FVector& ShootDirection, float TravelDistance)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27385);

	ATslWeapon_Trajectory_SimulateUnderwaterTrail_Params params;
	params.SurfaceImpactPoint = SurfaceImpactPoint;
	params.ShootDirection = ShootDirection;
	params.TravelDistance = TravelDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.SimulateUnderwaterHit
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FVector                 UnderwaterImpactPoint          (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 ShootOrigin                    (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslWeapon_Trajectory::SimulateUnderwaterHit(const struct FVector& UnderwaterImpactPoint, const struct FVector& ShootOrigin)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27382);

	ATslWeapon_Trajectory_SimulateUnderwaterHit_Params params;
	params.UnderwaterImpactPoint = UnderwaterImpactPoint;
	params.ShootOrigin = ShootOrigin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.SimulateHit_UnReliable
// (Net, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FHitResult              Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 RelLocation                    (ConstParm, Parm, IsPlainOldData)

void ATslWeapon_Trajectory::SimulateHit_UnReliable(const struct FHitResult& Impact, const struct FVector& RelLocation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27379);

	ATslWeapon_Trajectory_SimulateHit_UnReliable_Params params;
	params.Impact = Impact;
	params.RelLocation = RelLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.SimulateHit_Reliable
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FHitResult              Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 RelLocation                    (ConstParm, Parm, IsPlainOldData)

void ATslWeapon_Trajectory::SimulateHit_Reliable(const struct FHitResult& Impact, const struct FVector& RelLocation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27376);

	ATslWeapon_Trajectory_SimulateHit_Reliable_Params params;
	params.Impact = Impact;
	params.RelLocation = RelLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.Simulate_CreateAmmoInstance
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FVector                 ServerStartTrace               (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 Dir                            (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FAttackId               AttackId                       (ConstParm, Parm, ReferenceParm)

void ATslWeapon_Trajectory::Simulate_CreateAmmoInstance(const struct FVector& ServerStartTrace, const struct FVector& Dir, const struct FAttackId& AttackId)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27372);

	ATslWeapon_Trajectory_Simulate_CreateAmmoInstance_Params params;
	params.ServerStartTrace = ServerStartTrace;
	params.Dir = Dir;
	params.AttackId = AttackId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.ServerWallCheckTest
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                 TraceStart                     (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 TraceEnd                       (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslWeapon_Trajectory::ServerWallCheckTest(const struct FVector& TraceStart, const struct FVector& TraceEnd)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27369);

	ATslWeapon_Trajectory_ServerWallCheckTest_Params params;
	params.TraceStart = TraceStart;
	params.TraceEnd = TraceEnd;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.ServerNotifyHit
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// unsigned char                  bCallerCheck                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// unsigned char                  bInvalidRotation               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ClientImpactLocation           (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 RelativeImpact                 (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FHitResult              Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// TArray<uint32_t>               Checksums                      (ConstParm, Parm, ZeroConstructor, ReferenceParm)
// struct FVector_NetQuantize     Origin                         (ConstParm, Parm, ReferenceParm)
// struct FVector                 TraceStart                     (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 PreLocation                    (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector_NetQuantizeNormal ShootDir                       (Parm)
// float                          TravelDistance                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FAttackId               AttackId                       (Parm)
// uint32_t                       HitSeq                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 RelLocation                    (ConstParm, Parm, IsPlainOldData)
// float                          SpeedLoss                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Trajectory::ServerNotifyHit(unsigned char bCallerCheck, unsigned char bInvalidRotation, const struct FVector& ClientImpactLocation, const struct FVector& RelativeImpact, const struct FHitResult& Impact, TArray<uint32_t> Checksums, const struct FVector_NetQuantize& Origin, const struct FVector& TraceStart, const struct FVector& PreLocation, const struct FVector_NetQuantizeNormal& ShootDir, float TravelDistance, const struct FAttackId& AttackId, uint32_t HitSeq, const struct FVector& RelLocation, float SpeedLoss)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27352);

	ATslWeapon_Trajectory_ServerNotifyHit_Params params;
	params.bCallerCheck = bCallerCheck;
	params.bInvalidRotation = bInvalidRotation;
	params.ClientImpactLocation = ClientImpactLocation;
	params.RelativeImpact = RelativeImpact;
	params.Impact = Impact;
	params.Checksums = Checksums;
	params.Origin = Origin;
	params.TraceStart = TraceStart;
	params.PreLocation = PreLocation;
	params.ShootDir = ShootDir;
	params.TravelDistance = TravelDistance;
	params.AttackId = AttackId;
	params.HitSeq = HitSeq;
	params.RelLocation = RelLocation;
	params.SpeedLoss = SpeedLoss;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.ServerNotifyCrack
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class ATslCharacter*           TargetCharacter                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector_NetQuantize     LocationRelative               (Parm)
// float                          BulletVelocity                 (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Trajectory::ServerNotifyCrack(class ATslCharacter* TargetCharacter, const struct FVector_NetQuantize& LocationRelative, float BulletVelocity)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27348);

	ATslWeapon_Trajectory_ServerNotifyCrack_Params params;
	params.TargetCharacter = TargetCharacter;
	params.LocationRelative = LocationRelative;
	params.BulletVelocity = BulletVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.ServerNotifyAmmoSpawned
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                 ServerStartTrace               (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 Dir                            (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FAttackId               AttackId                       (ConstParm, Parm, ReferenceParm)

void ATslWeapon_Trajectory::ServerNotifyAmmoSpawned(const struct FVector& ServerStartTrace, const struct FVector& Dir, const struct FAttackId& AttackId)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27344);

	ATslWeapon_Trajectory_ServerNotifyAmmoSpawned_Params params;
	params.ServerStartTrace = ServerStartTrace;
	params.Dir = Dir;
	params.AttackId = AttackId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.ServerLogBodyPenetration
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// int                            AttackId                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   DamageZone                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          DamageDiff                     (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Trajectory::ServerLogBodyPenetration(int AttackId, const struct FName& DamageZone, float DamageDiff)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27340);

	ATslWeapon_Trajectory_ServerLogBodyPenetration_Params params;
	params.AttackId = AttackId;
	params.DamageZone = DamageZone;
	params.DamageDiff = DamageDiff;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.ServerChecksumTest
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                 Location                       (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// TArray<uint32_t>               ClientChecksums                (ConstParm, Parm, ZeroConstructor, ReferenceParm)
// unsigned char                  bRotationCallerDetection       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// unsigned char                  bInvalidRotation               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void ATslWeapon_Trajectory::ServerChecksumTest(const struct FVector& Location, TArray<uint32_t> ClientChecksums, unsigned char bRotationCallerDetection, unsigned char bInvalidRotation)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27334);

	ATslWeapon_Trajectory_ServerChecksumTest_Params params;
	params.Location = Location;
	params.ClientChecksums = ClientChecksums;
	params.bRotationCallerDetection = bRotationCallerDetection;
	params.bInvalidRotation = bInvalidRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.OnRep_WeaponSpread
// (Final, Native, Protected)
// Parameters:
// float                          LastWeaponSpread               (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Trajectory::OnRep_WeaponSpread(float LastWeaponSpread)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27332);

	ATslWeapon_Trajectory_OnRep_WeaponSpread_Params params;
	params.LastWeaponSpread = LastWeaponSpread;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Trajectory.IsBulletInAir
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslWeapon_Trajectory::IsBulletInAir()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27330);

	ATslWeapon_Trajectory_IsBulletInAir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetTrajectoryConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrajectoryWeaponData   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FTrajectoryWeaponData ATslWeapon_Trajectory::GetTrajectoryConfig()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27328);

	ATslWeapon_Trajectory_GetTrajectoryConfig_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetRecoilInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRecoilInfo             ReturnValue                    (Parm, OutParm, ReturnParm)

struct FRecoilInfo ATslWeapon_Trajectory::GetRecoilInfo()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27326);

	ATslWeapon_Trajectory_GetRecoilInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetCurrentStabilityVar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Trajectory::GetCurrentStabilityVar()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27324);

	ATslWeapon_Trajectory_GetCurrentStabilityVar_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetCurrentReoveryTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Trajectory::GetCurrentReoveryTarget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27322);

	ATslWeapon_Trajectory_GetCurrentReoveryTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetCurrentRecoilValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslWeapon_Trajectory::GetCurrentRecoilValue()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27320);

	ATslWeapon_Trajectory_GetCurrentRecoilValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetCurrentRecoilTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector2D ATslWeapon_Trajectory::GetCurrentRecoilTarget()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27318);

	ATslWeapon_Trajectory_GetCurrentRecoilTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetBulletRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FRotator ATslWeapon_Trajectory::GetBulletRotation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27316);

	ATslWeapon_Trajectory_GetBulletRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetBulletLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector ATslWeapon_Trajectory::GetBulletLocation()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27314);

	ATslWeapon_Trajectory_GetBulletLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.ClientWallCheckFail
// (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// struct FVector                 TraceStart                     (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 TraceEnd                       (ConstParm, Parm, ReferenceParm, IsPlainOldData)
// struct FVector                 Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslWeapon_Trajectory::ClientWallCheckFail(const struct FVector& TraceStart, const struct FVector& TraceEnd, const struct FVector& Impact)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27310);

	ATslWeapon_Trajectory_ClientWallCheckFail_Params params;
	params.TraceStart = TraceStart;
	params.TraceEnd = TraceEnd;
	params.Impact = Impact;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Melee.ServerNotifyHit
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// TArray<float>                  AimSpeeds                      (ConstParm, Parm, ZeroConstructor, ReferenceParm)
// TArray<struct FHitResult>      Impacts                        (ConstParm, Parm, ZeroConstructor, ReferenceParm)
// struct FAttackId               AttackId                       (Parm)
// uint32_t                       HitSeq                         (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Melee::ServerNotifyHit(TArray<float> AimSpeeds, TArray<struct FHitResult> Impacts, const struct FAttackId& AttackId, uint32_t HitSeq)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27419);

	ATslWeapon_Melee_ServerNotifyHit_Params params;
	params.AimSpeeds = AimSpeeds;
	params.Impacts = Impacts;
	params.AttackId = AttackId;
	params.HitSeq = HitSeq;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Melee.ServerAttack
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// int                            AnimIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Melee::ServerAttack(int AnimIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27417);

	ATslWeapon_Melee_ServerAttack_Params params;
	params.AnimIndex = AnimIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Melee.OnMontageEnded
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*            Montage                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bInterrupted                   (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Melee::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27414);

	ATslWeapon_Melee_OnMontageEnded_Params params;
	params.Montage = Montage;
	params.bInterrupted = bInterrupted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Melee.OnAnimationNotify
// (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*  MeshComp                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   NotifyName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void ATslWeapon_Melee::OnAnimationNotify(class USkeletalMeshComponent* MeshComp, const struct FName& NotifyName)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27411);

	ATslWeapon_Melee_OnAnimationNotify_Params params;
	params.MeshComp = MeshComp;
	params.NotifyName = NotifyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Melee.ClientHit_Confirmed
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FHitResult              Impact                         (ConstParm, Parm, ReferenceParm, IsPlainOldData)

void ATslWeapon_Melee::ClientHit_Confirmed(const struct FHitResult& Impact)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27409);

	ATslWeapon_Melee_ClientHit_Confirmed_Params params;
	params.Impact = Impact;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWeapon_Melee.ClientAttack
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int                            AnimIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void ATslWeapon_Melee::ClientAttack(int AnimIndex)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27407);

	ATslWeapon_Melee_ClientAttack_Params params;
	params.AnimIndex = AnimIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslWebPopupInterface.ShowWebPopup
// (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FWebPopupParam          Param                          (ConstParm, Parm, OutParm, ReferenceParm)

void UTslWebPopupInterface::ShowWebPopup(const struct FWebPopupParam& Param)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27437);

	UTslWebPopupInterface_ShowWebPopup_Params params;
	params.Param = Param;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.VehicleHasDriver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslMotorbikeVehicle::VehicleHasDriver()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27471);

	ATslMotorbikeVehicle_VehicleHasDriver_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlR
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          inFloat                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslMotorbikeVehicle::SetAirControlR(float inFloat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27469);

	ATslMotorbikeVehicle_SetAirControlR_Params params;
	params.inFloat = inFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlQ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          inFloat                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslMotorbikeVehicle::SetAirControlQ(float inFloat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27467);

	ATslMotorbikeVehicle_SetAirControlQ_Params params;
	params.inFloat = inFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlL
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          inFloat                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslMotorbikeVehicle::SetAirControlL(float inFloat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27465);

	ATslMotorbikeVehicle_SetAirControlL_Params params;
	params.inFloat = inFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlF
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          inFloat                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslMotorbikeVehicle::SetAirControlF(float inFloat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27463);

	ATslMotorbikeVehicle_SetAirControlF_Params params;
	params.inFloat = inFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlE
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          inFloat                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslMotorbikeVehicle::SetAirControlE(float inFloat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27461);

	ATslMotorbikeVehicle_SetAirControlE_Params params;
	params.inFloat = inFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlB
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          inFloat                        (Parm, ZeroConstructor, IsPlainOldData)

void ATslMotorbikeVehicle::SetAirControlB(float inFloat)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27459);

	ATslMotorbikeVehicle_SetAirControlB_Params params;
	params.inFloat = inFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.ProcessFlipAndStabilize
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void ATslMotorbikeVehicle::ProcessFlipAndStabilize()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27458);

	ATslMotorbikeVehicle_ProcessFlipAndStabilize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.OnVehicleEjected
// (Final, Native, Private)

void ATslMotorbikeVehicle::OnVehicleEjected()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27457);

	ATslMotorbikeVehicle_OnVehicleEjected_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.OnPostDriverRide
// (Final, Native, Private)

void ATslMotorbikeVehicle::OnPostDriverRide()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27456);

	ATslMotorbikeVehicle_OnPostDriverRide_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.OnPostDriverLeave
// (Final, Native, Private)

void ATslMotorbikeVehicle::OnPostDriverLeave()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27455);

	ATslMotorbikeVehicle_OnPostDriverLeave_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.OnMeshHit
// (Final, Native, Private, HasOutParms, HasDefaults)
// Parameters:
// class UPrimitiveComponent*     HitComp                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class AActor*                  OtherActor                     (Parm, ZeroConstructor, IsPlainOldData)
// class UPrimitiveComponent*     OtherComp                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 NormalImpulse                  (Parm, IsPlainOldData)
// struct FHitResult              Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void ATslMotorbikeVehicle::OnMeshHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27449);

	ATslMotorbikeVehicle_OnMeshHit_Params params;
	params.HitComp = HitComp;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.TslMotorbikeVehicle.IsUsingActiveStabilize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslMotorbikeVehicle::IsUsingActiveStabilize()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27447);

	ATslMotorbikeVehicle_IsUsingActiveStabilize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.IsKickstandActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslMotorbikeVehicle::IsKickstandActive()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27445);

	ATslMotorbikeVehicle_IsKickstandActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.IsFlippingEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslMotorbikeVehicle::IsFlippingEnabled()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27443);

	ATslMotorbikeVehicle_IsFlippingEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.HasContact
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslMotorbikeVehicle::HasContact()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27441);

	ATslMotorbikeVehicle_HasContact_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.GetCOMSteerOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float ATslMotorbikeVehicle::GetCOMSteerOffset()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27439);

	ATslMotorbikeVehicle_GetCOMSteerOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.WidgetShow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FString                 WidgetName                     (Parm, ZeroConstructor)
// EWidgetShowType                WidgetShowType                 (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 OptionalParam                  (Parm, ZeroConstructor, IsPlainOldData)

void UUiHelperFunctions::WidgetShow(class UUserWidget* Widget, const struct FString& WidgetName, EWidgetShowType WidgetShowType, class UObject* OptionalParam)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27879);

	UUiHelperFunctions_WidgetShow_Params params;
	params.Widget = Widget;
	params.WidgetName = WidgetName;
	params.WidgetShowType = WidgetShowType;
	params.OptionalParam = OptionalParam;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.UiHelperFunctions.SortWidgetFormPositionY
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UWidget*>         Widgets                        (Parm, ZeroConstructor)
// bool                           bDescendingOrder               (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UWidget*>         ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UWidget*> UUiHelperFunctions::SortWidgetFormPositionY(TArray<class UWidget*> Widgets, bool bDescendingOrder)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27873);

	UUiHelperFunctions_SortWidgetFormPositionY_Params params;
	params.Widgets = Widgets;
	params.bDescendingOrder = bDescendingOrder;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.SortWidgetFormPositionX
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UWidget*>         Widgets                        (Parm, ZeroConstructor)
// bool                           bDescendingOrder               (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UWidget*>         ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UWidget*> UUiHelperFunctions::SortWidgetFormPositionX(TArray<class UWidget*> Widgets, bool bDescendingOrder)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27867);

	UUiHelperFunctions_SortWidgetFormPositionX_Params params;
	params.Widgets = Widgets;
	params.bDescendingOrder = bDescendingOrder;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.SortPlayerMatchResultInfosByRanking
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FTslPlayerMatchResultInfo> PlayerMatchResultInfos         (Parm, ZeroConstructor)
// TArray<struct FTslPlayerMatchResultInfo> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FTslPlayerMatchResultInfo> UUiHelperFunctions::SortPlayerMatchResultInfosByRanking(TArray<struct FTslPlayerMatchResultInfo> PlayerMatchResultInfos)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27862);

	UUiHelperFunctions_SortPlayerMatchResultInfosByRanking_Params params;
	params.PlayerMatchResultInfos = PlayerMatchResultInfos;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.SortItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<TScriptInterface<class USlotInterface>> InItemList                     (Parm, ZeroConstructor)
// TArray<TScriptInterface<class USlotInterface>> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<TScriptInterface<class USlotInterface>> UUiHelperFunctions::SortItem(TArray<TScriptInterface<class USlotInterface>> InItemList)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27857);

	UUiHelperFunctions_SortItem_Params params;
	params.InItemList = InItemList;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.SetTslBlur
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlurLevel                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          DepthBlurBlackPoint            (Parm, ZeroConstructor, IsPlainOldData)
// float                          DepthBlurWhitePoint            (Parm, ZeroConstructor, IsPlainOldData)

void UUiHelperFunctions::SetTslBlur(class UObject* WorldContextObject, float BlurLevel, float DepthBlurBlackPoint, float DepthBlurWhitePoint)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27852);

	UUiHelperFunctions_SetTslBlur_Params params;
	params.WorldContextObject = WorldContextObject;
	params.BlurLevel = BlurLevel;
	params.DepthBlurBlackPoint = DepthBlurBlackPoint;
	params.DepthBlurWhitePoint = DepthBlurWhitePoint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.UiHelperFunctions.ProcessSelfPutMode
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// TScriptInterface<class USlotInterface> Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// TScriptInterface<class USlotContainerInterface> SlotContainer                  (Parm, ZeroConstructor, IsPlainOldData)
// int                            SelectIndex                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// TArray<int>                    EnableSelfPutIndexList         (Parm, OutParm, ZeroConstructor)
// EWeaponAttachmentSlotID        AttachmentSlotID               (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::ProcessSelfPutMode(class UUserWidget* Widget, const TScriptInterface<class USlotInterface>& Slot, const TScriptInterface<class USlotContainerInterface>& SlotContainer, int* SelectIndex, TArray<int>* EnableSelfPutIndexList, EWeaponAttachmentSlotID* AttachmentSlotID)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27842);

	UUiHelperFunctions_ProcessSelfPutMode_Params params;
	params.Widget = Widget;
	params.Slot = Slot;
	params.SlotContainer = SlotContainer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SelectIndex != nullptr)
		*SelectIndex = params.SelectIndex;
	if (EnableSelfPutIndexList != nullptr)
		*EnableSelfPutIndexList = params.EnableSelfPutIndexList;
	if (AttachmentSlotID != nullptr)
		*AttachmentSlotID = params.AttachmentSlotID;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsWarning
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsWarning(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27839);

	UUiHelperFunctions_IsWarning_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsThereAnyPlayingAnimation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// TArray<class UWidgetAnimation*> AnimationArray                 (ConstParm, Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsThereAnyPlayingAnimation(class UUserWidget* Widget, TArray<class UWidgetAnimation*> AnimationArray)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27834);

	UUiHelperFunctions_IsThereAnyPlayingAnimation_Params params;
	params.Widget = Widget;
	params.AnimationArray = AnimationArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsReplayingKillcam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsReplayingKillcam(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27831);

	UUiHelperFunctions_IsReplayingKillcam_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsReplaying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsReplaying(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27828);

	UUiHelperFunctions_IsReplaying_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsObserverSpectating
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsObserverSpectating(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27825);

	UUiHelperFunctions_IsObserverSpectating_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsNavigateKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsNavigateKey(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27822);

	UUiHelperFunctions_IsNavigateKey_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsLastSpectatorTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsLastSpectatorTeam(class UUserWidget* Widget, class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27818);

	UUiHelperFunctions_IsLastSpectatorTeam_Params params;
	params.Widget = Widget;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsLastSpectatedCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsLastSpectatedCharacter(class UUserWidget* Widget, class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27814);

	UUiHelperFunctions_IsLastSpectatedCharacter_Params params;
	params.Widget = Widget;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsKickEnableCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsKickEnableCharacter(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27811);

	UUiHelperFunctions_IsKickEnableCharacter_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsInNextPlayzone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsInNextPlayzone(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27808);

	UUiHelperFunctions_IsInNextPlayzone_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsHitted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            State                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsHitted(int State)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27805);

	UUiHelperFunctions_IsHitted_Params params;
	params.State = State;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGroggyByTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATeam*                   Team                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsGroggyByTeam(class ATeam* Team)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27802);

	UUiHelperFunctions_IsGroggyByTeam_Params params;
	params.Team = Team;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGamepadY
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsGamepadY(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27799);

	UUiHelperFunctions_IsGamepadY_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGamepadX
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsGamepadX(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27796);

	UUiHelperFunctions_IsGamepadX_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGamepadUp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsGamepadUp(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27793);

	UUiHelperFunctions_IsGamepadUp_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGamepadRight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsGamepadRight(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27790);

	UUiHelperFunctions_IsGamepadRight_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGamepadLeft
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsGamepadLeft(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27787);

	UUiHelperFunctions_IsGamepadLeft_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGamepadDown
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsGamepadDown(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27784);

	UUiHelperFunctions_IsGamepadDown_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGamepadB
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsGamepadB(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27781);

	UUiHelperFunctions_IsGamepadB_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGamepadA
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                    InKey                          (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsGamepadA(const struct FKey& InKey)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27778);

	UUiHelperFunctions_IsGamepadA_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsBluezoneGpsReset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsBluezoneGpsReset(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27775);

	UUiHelperFunctions_IsBluezoneGpsReset_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsAttacked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            State                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::IsAttacked(int State)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27772);

	UUiHelperFunctions_IsAttacked_Params params;
	params.State = State;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.HaveDurability
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class USlotInterface> ItemSlot                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UUiHelperFunctions::HaveDurability(const TScriptInterface<class USlotInterface>& ItemSlot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27769);

	UUiHelperFunctions_HaveDurability_Params params;
	params.ItemSlot = ItemSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetWeaponProcessor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class AWeaponProcessor*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AWeaponProcessor* UUiHelperFunctions::GetWeaponProcessor(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27766);

	UUiHelperFunctions_GetWeaponProcessor_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetViewTargetTslCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UUiHelperFunctions::GetViewTargetTslCharacter(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27763);

	UUiHelperFunctions_GetViewTargetTslCharacter_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetVehicleUI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                   VehiclePawn                    (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* UUiHelperFunctions::GetVehicleUI(class APawn* VehiclePawn)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27760);

	UUiHelperFunctions_GetVehicleUI_Params params;
	params.VehiclePawn = VehiclePawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetUpWidgetByTslFocusableWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UWidget*                 ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UWidget* UUiHelperFunctions::GetUpWidgetByTslFocusableWidget(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27757);

	UUiHelperFunctions_GetUpWidgetByTslFocusableWidget_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTslSpectatorPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class ATslSpectatorPawn*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslSpectatorPawn* UUiHelperFunctions::GetTslSpectatorPawn(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27754);

	UUiHelperFunctions_GetTslSpectatorPawn_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTslPlayerState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// class ATslPlayerState*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerState* UUiHelperFunctions::GetTslPlayerState(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27751);

	UUiHelperFunctions_GetTslPlayerState_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTslHUD
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class ATslHUD*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslHUD* UUiHelperFunctions::GetTslHUD(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27748);

	UUiHelperFunctions_GetTslHUD_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTslCharacterByNetId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FString                 NetId                          (Parm, ZeroConstructor)
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UUiHelperFunctions::GetTslCharacterByNetId(class UUserWidget* Widget, const struct FString& NetId)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27744);

	UUiHelperFunctions_GetTslCharacterByNetId_Params params;
	params.Widget = Widget;
	params.NetId = NetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTeamId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UUiHelperFunctions::GetTeamId(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27741);

	UUiHelperFunctions_GetTeamId_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTeamColors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            TeamCount                      (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FLinearColor>    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FLinearColor> UUiHelperFunctions::GetTeamColors(int TeamCount)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27737);

	UUiHelperFunctions_GetTeamColors_Params params;
	params.TeamCount = TeamCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTeamColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslCharacter*           TslCharacter                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FLinearColor UUiHelperFunctions::GetTeamColor(class ATslCharacter* TslCharacter)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27734);

	UUiHelperFunctions_GetTeamColor_Params params;
	params.TslCharacter = TslCharacter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetSubjectToReportType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// ESubjectToReport               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

ESubjectToReport UUiHelperFunctions::GetSubjectToReportType(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27730);

	UUiHelperFunctions_GetSubjectToReportType_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetSubjectToReport
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FSubjectToReport> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FSubjectToReport> UUiHelperFunctions::GetSubjectToReport()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27727);

	UUiHelperFunctions_GetSubjectToReport_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetSortedReplicateCharactersBySpectatorPawnDistance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// TArray<class ATslCharacter*>   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class ATslCharacter*> UUiHelperFunctions::GetSortedReplicateCharactersBySpectatorPawnDistance(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27723);

	UUiHelperFunctions_GetSortedReplicateCharactersBySpectatorPawnDistance_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetSortedReplicateCharactersByLastHitTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// TArray<class ATslCharacter*>   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class ATslCharacter*> UUiHelperFunctions::GetSortedReplicateCharactersByLastHitTime(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27719);

	UUiHelperFunctions_GetSortedReplicateCharactersByLastHitTime_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetRightWidgetByTslFocusableWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UWidget*                 ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UWidget* UUiHelperFunctions::GetRightWidgetByTslFocusableWidget(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27716);

	UUiHelperFunctions_GetRightWidgetByTslFocusableWidget_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetReportCauses
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// TArray<struct FReportCauseData> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FReportCauseData> UUiHelperFunctions::GetReportCauses(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27712);

	UUiHelperFunctions_GetReportCauses_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetRecordPlayerNetIdInReplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UUiHelperFunctions::GetRecordPlayerNetIdInReplay(class UObject* WorldContextObject)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27709);

	UUiHelperFunctions_GetRecordPlayerNetIdInReplay_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetPlayerNetID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UUiHelperFunctions::GetPlayerNetID(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27706);

	UUiHelperFunctions_GetPlayerNetID_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetPlayerName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UUiHelperFunctions::GetPlayerName(class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27703);

	UUiHelperFunctions_GetPlayerName_Params params;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetPlayerIcon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MarkerNum                      (Parm, ZeroConstructor, IsPlainOldData)
// class UTexture*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture* UUiHelperFunctions::GetPlayerIcon(int MarkerNum)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27700);

	UUiHelperFunctions_GetPlayerIcon_Params params;
	params.MarkerNum = MarkerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetOwningTslPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class ATslPlayerController*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslPlayerController* UUiHelperFunctions::GetOwningTslPlayerController(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27697);

	UUiHelperFunctions_GetOwningTslPlayerController_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetOwningTslCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UUiHelperFunctions::GetOwningTslCharacter(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27694);

	UUiHelperFunctions_GetOwningTslCharacter_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetNextPlayzoneRadius_BluezoneGPS
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UUiHelperFunctions::GetNextPlayzoneRadius_BluezoneGPS(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27691);

	UUiHelperFunctions_GetNextPlayzoneRadius_BluezoneGPS_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetNextPlayzonePosition_BluezoneGPS
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UUiHelperFunctions::GetNextPlayzonePosition_BluezoneGPS(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27688);

	UUiHelperFunctions_GetNextPlayzonePosition_BluezoneGPS_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetMarkerIcon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MarkerNum                      (Parm, ZeroConstructor, IsPlainOldData)
// class UTexture*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture* UUiHelperFunctions::GetMarkerIcon(int MarkerNum)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27685);

	UUiHelperFunctions_GetMarkerIcon_Params params;
	params.MarkerNum = MarkerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetMarkerColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MarkerNum                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FLinearColor UUiHelperFunctions::GetMarkerColor(int MarkerNum)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27682);

	UUiHelperFunctions_GetMarkerColor_Params params;
	params.MarkerNum = MarkerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetMapDeathIcon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MarkerNum                      (Parm, ZeroConstructor, IsPlainOldData)
// class UTexture*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture* UUiHelperFunctions::GetMapDeathIcon(int MarkerNum)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27679);

	UUiHelperFunctions_GetMapDeathIcon_Params params;
	params.MarkerNum = MarkerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetLeftWidgetByTslFocusableWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UWidget*                 ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UWidget* UUiHelperFunctions::GetLeftWidgetByTslFocusableWidget(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27676);

	UUiHelperFunctions_GetLeftWidgetByTslFocusableWidget_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetLastSpectatedCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class ATslCharacter*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslCharacter* UUiHelperFunctions::GetLastSpectatedCharacter(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27673);

	UUiHelperFunctions_GetLastSpectatedCharacter_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetInventoryFacade
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class AInventoryFacade*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AInventoryFacade* UUiHelperFunctions::GetInventoryFacade(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27670);

	UUiHelperFunctions_GetInventoryFacade_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetInventory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class AInventory*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AInventory* UUiHelperFunctions::GetInventory(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27667);

	UUiHelperFunctions_GetInventory_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetIndicatorIcon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MarkerNum                      (Parm, ZeroConstructor, IsPlainOldData)
// class UTexture*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture* UUiHelperFunctions::GetIndicatorIcon(int MarkerNum)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27664);

	UUiHelperFunctions_GetIndicatorIcon_Params params;
	params.MarkerNum = MarkerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetHealthRatioByTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATeam*                   Team                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UUiHelperFunctions::GetHealthRatioByTeam(class ATeam* Team)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27661);

	UUiHelperFunctions_GetHealthRatioByTeam_Params params;
	params.Team = Team;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetHealLimit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UUiHelperFunctions::GetHealLimit(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27658);

	UUiHelperFunctions_GetHealLimit_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetGroggyHealthRatioByTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATeam*                   Team                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UUiHelperFunctions::GetGroggyHealthRatioByTeam(class ATeam* Team)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27655);

	UUiHelperFunctions_GetGroggyHealthRatioByTeam_Params params;
	params.Team = Team;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetEquipment
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class AEquipment*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEquipment* UUiHelperFunctions::GetEquipment(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27652);

	UUiHelperFunctions_GetEquipment_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetDurabilityRatio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class USlotInterface> ItemSlot                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UUiHelperFunctions::GetDurabilityRatio(const TScriptInterface<class USlotInterface>& ItemSlot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27649);

	UUiHelperFunctions_GetDurabilityRatio_Params params;
	params.ItemSlot = ItemSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetDownWidgetByTslFocusableWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                 Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UWidget*                 ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UWidget* UUiHelperFunctions::GetDownWidgetByTslFocusableWidget(class UWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27646);

	UUiHelperFunctions_GetDownWidgetByTslFocusableWidget_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetDistanceFromSpectatorPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class ATslCharacter*           Character                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UUiHelperFunctions::GetDistanceFromSpectatorPawn(class UUserWidget* Widget, class ATslCharacter* Character)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27642);

	UUiHelperFunctions_GetDistanceFromSpectatorPawn_Params params;
	params.Widget = Widget;
	params.Character = Character;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetDetailCauseTypeDescriptionList
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EReportCause                   ReportCause                    (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FReportDetailCauseTypeDescription> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FReportDetailCauseTypeDescription> UUiHelperFunctions::GetDetailCauseTypeDescriptionList(EReportCause ReportCause)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27637);

	UUiHelperFunctions_GetDetailCauseTypeDescriptionList_Params params;
	params.ReportCause = ReportCause;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetCurrentPlayzoneRadius_BluezoneGPS
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UUiHelperFunctions::GetCurrentPlayzoneRadius_BluezoneGPS(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27634);

	UUiHelperFunctions_GetCurrentPlayzoneRadius_BluezoneGPS_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetCurrentPlayzonePosition_BluezoneGPS
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FVector UUiHelperFunctions::GetCurrentPlayzonePosition_BluezoneGPS(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27631);

	UUiHelperFunctions_GetCurrentPlayzonePosition_BluezoneGPS_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetCompassIcon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MarkerNum                      (Parm, ZeroConstructor, IsPlainOldData)
// class UTexture*                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UTexture* UUiHelperFunctions::GetCompassIcon(int MarkerNum)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27628);

	UUiHelperFunctions_GetCompassIcon_Params params;
	params.MarkerNum = MarkerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetChildrenOfPanel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPanelWidget*            PanelWidget                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// TArray<class UWidget*>         ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UWidget*> UUiHelperFunctions::GetChildrenOfPanel(class UPanelWidget* PanelWidget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27624);

	UUiHelperFunctions_GetChildrenOfPanel_Params params;
	params.PanelWidget = PanelWidget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetCharacterStateByTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATeam*                   Team                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UUiHelperFunctions::GetCharacterStateByTeam(class ATeam* Team)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27621);

	UUiHelperFunctions_GetCharacterStateByTeam_Params params;
	params.Team = Team;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetBluezoneWarningTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UUiHelperFunctions::GetBluezoneWarningTime(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27618);

	UUiHelperFunctions_GetBluezoneWarningTime_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetBluezoneReleaseTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UUiHelperFunctions::GetBluezoneReleaseTime(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27615);

	UUiHelperFunctions_GetBluezoneReleaseTime_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetBluezoneGpsState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*             Widget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UUiHelperFunctions::GetBluezoneGpsState(class UUserWidget* Widget)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27612);

	UUiHelperFunctions_GetBluezoneGpsState_Params params;
	params.Widget = Widget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.FindNextWidgetIndexInPanel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPanelWidget*            PanelWidget                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UWidget*                 StartWidget                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           bReverseDir                    (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UUiHelperFunctions::FindNextWidgetIndexInPanel(class UPanelWidget* PanelWidget, class UWidget* StartWidget, bool bReverseDir)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27607);

	UUiHelperFunctions_FindNextWidgetIndexInPanel_Params params;
	params.PanelWidget = PanelWidget;
	params.StartWidget = StartWidget;
	params.bReverseDir = bReverseDir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.DrawDottedLine
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPaintContext           Context                        (Parm, OutParm, ReferenceParm)
// struct FBox2D                  Rect                           (ConstParm, Parm, OutParm, ReferenceParm)
// struct FVector2D               PositionA                      (Parm, IsPlainOldData)
// struct FVector2D               PositionB                      (Parm, IsPlainOldData)
// float                          DottedLength                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          DottedInterval                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            Tint                           (Parm, IsPlainOldData)
// bool                           bAntiAlias                     (Parm, ZeroConstructor, IsPlainOldData)

void UUiHelperFunctions::DrawDottedLine(const struct FBox2D& Rect, const struct FVector2D& PositionA, const struct FVector2D& PositionB, float DottedLength, float DottedInterval, const struct FLinearColor& Tint, bool bAntiAlias, struct FPaintContext* Context)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27598);

	UUiHelperFunctions_DrawDottedLine_Params params;
	params.Rect = Rect;
	params.PositionA = PositionA;
	params.PositionB = PositionB;
	params.DottedLength = DottedLength;
	params.DottedInterval = DottedInterval;
	params.Tint = Tint;
	params.bAntiAlias = bAntiAlias;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Context != nullptr)
		*Context = params.Context;
}


// Function TslGame.UiHelperFunctions.CastWeaponItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class USlotInterface> ItemSlot                       (Parm, ZeroConstructor, IsPlainOldData)
// class UWeaponItem*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UWeaponItem* UUiHelperFunctions::CastWeaponItem(const TScriptInterface<class USlotInterface>& ItemSlot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27595);

	UUiHelperFunctions_CastWeaponItem_Params params;
	params.ItemSlot = ItemSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.CastEquipableItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class USlotInterface> ItemSlot                       (Parm, ZeroConstructor, IsPlainOldData)
// class UEquipableItem*          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEquipableItem* UUiHelperFunctions::CastEquipableItem(const TScriptInterface<class USlotInterface>& ItemSlot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27592);

	UUiHelperFunctions_CastEquipableItem_Params params;
	params.ItemSlot = ItemSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.CastAttachableItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class USlotInterface> ItemSlot                       (Parm, ZeroConstructor, IsPlainOldData)
// class UAttachableItem*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UAttachableItem* UUiHelperFunctions::CastAttachableItem(const TScriptInterface<class USlotInterface>& ItemSlot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27589);

	UUiHelperFunctions_CastAttachableItem_Params params;
	params.ItemSlot = ItemSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.UiHelperFunctions.CalculateWeightGaugeUpParamsByItem
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// float                          TotalMaxSpace                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          CurrMaxSpace                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          CurrSpace                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          FocusedItemWeight              (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutCurrMaxSpaceStart           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutCurrSpaceStart              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutFeedbackStart               (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           OutIsPositive                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UUiHelperFunctions::CalculateWeightGaugeUpParamsByItem(float TotalMaxSpace, float CurrMaxSpace, float CurrSpace, float FocusedItemWeight, float* OutCurrMaxSpaceStart, float* OutCurrSpaceStart, float* OutFeedbackStart, bool* OutIsPositive)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27580);

	UUiHelperFunctions_CalculateWeightGaugeUpParamsByItem_Params params;
	params.TotalMaxSpace = TotalMaxSpace;
	params.CurrMaxSpace = CurrMaxSpace;
	params.CurrSpace = CurrSpace;
	params.FocusedItemWeight = FocusedItemWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutCurrMaxSpaceStart != nullptr)
		*OutCurrMaxSpaceStart = params.OutCurrMaxSpaceStart;
	if (OutCurrSpaceStart != nullptr)
		*OutCurrSpaceStart = params.OutCurrSpaceStart;
	if (OutFeedbackStart != nullptr)
		*OutFeedbackStart = params.OutFeedbackStart;
	if (OutIsPositive != nullptr)
		*OutIsPositive = params.OutIsPositive;
}


// Function TslGame.UiHelperFunctions.BuildFocusableWidgetList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPanelWidget*            Panel                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// TArray<class UWidget*>         FocusableWidgetList            (Parm, ZeroConstructor)
// TArray<class UWidget*>         ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UWidget*> UUiHelperFunctions::BuildFocusableWidgetList(class UPanelWidget* Panel, TArray<class UWidget*> FocusableWidgetList)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27574);

	UUiHelperFunctions_BuildFocusableWidgetList_Params params;
	params.Panel = Panel;
	params.FocusableWidgetList = FocusableWidgetList;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	static auto defaultObj = StaticClass()->CreateDefaultObject();
	defaultObj->ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslMotoSeatActor.IsEntryAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool ATslMotoSeatActor::IsEntryAllowed()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27890);

	ATslMotoSeatActor_IsEntryAllowed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.TslMotoSeatActor.HandleFlipAndKickstand
// (Final, Native, Public, BlueprintCallable)

void ATslMotoSeatActor::HandleFlipAndKickstand()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27889);

	ATslMotoSeatActor_HandleFlipAndKickstand_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.UpdatePosition
// (Native, Protected)

void UVivoxBaseComponent::UpdatePosition()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27937);

	UVivoxBaseComponent_UpdatePosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.SetVoiceChannelType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVivoxChannelType              ChannelType                    (Parm, ZeroConstructor, IsPlainOldData)

void UVivoxBaseComponent::SetVoiceChannelType(EVivoxChannelType ChannelType)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27934);

	UVivoxBaseComponent_SetVoiceChannelType_Params params;
	params.ChannelType = ChannelType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.SetParticipantMute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 TargetUniqueId                 (Parm, ZeroConstructor)
// bool                           bIsMuted                       (Parm, ZeroConstructor, IsPlainOldData)

void UVivoxBaseComponent::SetParticipantMute(const struct FString& TargetUniqueId, bool bIsMuted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27931);

	UVivoxBaseComponent_SetParticipantMute_Params params;
	params.TargetUniqueId = TargetUniqueId;
	params.bIsMuted = bIsMuted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.SetLocalVoiceOutputVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            UserSettingVolume              (Parm, ZeroConstructor, IsPlainOldData)

void UVivoxBaseComponent::SetLocalVoiceOutputVolume(int UserSettingVolume)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27929);

	UVivoxBaseComponent_SetLocalVoiceOutputVolume_Params params;
	params.UserSettingVolume = UserSettingVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.SetLocalVoiceOutputMuted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bIsMuted                       (Parm, ZeroConstructor, IsPlainOldData)

void UVivoxBaseComponent::SetLocalVoiceOutputMuted(bool bIsMuted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27927);

	UVivoxBaseComponent_SetLocalVoiceOutputMuted_Params params;
	params.bIsMuted = bIsMuted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.SetLocalVoiceInputVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            UserSettingVolume              (Parm, ZeroConstructor, IsPlainOldData)

void UVivoxBaseComponent::SetLocalVoiceInputVolume(int UserSettingVolume)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27925);

	UVivoxBaseComponent_SetLocalVoiceInputVolume_Params params;
	params.UserSettingVolume = UserSettingVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.SetLocalVoiceInputMuted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bIsMuted                       (Parm, ZeroConstructor, IsPlainOldData)

void UVivoxBaseComponent::SetLocalVoiceInputMuted(bool bIsMuted)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27923);

	UVivoxBaseComponent_SetLocalVoiceInputMuted_Params params;
	params.bIsMuted = bIsMuted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ServerLogin
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void UVivoxBaseComponent::ServerLogin()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27922);

	UVivoxBaseComponent_ServerLogin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ServerJoinTeamChannel
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void UVivoxBaseComponent::ServerJoinTeamChannel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27921);

	UVivoxBaseComponent_ServerJoinTeamChannel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ServerJoinGlobalChannel
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void UVivoxBaseComponent::ServerJoinGlobalChannel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27920);

	UVivoxBaseComponent_ServerJoinGlobalChannel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ResetTeamChannelJoinState
// (Final, Native, Private)

void UVivoxBaseComponent::ResetTeamChannelJoinState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27919);

	UVivoxBaseComponent_ResetTeamChannelJoinState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ResetLoginState
// (Final, Native, Private)

void UVivoxBaseComponent::ResetLoginState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27918);

	UVivoxBaseComponent_ResetLoginState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ResetGlobalChannelJoinState
// (Final, Native, Private)

void UVivoxBaseComponent::ResetGlobalChannelJoinState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27917);

	UVivoxBaseComponent_ResetGlobalChannelJoinState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ResetConnectionState
// (Final, Native, Private)

void UVivoxBaseComponent::ResetConnectionState()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27916);

	UVivoxBaseComponent_ResetConnectionState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.RefreshDevices
// (Final, Native, Private)

void UVivoxBaseComponent::RefreshDevices()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27915);

	UVivoxBaseComponent_RefreshDevices_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.GetVoiceChannelType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVivoxChannelType              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

EVivoxChannelType UVivoxBaseComponent::GetVoiceChannelType()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27912);

	UVivoxBaseComponent_GetVoiceChannelType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.GetLocalVoiceOutputVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UVivoxBaseComponent::GetLocalVoiceOutputVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27910);

	UVivoxBaseComponent_GetLocalVoiceOutputVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.GetLocalVoiceOutputMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UVivoxBaseComponent::GetLocalVoiceOutputMuted()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27908);

	UVivoxBaseComponent_GetLocalVoiceOutputMuted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.GetLocalVoiceInputVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UVivoxBaseComponent::GetLocalVoiceInputVolume()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27906);

	UVivoxBaseComponent_GetLocalVoiceInputVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.GetLocalVoiceInputMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UVivoxBaseComponent::GetLocalVoiceInputMuted()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27904);

	UVivoxBaseComponent_GetLocalVoiceInputMuted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.ClientLogin
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// struct FString                 AccessToken                    (Parm, ZeroConstructor)

void UVivoxBaseComponent::ClientLogin(const struct FString& AccessToken)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27902);

	UVivoxBaseComponent_ClientLogin_Params params;
	params.AccessToken = AccessToken;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ClientLeaveTeamChannel
// (Net, NetReliable, Native, Event, Protected, NetClient)

void UVivoxBaseComponent::ClientLeaveTeamChannel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27901);

	UVivoxBaseComponent_ClientLeaveTeamChannel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ClientLeaveGlobalChannel
// (Net, NetReliable, Native, Event, Protected, NetClient)

void UVivoxBaseComponent::ClientLeaveGlobalChannel()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27900);

	UVivoxBaseComponent_ClientLeaveGlobalChannel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ClientJoinTeamChannel
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// struct FString                 AccessToken                    (Parm, ZeroConstructor)

void UVivoxBaseComponent::ClientJoinTeamChannel(const struct FString& AccessToken)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27898);

	UVivoxBaseComponent_ClientJoinTeamChannel_Params params;
	params.AccessToken = AccessToken;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.ClientJoinGlobalChannel
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// struct FString                 AccessToken                    (Parm, ZeroConstructor)

void UVivoxBaseComponent::ClientJoinGlobalChannel(const struct FString& AccessToken)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27896);

	UVivoxBaseComponent_ClientJoinGlobalChannel_Params params;
	params.AccessToken = AccessToken;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxBaseComponent.CalculateOutputVolumeFromModifiers
// (Final, Native, Protected, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UVivoxBaseComponent::CalculateOutputVolumeFromModifiers()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27894);

	UVivoxBaseComponent_CalculateOutputVolumeFromModifiers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.CalculateInputVolumeFromModifiers
// (Final, Native, Protected, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UVivoxBaseComponent::CalculateInputVolumeFromModifiers()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27892);

	UVivoxBaseComponent_CalculateInputVolumeFromModifiers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.VivoxComponent.ServerTestAccessToken
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UVivoxComponent::ServerTestAccessToken()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27956);

	UVivoxComponent_ServerTestAccessToken_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxComponent.ServerSetObserverTeamNum
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int                            NewTeamNum                     (Parm, ZeroConstructor, IsPlainOldData)

void UVivoxComponent::ServerSetObserverTeamNum(int NewTeamNum)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27954);

	UVivoxComponent_ServerSetObserverTeamNum_Params params;
	params.NewTeamNum = NewTeamNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxComponent.ApplyTimedVolumeModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVivoxChannelType              ChannelType                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          NewModifier                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          RestoreDuration                (Parm, ZeroConstructor, IsPlainOldData)

void UVivoxComponent::ApplyTimedVolumeModifier(EVivoxChannelType ChannelType, float NewModifier, float Duration, float RestoreDuration)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27948);

	UVivoxComponent_ApplyTimedVolumeModifier_Params params;
	params.ChannelType = ChannelType;
	params.NewModifier = NewModifier;
	params.Duration = Duration;
	params.RestoreDuration = RestoreDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxManager.OnRevokeKeySuccess
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*          Response                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UVivoxManager::OnRevokeKeySuccess(class UVivoxResponse* Response)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27972);

	UVivoxManager_OnRevokeKeySuccess_Params params;
	params.Response = Response;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxManager.OnRevokeKeyFail
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*          Response                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UVivoxManager::OnRevokeKeyFail(class UVivoxResponse* Response)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27970);

	UVivoxManager_OnRevokeKeyFail_Params params;
	params.Response = Response;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxManager.OnChannelSuccess
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*          Response                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UVivoxManager::OnChannelSuccess(class UVivoxResponse* Response)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27968);

	UVivoxManager_OnChannelSuccess_Params params;
	params.Response = Response;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxManager.OnChannelFail
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*          Response                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UVivoxManager::OnChannelFail(class UVivoxResponse* Response)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27966);

	UVivoxManager_OnChannelFail_Params params;
	params.Response = Response;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxManager.OnAddKeySuccess
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*          Response                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UVivoxManager::OnAddKeySuccess(class UVivoxResponse* Response)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27964);

	UVivoxManager_OnAddKeySuccess_Params params;
	params.Response = Response;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.VivoxManager.OnAddKeyFail
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*          Response                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UVivoxManager::OnAddKeyFail(class UVivoxResponse* Response)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27962);

	UVivoxManager_OnAddKeyFail_Params params;
	params.Response = Response;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponAnimInfoComponent.SetAccessorySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*  NewAccessoryComponent          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// EAccessorySlot                 Slot                           (Parm, ZeroConstructor, IsPlainOldData)

void UWeaponAnimInfoComponent::SetAccessorySlot(class UTslAccessoryComponent* NewAccessoryComponent, EAccessorySlot Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(28010);

	UWeaponAnimInfoComponent_SetAccessorySlot_Params params;
	params.NewAccessoryComponent = NewAccessoryComponent;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponAnimInfoComponent.HasWeaponLeftHandIKSocket
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              Weapon                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UWeaponAnimInfoComponent::HasWeaponLeftHandIKSocket(class ATslWeapon* Weapon)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(28007);

	UWeaponAnimInfoComponent_HasWeaponLeftHandIKSocket_Params params;
	params.Weapon = Weapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.GetWeaponLeftHandIKTransform
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              Weapon                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UWeaponAnimInfoComponent::GetWeaponLeftHandIKTransform(class ATslWeapon* Weapon)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(28004);

	UWeaponAnimInfoComponent_GetWeaponLeftHandIKTransform_Params params;
	params.Weapon = Weapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.GetWeaponHandIK_Right
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              Weapon                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UWeaponAnimInfoComponent::GetWeaponHandIK_Right(class ATslWeapon* Weapon)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(28001);

	UWeaponAnimInfoComponent_GetWeaponHandIK_Right_Params params;
	params.Weapon = Weapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.GetWeaponHandIK_Left
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              Weapon                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UWeaponAnimInfoComponent::GetWeaponHandIK_Left(class ATslWeapon* Weapon)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27998);

	UWeaponAnimInfoComponent_GetWeaponHandIK_Left_Params params;
	params.Weapon = Weapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.GetCurrentWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class ATslWeapon* UWeaponAnimInfoComponent::GetCurrentWeapon()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27996);

	UWeaponAnimInfoComponent_GetCurrentWeapon_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.GetAccessorySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAccessorySlot                 Slot                           (Parm, ZeroConstructor, IsPlainOldData)
// class UTslAccessoryComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UTslAccessoryComponent* UWeaponAnimInfoComponent::GetAccessorySlot(EAccessorySlot Slot)
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(27992);

	UWeaponAnimInfoComponent_GetAccessorySlot_Params params;
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function TslGame.WeaponClone.UpdateSkinData
// (Final, Native, Public)

void UWeaponClone::UpdateSkinData()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(28033);

	UWeaponClone_UpdateSkinData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function TslGame.WeaponClone.Update
// (Final, Native, Public)

void UWeaponClone::Update()
{
	static UFunction* fn = nullptr; 
	if (!fn) fn = UObject::GetObjectCasted<UFunction>(28032);

	UWeaponClone_Update_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
